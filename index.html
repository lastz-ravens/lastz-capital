<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Hex Map (Desert & Grass + Bases / Local)</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      height: 100%;
      overflow: hidden;
      background: #050608;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5f5;
    }
    #map-canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: radial-gradient(circle at top, #1d2838 0, #050608 50%);
      cursor: grab;
    }
    #map-canvas.dragging { cursor: grabbing; }

    .hud {
      position: fixed;
      right: 10px;
      bottom: 10px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .75);
      backdrop-filter: blur(10px);
      font-size: 11px;
      display: flex;
      gap: 8px;
      align-items: center;
      pointer-events: none;
      z-index: 10;
    }
    .hud span.label { opacity: .6; }
    .hud span.value { font-variant-numeric: tabular-nums; }

    .hint {
      position: fixed;
      left: 10px;
      bottom: 10px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .75);
      backdrop-filter: blur(10px);
      font-size: 11px;
      opacity: .85;
      pointer-events: none;
      z-index: 10;
      max-width: 520px;
    }

    /* „Çµ„Ç§„Éâ„Éê„ÉºÔºàÂü∫Âú∞„É™„Çπ„ÉàÔºâ */
    .sidebar {
      position: fixed;
      left: 10px;
      top: 10px;
      width: 270px;
      padding: 10px;
      border-radius: 16px;
      background: rgba(5, 6, 8, 0.96);
      backdrop-filter: blur(16px);
      font-size: 12px;
      z-index: 20;
      pointer-events: auto;
      max-height: calc(100% - 20px);
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
      transition: max-height 0.2s ease, padding 0.2s ease;
    }
    .sidebar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      margin-bottom: 6px;
    }
    .sidebar-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      opacity: 0.85;
    }
    .sidebar-actions {
      display: flex;
      gap: 4px;
      flex-shrink: 0;
      align-items: center;
    }
    .sidebar-actions button {
      border: none;
      border-radius: 999px;
      padding: 2px 6px;
      font-size: 10px;
      cursor: pointer;
      background: rgba(255,255,255,0.14);
      color: #f5f5f5;
      white-space: nowrap;
    }
    .sidebar-actions button:hover {
      background: rgba(255,255,255,0.26);
    }

    /* Êäò„Çä„Åü„Åü„Åø„Éú„Çø„É≥ */
    #toggle-sidebar {
      font-weight: 700;
      padding: 2px 7px;
      min-width: 24px;
      text-align: center;
    }

    #base-list {
      list-style: none;
      margin: 0;
      padding: 0;
      overflow-y: auto;
      flex: 1;
    }
    .sidebar-note {
      margin-top: 6px;
      font-size: 10px;
      opacity: 0.75;
    }

    /* Êäò„Çä„Åü„Åü„ÅøÊôÇ */
    .sidebar.collapsed {
      max-height: 48px;
      padding-bottom: 6px;
    }
    .sidebar.collapsed #base-list,
    .sidebar.collapsed .sidebar-note {
      display: none;
    }

    #base-list li.base-item {
      display: flex;
      gap: 6px;
      padding: 5px 6px;
      border-radius: 10px;
      background: rgba(255,255,255,0.06);
      margin-bottom: 4px;
      border: 1px solid rgba(255,255,255,0.12);
      align-items: center;
    }
    #base-list li.base-item:hover {
      background: rgba(255,255,255,0.10);
    }

    .base-item-thumb {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      background-color: rgba(255,255,255,0.08);
      background-size: cover;
      background-position: center;
      flex-shrink: 0;
      border: 1px solid rgba(255,255,255,0.3);
    }

    .base-item-info {
      flex: 1;
      min-width: 0;
    }
    .base-item-name-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 4px;
    }
    .base-name {
      font-size: 12px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .base-level {
      font-size: 11px;
      opacity: 0.9;
    }
    .base-alliance-row {
      font-size: 10px;
      opacity: 0.9;
      margin-top: 1px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .base-item-meta-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 2px;
      gap: 4px;
    }
    .base-coord {
      font-size: 10px;
      opacity: 0.9;
    }
    .base-status {
      display: flex;
      gap: 2px;
    }
    .base-status button {
      border: none;
      border-radius: 999px;
      padding: 1px 5px;
      font-size: 10px;
      cursor: pointer;
      background: rgba(255,255,255,0.10);
      color: #f5f5f5;
      white-space: nowrap;
    }
    .base-status button.active[data-status="ÂèÇÂä†"] {
      background: rgba(80, 220, 140, 0.95);
      color: #021108;
    }
    .base-status button.active[data-status="‰∏çÂèÇÂä†"] {
      background: rgba(240, 90, 90, 0.95);
      color: #250202;
    }
    .base-status button.active[data-status="‰∏çÊòé"] {
      background: rgba(255, 210, 90, 0.95);
      color: #251a02;
    }

    @media (max-width: 768px) {
      .hint {
        font-size: 10px;
        max-width: 90%;
        bottom: 60px;        /* HUD „Å®„Åã„Å∂„Çâ„Å™„ÅÑ„Çà„ÅÜÂ∞ë„Åó‰∏ä„Å´ */
      }
      .hud {
        bottom: 10px;
        right: 10px;
      }
      .sidebar {
        width: calc(100% - 20px);
        left: 10px;
        right: 10px;
        top: 10px;
        max-height: 45%;
      }
      .sidebar-title {
        font-size: 10px;
      }
      .sidebar-actions button {
        font-size: 9px;
        padding: 2px 4px;
      }
    }
  </style>
</head>
<body>
  <canvas id="map-canvas"></canvas>

  <div class="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title">Âü∫Âú∞‰∏ÄË¶ßÔºàË°å„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„ÅßÁ∑®ÈõÜÔºâ</div>
      <div class="sidebar-actions">
        <button id="toggle-sidebar">Ôºç</button>
        <button id="export-btn">EX</button>
        <button id="import-btn">IM</button>
        <input type="file" id="import-file" accept="application/json" style="display:none" />
      </div>
    </div>
    <ul id="base-list"></ul>
    <div class="sidebar-note">
      „Éª„Éû„ÉÉ„ÉóÔºöÁ©∫„Åç„Éû„Çπ„Çí„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„ÅßÂü∫Âú∞ËøΩÂä† / Âü∫Âú∞„Éâ„É©„ÉÉ„Ç∞„ÅßÁßªÂãï / Âü∫Âú∞„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„ÅßÂêçÂâçÂ§âÊõ¥ or ÂâäÈô§<br>
      „ÉªÁä∂ÊÖã„Éª„É¨„Éô„É´„ÉªÊâÄÂ±ûÂêåÁõü„Éª„Ç¢„Ç§„Ç≥„É≥„ÅØ„Éñ„É©„Ç¶„Ç∂„Å´Ëá™Âãï‰øùÂ≠ò„Åï„Çå„Åæ„ÅôÔºàÁ´ØÊú´„Åî„Å®Ôºâ<br>
      „Éª„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åß JSON „Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÄÅ„Ç§„É≥„Éù„Éº„Éà„ÅßË™≠„ÅøËæº„ÅøÔºà‰ªñÁ´ØÊú´„Å∏ÊâãÂãïÂÖ±ÊúâÔºâ
    </div>
  </div>

  <div class="hud">
    <span class="label">Zoom</span>
    <span class="value" id="zoom-display">100%</span>
    <span class="label">Cell</span>
    <span class="value" id="cell-display">‚Äî</span>
  </div>

  <div class="hint" id="hint-text">
    ‚Ä¶
  </div>

  <script>
    // ===== DOM =====
    const canvas = document.getElementById("map-canvas");
    const ctx = canvas.getContext("2d");
    const zoomDisplay = document.getElementById("zoom-display");
    const cellDisplay = document.getElementById("cell-display");
    const baseListEl = document.getElementById("base-list");
    const exportBtn = document.getElementById("export-btn");
    const importBtn = document.getElementById("import-btn");
    const importFileInput = document.getElementById("import-file");
    const hintTextEl = document.getElementById("hint-text");
    const sidebarEl = document.querySelector(".sidebar");
    const toggleSidebarBtn = document.getElementById("toggle-sidebar");

    // ===== Âü∫Êú¨Ë®≠ÂÆö =====
    const HEX_SIZE = 20;
    const GRID_MAX_X = 999;
    const GRID_MAX_Y = 999;

    const HEX_HEIGHT = 2 * HEX_SIZE;
    const HEX_WIDTH  = Math.sqrt(3) * HEX_SIZE;
    const HEX_VERT_SPACING  = 1.5 * HEX_SIZE;
    const HEX_HORIZ_SPACING = HEX_WIDTH;

    const EDGE_THICKNESS_WORLD = HEX_SIZE * 0.8;

    const STORAGE_KEY = "hexmap_bases_local_v1"; // „É≠„Éº„Ç´„É´Â∞ÇÁî®

    let scale = 0.35;
    let offsetX = 0;
    let offsetY = 0;
    const MIN_SCALE = 0.08;
    const MAX_SCALE = 3.0;

    let isPanning = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let selectedCell = null;

    let draggingBaseId = null;
    let lastDragCell = null;

    // Âü∫Âú∞: {id, name, cells:[{x,y}], anchor:{x,y}, level, status, allianceName, allianceIcon}
    const bases = [];
    let baseCount = 0;

    // È¶ñÈÉΩ‰∏≠ÂøÉ¬±50
    const CAPITAL_CENTER_X = 500;
    const CAPITAL_CENTER_Y = 500;
    const VIEW_RADIUS = 50;

    const VIEW_MIN_X = Math.max(0, CAPITAL_CENTER_X - VIEW_RADIUS);
    const VIEW_MAX_X = Math.min(GRID_MAX_X, CAPITAL_CENTER_X + VIEW_RADIUS);
    const VIEW_MIN_Y = Math.max(0, CAPITAL_CENTER_Y - VIEW_RADIUS);
    const VIEW_MAX_Y = Math.min(GRID_MAX_Y, CAPITAL_CENTER_Y + VIEW_RADIUS);

    // Á†ÇÊº†„Ç®„É™„Ç¢Â§öËßíÂΩ¢
    const desertVerticesGrid = [
      { x: 482, y: 465 },
      { x: 465, y: 500 },
      { x: 482, y: 535 },
      { x: 517, y: 535 },
      { x: 535, y: 500 },
      { x: 517, y: 465 }
    ];

    // ÈÖçÁΩÆ‰∏çÂèØ„É°„Ç§„É≥ÂÖ≠Ëßí
    const blockedVerticesGrid = [
      { x: 483, y: 500 },
      { x: 491, y: 517 },
      { x: 508, y: 517 },
      { x: 517, y: 500 },
      { x: 508, y: 483 },
      { x: 491, y: 483 }
    ];

    const extraBlockedCells = [
      { x: 489, y: 515 }, { x: 490, y: 516 }, { x: 490, y: 517 },
      { x: 491, y: 518 }, { x: 491, y: 585 }, { x: 492, y: 518 },
      { x: 493, y: 518 }, { x: 494, y: 518 }, { x: 489, y: 516 },
      { x: 489, y: 517 }, { x: 490, y: 518 }, { x: 490, y: 519 },
      { x: 491, y: 519 }, { x: 492, y: 519 }, { x: 493, y: 519 },
      { x: 517, y: 502 }, { x: 517, y: 501 }, { x: 517, y: 502 },
      { x: 518, y: 500 }, { x: 518, y: 499 }, { x: 518, y: 498 },
      { x: 517, y: 497 }, { x: 517, y: 496 }, { x: 517, y: 499 },
      { x: 517, y: 498 }, { x: 516, y: 497 }, { x: 516, y: 496 },
      { x: 489, y: 485 }, { x: 489, y: 484 }, { x: 489, y: 483 },
      { x: 490, y: 482 }, { x: 490, y: 484 }, { x: 490, y: 483 },
      { x: 491, y: 482 }, { x: 491, y: 481 }, { x: 492, y: 482 },
      { x: 492, y: 481 }, { x: 493, y: 482 }, { x: 494, y: 482 },
      { x: 490, y: 481 }, { x: 493, y: 481 }, { x: 494, y: 482 }
    ];

    let desertPolygonWorld = [];
    let blockedPolygonWorld = [];

    // Âü∫Âú∞„ÇØ„É©„Çπ„Çø„ÉºÔºàaxial ÂçäÂæÑ1Ôºâ
    const basePatternAxial = [
      { dq: 0, dr: 0 },
      { dq: 1, dr: 0 },
      { dq: 0, dr: 1 },
      { dq: -1, dr: 1 },
      { dq: -1, dr: 0 },
      { dq: 0, dr: -1 },
      { dq: 1, dr: -1 }
    ];

    function oddrToAxial(col, row) {
      const q = col - (row - (row & 1)) / 2;
      const r = row;
      return { q, r };
    }
    function axialToOddr(q, r) {
      const row = r;
      const col = q + (r - (r & 1)) / 2;
      return { x: col, y: row };
    }

    // „Çπ„Éû„Éõ/PC „Éí„É≥„ÉàÂàá„ÇäÊõø„Åà
    function updateHintText() {
      const isMobile = window.innerWidth <= 768;
      if (isMobile) {
        hintTextEl.textContent =
          "üì± 1Êú¨Êåá„Éâ„É©„ÉÉ„Ç∞„ÅßÁßªÂãï / „Éî„É≥„ÉÅ„Åß„Ç∫„Éº„É† / „Çø„ÉÉ„Éó„Åß„Çª„É´ÈÅ∏Êäû / Á©∫„Åç„Éû„Çπ„Çí„ÉÄ„Éñ„É´„Çø„ÉÉ„ÉóÔºàÊ©üÁ®Æ„Å´„Çà„Å£„Å¶„ÅØÈï∑Êäº„ÅóÔºã„Çø„ÉÉ„ÉóÔºâ„ÅßÂü∫Âú∞ËøΩÂä† / Âü∫Âú∞„Éâ„É©„ÉÉ„Ç∞„ÅßÁßªÂãï / Â∑¶‰∏ä„Éú„Çø„É≥„ÅßÂü∫Âú∞‰∏ÄË¶ß„ÇíÈñãÈñâ";
      } else {
        hintTextEl.textContent =
          "üñ± „Éâ„É©„ÉÉ„Ç∞ÁßªÂãï / „Éõ„Ç§„Éº„É´„Ç∫„Éº„É† / „ÇØ„É™„ÉÉ„ÇØ„Åß X,Y ÈÅ∏Êäû / Á©∫„Åç„Éû„Çπ„Çí„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„ÅßÂü∫Âú∞ËøΩÂä† / Âü∫Âú∞„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„ÅßÂêçÂâçÂ§âÊõ¥ or ÂâäÈô§ / Âü∫Âú∞„Éâ„É©„ÉÉ„Ç∞„ÅßÁßªÂãï / Â∑¶‰∏ä„Éú„Çø„É≥„ÅßÂü∫Âú∞‰∏ÄË¶ß„ÇíÈñãÈñâ";
      }
    }
    window.addEventListener("resize", updateHintText);
    updateHintText();

    // È´òËß£ÂÉèÂ∫¶ÂØæÂøú‰ªò„Åç resize
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width  = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      if (!resizeCanvas.initialized) {
        resizeCanvas.initialized = true;
        const midWorld = gridToWorld(CAPITAL_CENTER_X, CAPITAL_CENTER_Y);
        offsetX = rect.width / 2 - midWorld.x * scale;
        offsetY = rect.height / 2 - midWorld.y * scale;
        desertPolygonWorld  = desertVerticesGrid.map(v => gridToWorld(v.x, v.y));
        blockedPolygonWorld = blockedVerticesGrid.map(v => gridToWorld(v.x, v.y));
        loadBases();
        updateBaseListUI();
      }
      draw();
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // Â∫ßÊ®ôÂ§âÊèõ
    function gridToWorld(gx, gy) {
      const wx = HEX_HORIZ_SPACING * (gx + (gy & 1) * 0.5);
      const wy = HEX_VERT_SPACING * gy;
      return { x: wx, y: wy };
    }
    function worldToScreen(wx, wy) {
      return { x: wx * scale + offsetX, y: wy * scale + offsetY };
    }
    function screenToWorld(sx, sy) {
      return { x: (sx - offsetX) / scale, y: (sy - offsetY) / scale };
    }
    function screenToGrid(sx, sy) {
      const w = screenToWorld(sx, sy);
      let gy = Math.round(w.y / HEX_VERT_SPACING);
      gy = Math.max(0, Math.min(GRID_MAX_Y, gy));
      const rowOffset = (gy & 1) ? HEX_HORIZ_SPACING * 0.5 : 0;
      let gx = Math.round((w.x - rowOffset) / HEX_HORIZ_SPACING);
      gx = Math.max(0, Math.min(GRID_MAX_X, gx));
      return { x: gx, y: gy };
    }

    // Âπæ‰Ωï
    function pointInPolygon(point, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect =
          ((yi > point.y) !== (yj > point.y)) &&
          (point.x < (xj - xi) * (point.y - yi) / (yj - yi + 1e-9) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    function pointToSegmentDistance(p, a, b) {
      const vx = b.x - a.x;
      const vy = b.y - a.y;
      const wx = p.x - a.x;
      const wy = p.y - a.y;
      const c1 = vx * wx + vy * wy;
      if (c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y);
      const c2 = vx * vx + vy * vy;
      if (c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y);
      const t = c1 / c2;
      const projx = a.x + t * vx;
      const projy = a.y + t * vy;
      return Math.hypot(p.x - projx, p.y - projy);
    }
    function distanceToPolygonEdges(p, polygon) {
      let minD = Infinity;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const a = polygon[j];
        const b = polygon[i];
        const d = pointToSegmentDistance(p, a, b);
        if (d < minD) minD = d;
      }
      return minD;
    }

    // ÈÖçÁΩÆ‰∏çÂèØ
    function isBlockedCell(gx, gy) {
      for (const c of extraBlockedCells) {
        if (c.x === gx && c.y === gy) return true;
      }
      const w = gridToWorld(gx, gy);
      const inside = pointInPolygon(w, blockedPolygonWorld);
      const dist = distanceToPolygonEdges(w, blockedPolygonWorld);
      return inside || dist <= EDGE_THICKNESS_WORLD;
    }

    // Âü∫Âú∞„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
    function findBaseAtCell(gx, gy) {
      return bases.find(b => b.cells.some(c => c.x === gx && c.y === gy)) || null;
    }
    function createBaseCellsForAnchor(gx, gy, ignoreBaseId = null) {
      const { q, r } = oddrToAxial(gx, gy);
      const cells = basePatternAxial.map(off => {
        const oq = q + off.dq;
        const or = r + off.dr;
        return axialToOddr(oq, or);
      });

      for (const c of cells) {
        if (c.x < 0 || c.x > GRID_MAX_X || c.y < 0 || c.y > GRID_MAX_Y) return null;
        if (isBlockedCell(c.x, c.y)) return null;
        for (const b of bases) {
          if (ignoreBaseId && b.id === ignoreBaseId) continue;
          if (b.cells.some(d => d.x === c.x && d.y === c.y)) return null;
        }
      }
      return cells;
    }
    function deleteBaseById(id) {
      const idx = bases.findIndex(b => b.id === id);
      if (idx !== -1) {
        bases.splice(idx, 1);
        saveBases();
        updateBaseListUI();
        draw();
      }
    }

    // ‰øùÂ≠ò„ÉªË™≠„ÅøËæº„ÅøÔºà„É≠„Éº„Ç´„É´„ÅÆ„ÅøÔºâ
    function makeSerializableData() {
      return {
        bases: bases.map(b => ({
          id: b.id,
          name: b.name,
          anchor: b.anchor,
          level: b.level ?? null,
          status: b.status || "‰∏çÊòé",
          allianceName: b.allianceName || "",
          allianceIcon: b.allianceIcon || ""
        }))
      };
    }
    function saveBases() {
      const data = makeSerializableData();
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      } catch (e) {
        console.warn("saveBases error:", e);
      }
    }
    function loadBases() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      try {
        const data = JSON.parse(raw);
        if (!data || !Array.isArray(data.bases)) return;
        bases.length = 0;
        data.bases.forEach(rec => {
          if (!rec.anchor) return;
          const cells = createBaseCellsForAnchor(rec.anchor.x, rec.anchor.y, null);
          if (!cells) return;
          bases.push({
            id: rec.id || (Date.now().toString(36) + Math.random().toString(36).slice(2,7)),
            name: rec.name || "Âü∫Âú∞",
            cells,
            anchor: rec.anchor,
            level: rec.level ?? null,
            status: rec.status || "‰∏çÊòé",
            allianceName: rec.allianceName || "",
            allianceIcon: rec.allianceIcon || ""
          });
        });
        baseCount = bases.length;
      } catch (e) {
        console.warn("loadBases error:", e);
      }
    }

    // „Ç§„É≥„Éù„Éº„ÉàÔºè„Ç®„ÇØ„Çπ„Éù„Éº„Éà
    function importBasesFromData(data) {
      if (!data || !Array.isArray(data.bases)) {
        alert("„Ç§„É≥„Éù„Éº„Éà„Åô„ÇãJSON„ÅÆÂΩ¢Âºè„Åå‰∏çÊ≠£„Åß„Åô„ÄÇ");
        return;
      }
      if (!confirm("ÁèæÂú®„ÅÆÂü∫Âú∞„Éá„Éº„Çø„ÇíÂÖ®„Å¶ÁΩÆ„ÅçÊèõ„Åà„Åæ„Åô„ÅãÔºü")) return;

      bases.length = 0;
      data.bases.forEach(rec => {
        if (!rec.anchor) return;
        const cells = createBaseCellsForAnchor(rec.anchor.x, rec.anchor.y, null);
        if (!cells) return;
        bases.push({
          id: rec.id || (Date.now().toString(36) + Math.random().toString(36).slice(2,7)),
          name: rec.name || "Âü∫Âú∞",
          cells,
          anchor: rec.anchor,
          level: rec.level ?? null,
          status: rec.status || "‰∏çÊòé",
          allianceName: rec.allianceName || "",
          allianceIcon: rec.allianceIcon || ""
        });
      });
      baseCount = bases.length;
      saveBases();
      updateBaseListUI();
      draw();
    }
    function exportBasesToFile() {
      const data = makeSerializableData();
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "bases.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    function handleImportFile(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        try {
          const data = JSON.parse(ev.target.result);
          importBasesFromData(data);
        } catch (err) {
          console.error(err);
          alert("JSON„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ");
        } finally {
          importFileInput.value = "";
        }
      };
      reader.readAsText(file, "utf-8");
    }

    exportBtn.addEventListener("click", exportBasesToFile);
    importBtn.addEventListener("click", () => importFileInput.click());
    importFileInput.addEventListener("change", handleImportFile);

    // „Çµ„Ç§„Éâ„Éê„ÉºÊäò„Çä„Åü„Åü„Åø
    toggleSidebarBtn.addEventListener("click", () => {
      const collapsed = sidebarEl.classList.toggle("collapsed");
      toggleSidebarBtn.textContent = collapsed ? "Ôºã" : "Ôºç";
    });

    // Âü∫Âú∞„É°„ÇøÁ∑®ÈõÜÔºà„É™„Çπ„Éà„Åã„ÇâÔºâ
    function editBaseMeta(base) {
      if (!base) return;

      let newName = prompt("Âü∫Âú∞ÂêçÔºàÁ©∫Ê¨Ñ„ÅßÂ§âÊõ¥„Å™„ÅóÔºâ", base.name);
      if (newName !== null && newName.trim() !== "") {
        base.name = newName.trim();
      }

      let newAllianceName = prompt(
        "ÊâÄÂ±ûÂêåÁõüÂêçÔºàÁ©∫Ê¨Ñ„Åß„É™„Çª„ÉÉ„Éà / „Ç≠„É£„É≥„Çª„É´„ÅßÂ§âÊõ¥„Å™„ÅóÔºâ",
        base.allianceName || ""
      );
      if (newAllianceName !== null) {
        newAllianceName = newAllianceName.trim();
        base.allianceName = newAllianceName;
      }

      let newLevel = prompt(
        "Âü∫Âú∞„É¨„Éô„É´ÔºàÊï∞Â≠ó / Á©∫Ê¨Ñ„ÅßÂ§âÊõ¥„Å™„ÅóÔºâ",
        base.level != null ? String(base.level) : ""
      );
      if (newLevel !== null && newLevel.trim() !== "") {
        const num = Number(newLevel.trim());
        if (!isNaN(num)) base.level = num;
      }

      let newIcon = prompt(
        "ÊâÄÂ±ûÂêåÁõü„Ç¢„Ç§„Ç≥„É≥„ÅÆÁîªÂÉèURLÔºàÁ©∫Ê¨Ñ„ÅßÂâäÈô§ / „Ç≠„É£„É≥„Çª„É´„ÅßÂ§âÊõ¥„Å™„ÅóÔºâ",
        base.allianceIcon || ""
      );
      if (newIcon !== null) {
        newIcon = newIcon.trim();
        base.allianceIcon = newIcon === "" ? "" : newIcon;
      }

      saveBases();
      updateBaseListUI();
      draw();
    }

    // „Éû„ÉÉ„Éó‰∏ä„Åß„ÅÆÂêçÂâçÂ§âÊõ¥ÔºèÂâäÈô§
    function renameOrDeleteBase(base) {
      if (!base) return;
      let newName = prompt(
        "Âü∫Âú∞Âêç„ÇíÂ§âÊõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºàÁ©∫Ê¨Ñ„ÅßÂâäÈô§„ÄÅ„Ç≠„É£„É≥„Çª„É´„Åß‰Ωï„ÇÇ„Åó„Å™„ÅÑÔºâ",
        base.name
      );
      if (newName === null) return;
      newName = newName.trim();
      if (newName === "") {
        if (confirm(`Âü∫Âú∞„Äå${base.name}„Äç„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`)) {
          deleteBaseById(base.id);
        }
        return;
      }
      base.name = newName;
      saveBases();
      updateBaseListUI();
      draw();
    }

    function addBaseAtGrid(gx, gy) {
      const cells = createBaseCellsForAnchor(gx, gy, null);
      if (!cells) return;

      const defaultName = "Âü∫Âú∞" + String(++baseCount).padStart(3, "0");
      let name = prompt(
        "Âü∫Âú∞Âêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºà„Ç≠„É£„É≥„Çª„É´„ÅßÈÖçÁΩÆ‰∏≠Ê≠¢Ôºâ",
        defaultName
      );
      if (name === null) {
        baseCount--;
        return;
      }
      if (name.trim() === "") name = defaultName;

      let allianceName = prompt(
        "ÊâÄÂ±ûÂêåÁõüÂêçÔºà„Å™„Åë„Çå„Å∞Á©∫Ê¨Ñ„ÅÆ„Åæ„ÅæÔºâ",
        ""
      );
      if (allianceName !== null) allianceName = allianceName.trim();
      else allianceName = "";

      const id = Date.now().toString(36) + Math.random().toString(36).slice(2, 7);
      bases.push({
        id,
        name,
        cells,
        anchor: { x: gx, y: gy },
        level: null,
        status: "‰∏çÊòé",
        allianceName,
        allianceIcon: ""   // „Ç¢„Ç§„Ç≥„É≥URL„ÅØ„É™„Çπ„Éà„Åã„ÇâÁ∑®ÈõÜ
      });
      saveBases();
      updateBaseListUI();
      draw();
    }

    function moveBaseToGrid(baseId, gx, gy) {
      const base = bases.find(b => b.id === baseId);
      if (!base) return;
      const cells = createBaseCellsForAnchor(gx, gy, baseId);
      if (!cells) return;
      base.cells = cells;
      base.anchor = { x: gx, y: gy };
      saveBases();
      updateBaseListUI();
      draw();
    }

    // Âü∫Âú∞„É™„Çπ„ÉàUI
    function updateBaseListUI() {
      baseListEl.innerHTML = "";
      bases.forEach((b) => {
        const li = document.createElement("li");
        li.className = "base-item";

        const thumbDiv = document.createElement("div");
        thumbDiv.className = "base-item-thumb";
        if (b.allianceIcon) {
          thumbDiv.style.backgroundImage = `url(${b.allianceIcon})`; // ÂêåÁõü„Ç¢„Ç§„Ç≥„É≥
        } else {
          thumbDiv.style.backgroundImage = "";
        }

        const infoDiv = document.createElement("div");
        infoDiv.className = "base-item-info";

        const nameRow = document.createElement("div");
        nameRow.className = "base-item-name-row";

        const nameSpan = document.createElement("span");
        nameSpan.className = "base-name";
        nameSpan.textContent = b.name;

        const levelSpan = document.createElement("span");
        levelSpan.className = "base-level";
        levelSpan.textContent = b.level != null ? `Lv.${b.level}` : "Lv.-";

        nameRow.appendChild(nameSpan);
        nameRow.appendChild(levelSpan);

        const allianceRow = document.createElement("div");
        allianceRow.className = "base-alliance-row";
        allianceRow.textContent = b.allianceName
          ? `ÊâÄÂ±ûÂêåÁõü: ${b.allianceName}`
          : "ÊâÄÂ±ûÂêåÁõü: „Å™„Åó";

        const metaRow = document.createElement("div");
        metaRow.className = "base-item-meta-row";

        const anchor = b.anchor || b.cells[0];
        const coordSpan = document.createElement("span");
        coordSpan.className = "base-coord";
        coordSpan.textContent = `X${anchor.x} Y${anchor.y}`;

        const statusDiv = document.createElement("div");
        statusDiv.className = "base-status";

        ["ÂèÇÂä†", "‰∏çÂèÇÂä†", "‰∏çÊòé"].forEach(st => {
          const btn = document.createElement("button");
          btn.dataset.status = st;
          btn.textContent = st;
          if (b.status === st) btn.classList.add("active");
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            b.status = st;
            saveBases();
            updateBaseListUI();
            draw();
          });
          statusDiv.appendChild(btn);
        });

        metaRow.appendChild(coordSpan);
        metaRow.appendChild(statusDiv);

        infoDiv.appendChild(nameRow);
        infoDiv.appendChild(allianceRow);
        infoDiv.appendChild(metaRow);

        li.appendChild(thumbDiv);
        li.appendChild(infoDiv);

        li.addEventListener("dblclick", (e) => {
          e.stopPropagation();
          editBaseMeta(b);
        });

        baseListEl.appendChild(li);
      });
    }

    // ÊèèÁîª„Éò„É´„Éë„Éº
    function drawRoundedRect(ctx, x, y, w, h, r) {
      const radius = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + w - radius, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
      ctx.lineTo(x + w, y + h - radius);
      ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
      ctx.lineTo(x + radius, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    function drawHexCenter(wx, wy, strokeStyle, fillStyle, lineWidth = 1) {
      const { x: sx, y: sy } = worldToScreen(wx, wy);
      const s = HEX_SIZE * scale;
      const w = Math.sqrt(3) * s;
      const h = s;

      const pts = [
        { x: sx,        y: sy - h },
        { x: sx + w/2,  y: sy - h/2 },
        { x: sx + w/2,  y: sy + h/2 },
        { x: sx,        y: sy + h },
        { x: sx - w/2,  y: sy + h/2 },
        { x: sx - w/2,  y: sy - h/2 }
      ];

      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.closePath();

      if (fillStyle) {
        ctx.fillStyle = fillStyle;
        ctx.fill();
      }
      if (strokeStyle) {
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = lineWidth;
        ctx.stroke();
      }
    }

    function drawGrid() {
      const rect = canvas.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;

      const margin = 80 / scale;
      const topLeftWorld = screenToWorld(-margin, -margin);
      const bottomRightWorld = screenToWorld(w + margin, h + margin);

      let gyMin = Math.floor(topLeftWorld.y / HEX_VERT_SPACING) - 2;
      let gyMax = Math.ceil(bottomRightWorld.y / HEX_VERT_SPACING) + 2;

      gyMin = Math.max(0, gyMin);
      gyMax = Math.min(GRID_MAX_Y, gyMax);
      gyMin = Math.max(gyMin, VIEW_MIN_Y);
      gyMax = Math.min(gyMax, VIEW_MAX_Y);

      for (let gy = gyMin; gy <= gyMax; gy++) {
        const rowOffset = (gy & 1) ? HEX_HORIZ_SPACING * 0.5 : 0;

        let gxMin = Math.floor((topLeftWorld.x - rowOffset) / HEX_HORIZ_SPACING) - 2;
        let gxMax = Math.ceil((bottomRightWorld.x - rowOffset) / HEX_HORIZ_SPACING) + 2;

        gxMin = Math.max(0, gxMin);
        gxMax = Math.min(GRID_MAX_X, gxMax);
        gxMin = Math.max(gxMin, VIEW_MIN_X);
        gxMax = Math.min(gxMax, VIEW_MAX_X);

        for (let gx = gxMin; gx <= gxMax; gx++) {
          const { x: wx, y: wy } = gridToWorld(gx, gy);
          const center = { x: wx, y: wy };

          const isSelectedCell =
            selectedCell && selectedCell.x === gx && selectedCell.y === gy;

          const desertIn = pointInPolygon(center, desertPolygonWorld);
          const desertDist = distanceToPolygonEdges(center, desertPolygonWorld);
          const inDesert = desertIn || desertDist <= EDGE_THICKNESS_WORLD;

          const blkIn = pointInPolygon(center, blockedPolygonWorld);
          const blkDist = distanceToPolygonEdges(center, blockedPolygonWorld);
          const inBlockedPolygon = blkIn || blkDist <= EDGE_THICKNESS_WORLD;

          let inExtraBlocked = false;
          for (const c of extraBlockedCells) {
            if (gx === c.x && gy === c.y) {
              inExtraBlocked = true;
              break;
            }
          }
          const inBlocked = inBlockedPolygon || inExtraBlocked;

          const baseAt = findBaseAtCell(gx, gy);

          let stroke, fill, lw;
          if (isSelectedCell) {
            stroke = "rgba(255,221,85,0.7)";
            fill   = "rgba(255,221,85,0.18)";
            lw = 1.5;
          } else if (inBlocked) {
            stroke = "rgba(255, 80, 80, 0.75)";
            fill   = "rgba(255, 80, 80, 0.25)";
            lw = 1.2;
          } else if (baseAt) {
            if (baseAt.status === "ÂèÇÂä†") {
              stroke = "rgba(120, 255, 160, 0.9)";
              fill   = "rgba(90, 230, 150, 0.30)";
            } else if (baseAt.status === "‰∏çÂèÇÂä†") {
              stroke = "rgba(255, 140, 140, 0.9)";
              fill   = "rgba(255, 110, 110, 0.30)";
            } else {
              stroke = "rgba(255, 230, 160, 0.9)";
              fill   = "rgba(255, 220, 140, 0.28)";
            }
            lw = 1.4;
          } else {
            stroke = inDesert
              ? "rgba(230,210,120,0.18)"
              : "rgba(210, 255, 210, 0.14)";
            fill   = null;
            lw = 0.8;
          }

          drawHexCenter(wx, wy, stroke, fill, lw);
        }
      }
    }

    function drawDesertOutline() {
      ctx.beginPath();
      desertPolygonWorld.forEach((p, i) => {
        const s = worldToScreen(p.x, p.y);
        if (i === 0) ctx.moveTo(s.x, s.y);
        else ctx.lineTo(s.x, s.y);
      });
      ctx.closePath();
      ctx.strokeStyle = "rgba(230,210,120,0.85)";
      ctx.lineWidth = 1.4;
      ctx.stroke();
    }

    function drawBlockedOutline() {
      ctx.beginPath();
      blockedPolygonWorld.forEach((p, i) => {
        const s = worldToScreen(p.x, p.y);
        if (i === 0) ctx.moveTo(s.x, s.y);
        else ctx.lineTo(s.x, s.y);
      });
      ctx.closePath();
      ctx.strokeStyle = "rgba(255, 80, 80, 0.85)";
      ctx.lineWidth = 1.2;
      ctx.stroke();
    }

    // ‚òÖ „Éû„ÉÉ„Éó‰∏ä„ÅÆÂü∫Âú∞„É©„Éô„É´Ôºö„Çµ„É†„Éç„Ç§„É´„Ç¢„Ç§„Ç≥„É≥ÔºãÂü∫Âú∞ÂêçÔºãÁä∂ÊÖãÔºãÂ∫ßÊ®ô
    function drawBaseLabels() {
      ctx.save();

      bases.forEach(b => {
        const anchor = b.anchor || b.cells[0];
        const world = gridToWorld(anchor.x, anchor.y);
        const screen = worldToScreen(world.x, world.y);

        const statusText = b.status || "‰∏çÊòé";
        const levelText  = b.level != null ? `Lv.${b.level}` : "Lv.-";
        const statusLine = `${statusText} ${levelText}`;
        const coordText  = `X${anchor.x} Y${anchor.y}`;
        const nameText   = b.name;

        const baseFontSize = Math.max(8, Math.min(16, 12 * scale * 2.5));
        const lineHeight   = baseFontSize * 1.1;

        ctx.font = `${baseFontSize}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;

        const nameWidth   = ctx.measureText(nameText).width;
        const statusWidth = ctx.measureText(statusLine).width;
        const coordWidth  = ctx.measureText(coordText).width;

        const thumbSize = lineHeight * 1.2; // ÂêåÁõü„Ç¢„Ç§„Ç≥„É≥Êû†
        const textWidth = Math.max(nameWidth, statusWidth, coordWidth, thumbSize * 1.8);

        const paddingX  = 6 * scale * 2;
        const paddingY  = 4 * scale * 2;

        const panelWidth  = textWidth + paddingX * 2;
        const panelHeight = paddingY * 2 + thumbSize + 4 + lineHeight * 3;

        const offsetAboveHex = HEX_SIZE * scale * 1.6;
        const panelX = screen.x - panelWidth / 2;
        const panelY = screen.y - offsetAboveHex - panelHeight;

        // „Éë„Éç„É´ËÉåÊôØ
        ctx.globalAlpha = 0.92;
        ctx.fillStyle = "rgba(5, 6, 8, 0.92)";
        drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 6);
        ctx.fill();

        ctx.globalAlpha = 1.0;
        ctx.strokeStyle = "rgba(255, 255, 255, 0.16)";
        ctx.lineWidth = 1;
        drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 6);
        ctx.stroke();

        // ‰∏≠Ë∫´
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.font = `${baseFontSize}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;

        let cursorY = panelY + paddingY;

        // 1Ë°åÁõÆ: Â∑¶„Å´„Çµ„É†„Éç„Ç§„É´„Ç¢„Ç§„Ç≥„É≥Êû†ÔºàÂêåÁõü„Ç¢„Ç§„Ç≥„É≥Áî®Ôºâ
        const iconX = panelX + paddingX;
        const iconY = cursorY;

        ctx.fillStyle = "rgba(255,255,255,0.10)";
        drawRoundedRect(ctx, iconX, iconY, thumbSize, thumbSize, 3);
        ctx.fill();

        // „Ç¢„Ç§„Ç≥„É≥Ëá™‰Ωì„ÅØ Canvas „Å´„ÅØÁîªÂÉèÊèèÁîª„Åõ„Åö„ÄÅÈ†≠ÊñáÂ≠ó„Åã„Äå-„Äç„Å†„ÅëÔºà„Éï„É™„Éº„Ç∫ÂØæÁ≠ñÔºâ
        const allianceInitial = b.allianceName
          ? b.allianceName.trim().charAt(0)
          : "-";
        ctx.fillStyle = "rgba(255,255,255,0.85)";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(
          allianceInitial,
          iconX + thumbSize / 2,
          iconY + thumbSize / 2
        );

        cursorY += thumbSize + 4;

        // 2Ë°åÁõÆ: Âü∫Âú∞Âêç
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.fillStyle = "rgba(255,255,255,0.96)";
        ctx.fillText(nameText, screen.x, cursorY);
        cursorY += lineHeight;

        // 3Ë°åÁõÆ: Áä∂ÊÖãÔºã„É¨„Éô„É´
        ctx.fillStyle =
          statusText === "ÂèÇÂä†"
            ? "rgba(150, 255, 190, 0.96)"
            : statusText === "‰∏çÂèÇÂä†"
            ? "rgba(255, 170, 170, 0.96)"
            : "rgba(255, 230, 170, 0.96)";
        ctx.fillText(statusLine, screen.x, cursorY);
        cursorY += lineHeight;

        // 4Ë°åÁõÆ: Â∫ßÊ®ô
        ctx.fillStyle = "rgba(210, 230, 255, 0.96)";
        ctx.fillText(coordText, screen.x, cursorY);
      });

      ctx.restore();
    }

    function drawRegionLabels() {
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.textAlign = "center";

      let cx = 0, cy = 0;
      desertVerticesGrid.forEach(v => { cx += v.x; cy += v.y; });
      cx /= desertVerticesGrid.length;
      cy /= desertVerticesGrid.length;
      const desertWorld = gridToWorld(cx, cy);
      const desertScreen = worldToScreen(desertWorld.x, desertWorld.y);

      let fontSize = Math.max(10, Math.min(22, 14 * scale * 2.5));
      ctx.font = `${fontSize}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
      ctx.textBaseline = "middle";
      ctx.fillText("Á†ÇÊº†„Ç®„É™„Ç¢", desertScreen.x, desertScreen.y);

      const grassGrid = { x: 500, y: 550 };
      const grassWorld = gridToWorld(grassGrid.x, grassGrid.y);
      const grassScreen = worldToScreen(grassWorld.x, grassWorld.y);
      ctx.fillStyle = "rgba(200,255,200,0.9)";
      ctx.fillText("ËäùÁîü„Ç®„É™„Ç¢", grassScreen.x, grassScreen.y);

      const fixedLabels = [
        { x: 500, y: 500, text: "ÈÖçÁΩÆ‰∏çÂèØ„Ç®„É™„Ç¢" },
        { x: 517, y: 500, text: "Á†≤Âè∞3Âè∑" },
        { x: 491, y: 483, text: "Á†≤Âè∞2Âè∑" },
        { x: 491, y: 517, text: "Á†≤Âè∞1Âè∑" }
      ];

      fontSize = Math.max(9, Math.min(18, 12 * scale * 2));
      ctx.font = `${fontSize}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.textBaseline = "top";

      fixedLabels.forEach(obj => {
        const w = gridToWorld(obj.x, obj.y);
        const s = worldToScreen(w.x, w.y);
        const offset = HEX_SIZE * scale * 1.3;
        ctx.fillText(obj.text, s.x, s.y + offset);
      });

      ctx.restore();
    }

    function draw() {
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0, 0, rect.width, rect.height);
      drawGrid();
      drawDesertOutline();
      drawBlockedOutline();
      drawRegionLabels();
      drawBaseLabels();

      zoomDisplay.textContent = Math.round(scale * 100) + "%";
      cellDisplay.textContent = selectedCell
        ? `X${selectedCell.x} Y${selectedCell.y}`
        : "‚Äî";
    }

    // ===== Êìç‰Ωú =====
    canvas.addEventListener("mousedown", (e) => {
      if (e.button !== 0) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;

      const base = findBaseAtCell(cell.x, cell.y);
      if (base) {
        draggingBaseId = base.id;
        lastDragCell = cell;
        canvas.classList.add("dragging");
      } else {
        isPanning = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        canvas.classList.add("dragging");
      }
      draw();
    });

    window.addEventListener("mousemove", (e) => {
      if (draggingBaseId) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const cell = screenToGrid(mx, my);
        if (!lastDragCell || cell.x !== lastDragCell.x || cell.y !== lastDragCell.y) {
          moveBaseToGrid(draggingBaseId, cell.x, cell.y);
          lastDragCell = cell;
        }
        return;
      }

      if (!isPanning) return;
      const dx = e.clientX - lastMouseX;
      const dy = e.clientY - lastMouseY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      offsetX += dx;
      offsetY += dy;
      draw();
    });

    window.addEventListener("mouseup", () => {
      isPanning = false;
      draggingBaseId = null;
      lastDragCell = null;
      canvas.classList.remove("dragging");
    });

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      const zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
      let newScale = scale + zoomDelta * scale;
      newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
      if (newScale === scale) return;

      const worldBefore = screenToWorld(mx, my);
      scale = newScale;
      const worldAfter = screenToWorld(mx, my);

      offsetX += (worldAfter.x - worldBefore.x) * scale;
      offsetY += (worldAfter.y - worldBefore.y) * scale;

      draw();
    }, { passive: false });

    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;
      draw();
    });

    canvas.addEventListener("dblclick", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;

      const base = findBaseAtCell(cell.x, cell.y);
      if (base) {
        renameOrDeleteBase(base);
      } else {
        addBaseAtGrid(cell.x, cell.y);
      }
    });

    canvas.addEventListener("touchstart", (e) => {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mx = t.clientX - rect.left;
      const my = t.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;

      const base = findBaseAtCell(cell.x, cell.y);
      if (base) {
        draggingBaseId = base.id;
        lastDragCell = cell;
      } else {
        isPanning = true;
        lastMouseX = t.clientX;
        lastMouseY = t.clientY;
      }
      canvas.classList.add("dragging");
      draw();
    }, { passive: true });

    canvas.addEventListener("touchmove", (e) => {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mx = t.clientX - rect.left;
      const my = t.clientY - rect.top;

      if (draggingBaseId) {
        const cell = screenToGrid(mx, my);
        if (!lastDragCell || cell.x !== lastDragCell.x || cell.y !== lastDragCell.y) {
          moveBaseToGrid(draggingBaseId, cell.x, cell.y);
          lastDragCell = cell;
        }
        return;
      }

      if (!isPanning) return;
      const dx = t.clientX - lastMouseX;
      const dy = t.clientY - lastMouseY;
      lastMouseX = t.clientX;
      lastMouseY = t.clientY;
      offsetX += dx;
      offsetY += dy;
      draw();
    }, { passive: true });

    window.addEventListener("touchend", () => {
      isPanning = false;
      draggingBaseId = null;
      lastDragCell = null;
      canvas.classList.remove("dragging");
    });
  </script>
</body>
</html>
