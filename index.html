<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>284 Capital</title>

  <!-- favicon / iPhone ホーム追加 -->
  <link rel="icon" type="image/png" href="favicon.png">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- スマホでちゃんとスマホレイアウト -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      height: 100%;
      overflow: hidden;
      background: #050608;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5f5;
      font-size: 15px;
    }
    #map-canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: radial-gradient(circle at top, #1d2838 0, #050608 50%);
      cursor: grab;
      touch-action: none; /* ダブルタップ拡大を止める */
    }
    #map-canvas.dragging { cursor: grabbing; }

    /* HUD（Zoom / Cell） */
    .hud {
      position: fixed;
      right: 10px;
      bottom: 10px;
      padding: 7px 11px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .65);
      backdrop-filter: blur(10px);
      font-size: 13px;
      display: flex;
      gap: 8px;
      align-items: center;
      pointer-events: none;
      z-index: 10;
    }
    .hud span.label { opacity: .6; }
    .hud span.value { font-variant-numeric: tabular-nums; }

    /* サイドバー（基地リスト＋説明） */
    .sidebar {
      position: fixed;
      left: 10px;
      top: 10px;
      width: 320px;
      padding: 12px;
      border-radius: 16px;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(14px);
      font-size: 14px;
      z-index: 20;
      pointer-events: auto;
      max-height: calc(100% - 20px);
      display: flex;
      flex-direction: column;
    }
    .sidebar.collapsed {
      height: auto;
      max-height: none;
      padding: 8px 12px;
    }

    .sidebar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      margin-bottom: 8px;
    }
    .sidebar-title {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      opacity: 0.85;
    }
    .sidebar-actions {
      display: flex;
      gap: 4px;
      flex-shrink: 0;
      align-items: center;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .sidebar-actions button {
      border: none;
      border-radius: 999px;
      padding: 3px 7px;
      font-size: 12px;
      cursor: pointer;
      background: rgba(255,255,255,0.1);
      color: #f5f5f5;
      white-space: nowrap;
      min-width: 30px;
    }
    .sidebar-actions button:hover {
      background: rgba(255,255,255,0.2);
    }
    #toggle-sidebar {
      font-size: 14px;
      padding: 3px 9px;
      min-width: 28px;
    }

    /* フィルタ・ソート行 */
    .sidebar-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 6px;
      font-size: 12px;
    }
    .sidebar-controls label {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .sidebar-controls select {
      font-size: 12px;
      padding: 2px 4px;
      background: #111;
      color: #f5f5f5;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.2);
    }

    #base-list-wrapper {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }

    #base-list {
      list-style: none;
      margin: 0;
      padding: 0;
      overflow-y: auto;
      flex: 1;
    }

    .sidebar-summary {
      margin-top: 4px;
      font-size: 11px;
      opacity: 0.8;
      border-top: 1px solid rgba(255,255,255,0.08);
      padding-top: 4px;
      white-space: pre-line;
    }

    .sidebar-note {
      margin-top: 4px;
      font-size: 11px;
      opacity: 0.7;
      border-top: 1px solid rgba(255,255,255,0.08);
      padding-top: 4px;
    }
    .note-pc { display: block; }
    .note-sp { display: none; margin-top: 2px; }

    #base-list li.base-item {
      display: flex;
      gap: 7px;
      padding: 7px 8px;
      border-radius: 10px;
      background: rgba(255,255,255,0.04);
      margin-bottom: 4px;
      border: 1px solid transparent;
      align-items: center;
      cursor: pointer;
    }
    #base-list li.base-item:hover {
      background: rgba(255,255,255,0.08);
    }

    .base-color-dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      flex-shrink: 0;
      border: 1px solid rgba(0,0,0,0.5);
    }

    .base-item-info {
      flex: 1;
      min-width: 0;
    }
    .base-item-name-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 4px;
    }
    .base-name {
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .base-alliance {
      font-size: 13px;
      opacity: 0.8;
      white-space: nowrap;
    }
    .base-item-meta-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 2px;
      gap: 4px;
      font-size: 13px;
    }
    .base-coord {
      opacity: 0.8;
      white-space: nowrap;
    }
    .base-tagline {
      opacity: 0.85;
      white-space: nowrap;
    }

    .sidebar.collapsed #base-list-wrapper,
    .sidebar.collapsed .sidebar-controls,
    .sidebar.collapsed .sidebar-summary,
    .sidebar.collapsed .sidebar-note {
      display: none;
    }

    /* ズームボタン */
    .zoom-buttons {
      position: fixed;
      right: 10px;
      bottom: 72px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 10;
    }
    .zoom-buttons button {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      border: none;
      background: rgba(0,0,0,0.75);
      color: #fff;
      font-size: 22px;
      cursor: pointer;
    }

    /* 基地ポップ / メモポップトグルボタンの状態 */
    .toggle-on {
      background: rgba(44, 123, 229, 0.9) !important;
    }
    .toggle-on:hover {
      background: rgba(80, 150, 240, 1) !important;
    }

    @media (max-width: 768px) {
      /* HUD は右上へ */
      .hud {
        top: 8px;
        right: 8px;
        bottom: auto;
        font-size: 12px;
      }
      /* ズームボタンは画面中央右あたりへ（リストと重ならない） */
      .zoom-buttons {
        top: 50%;
        bottom: auto;
        right: 8px;
        transform: translateY(-50%);
      }
      .zoom-buttons button {
        width: 44px;
        height: 44px;
        font-size: 24px;
      }
      .sidebar {
        width: 100%;
        left: 0;
        right: 0;
        top: auto;
        bottom: 0;
        border-radius: 16px 16px 0 0;
        max-height: 48%;
        font-size: 14px;
      }
      .sidebar-title {
        font-size: 13px;
      }
      .sidebar-actions button {
        font-size: 12px;
        padding: 4px 7px;
      }
      #base-list li.base-item {
        padding: 8px 9px;
      }
      .note-pc { display: none; }
      .note-sp { display: block; }
    }
  </style>
</head>
<body>
  <canvas id="map-canvas"></canvas>

  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title">284 Capital - 基地一覧</div>
      <div class="sidebar-actions">
        <button id="copy-btn">Copy</button>
        <button id="export-btn">Exp</button>
        <button id="import-btn">Imp</button>
        <button id="pop-btn">Pop</button>
        <button id="memo-pop-btn">Memo</button>
        <button id="clear-btn">AllDel</button>
        <button id="toggle-sidebar">－</button>
        <input type="file" id="import-file" accept="application/json" style="display:none" />
      </div>
    </div>

    <div class="sidebar-controls">
      <label>
        Filter:
        <select id="filter-kind">
          <option value="ALL">全て</option>
          <option value="ALLY">味方</option>
          <option value="ENEMY">敵</option>
          <option value="CAPITAL">首都</option>
          <option value="CANNON">大砲</option>
          <option value="SUPPORT">援護</option>
        </select>
      </label>
      <label>
        Sort:
        <select id="sort-key">
          <option value="ALLIANCE">同盟</option>
          <option value="NAME">基地名</option>
          <option value="LEVEL">Lv.</option>
          <option value="TIER">T</option>
          <option value="TEAM">チーム</option>
          <option value="STATUS">状態</option>
        </select>
      </label>
    </div>

    <div id="base-list-wrapper">
      <ul id="base-list"></ul>
    </div>

    <div class="sidebar-summary" id="summary-box"></div>

    <div class="sidebar-note">
      <div class="note-pc">
        【PC】空きマス：ダブルクリックで基地追加 / 基地マス：ダブルクリックで編集・削除 / 左ドラッグで移動 / ホイールや＋－ボタンでズーム<br>
        ・Copy: 同盟名・基地名・座標をクリップボードへ<br>
        ・Exp/Imp: JSONファイルでエクスポート／インポート<br>
        ・Pop: 基地ポップ表示 ON/OFF / Memo: メモだけポップ表示 ON/OFF
      </div>
      <div class="note-sp">
        【スマホ】空きマス：同じマスを素早く2回タップで基地追加 / 基地マス：2回タップで編集・削除 / 1本指ドラッグで移動 / ＋－ボタンでズーム<br>
        ・Copy: 同盟名・基地名・座標をコピー<br>
        ・Exp/Imp: JSONファイルで保存／読み込み<br>
        ・Pop: 基地ポップ表示 ON/OFF / Memo: メモだけポップ表示 ON/OFF
      </div>
    </div>
  </div>

  <div class="zoom-buttons">
    <button id="zoom-in">＋</button>
    <button id="zoom-out">－</button>
  </div>

  <div class="hud">
    <span class="label">Zoom</span>
    <span class="value" id="zoom-display">100%</span>
    <span class="label">Cell</span>
    <span class="value" id="cell-display">—</span>
  </div>

  <!-- 基地追加・編集ダイアログ -->
  <div id="base-dialog"
       style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:30; background:rgba(0,0,0,0.6);">
    <div style="background:#101317; padding:14px 16px; border-radius:12px; width:320px; max-width:90%; font-size:14px;">
      <div style="font-size:15px; font-weight:600; margin-bottom:8px;">基地の追加 / 編集</div>
      <div style="display:flex; flex-direction:column; gap:8px;">
        <label>
          <span>陣営</span><br/>
          <select id="dlg-side" style="width:100%; margin-top:2px; font-size:14px; background:#111; color:#f5f5f5;">
            <option value="ALLY">味方</option>
            <option value="ENEMY">敵</option>
          </select>
        </label>
        <label>
          <span>所属同盟</span><br/>
          <select id="dlg-alliance" style="width:100%; margin-top:2px; font-size:14px; background:#111; color:#f5f5f5;"></select>
        </label>
        <label>
          <span>基地名</span><br/>
          <select id="dlg-name" style="width:100%; margin-top:2px; font-size:14px; background:#111; color:#f5f5f5;"></select>
        </label>
        <label id="team-row">
          <span>チーム</span><br/>
          <select id="dlg-team" style="width:100%; margin-top:2px; font-size:14px; background:#111; color:#f5f5f5;">
            <option value="NONE">なし</option>
            <option value="CAPITAL">首都</option>
            <option value="CANNON">大砲</option>
            <option value="SUPPORT">援護</option>
          </select>
        </label>
        <label>
          <span>参加状態</span><br/>
          <select id="dlg-status" style="width:100%; margin-top:2px; font-size:14px; background:#111; color:#f5f5f5;">
            <option value="参加">参加</option>
            <option value="不参加">不参加</option>
            <option value="不明">不明</option>
          </select>
        </label>
        <label>
          <span>レベル</span><br/>
          <select id="dlg-level" style="width:100%; margin-top:2px; font-size:14px; background:#111; color:#f5f5f5;"></select>
        </label>
        <label>
          <span>Tランク</span><br/>
          <select id="dlg-tier" style="width:100%; margin-top:2px; font-size:14px; background:#111; color:#f5f5f5;"></select>
        </label>
        <label>
          <span>メモ</span><br/>
          <textarea id="dlg-memo" rows="2"
            style="width:100%; margin-top:2px; font-size:13px; background:#111; color:#f5f5f5; border-radius:6px; border:1px solid rgba(255,255,255,0.2);"></textarea>
        </label>
        <div style="font-size:12px; opacity:0.7;" id="dlg-coord-text"></div>
      </div>
      <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:12px;">
        <button id="dlg-cancel"
                style="border:none; border-radius:999px; padding:5px 12px; font-size:14px; background:#444; color:#f5f5f5;">
          キャンセル
        </button>
        <button id="dlg-delete"
                style="border:none; border-radius:999px; padding:5px 12px; font-size:14px; background:#aa3333; color:#fff; display:none;">
          削除
        </button>
        <button id="dlg-ok"
                style="border:none; border-radius:999px; padding:5px 12px; font-size:14px; background:#2c7be5; color:#fff;">
          決定
        </button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("map-canvas");
    const ctx = canvas.getContext("2d");
    const zoomDisplay = document.getElementById("zoom-display");
    const cellDisplay = document.getElementById("cell-display");
    const baseListEl = document.getElementById("base-list");
    const sidebarEl = document.getElementById("sidebar");

    const copyBtn = document.getElementById("copy-btn");
    const toggleSidebarBtn = document.getElementById("toggle-sidebar");
    const zoomInBtn = document.getElementById("zoom-in");
    const zoomOutBtn = document.getElementById("zoom-out");
    const exportBtn = document.getElementById("export-btn");
    const importBtn = document.getElementById("import-btn");
    const importFileInput = document.getElementById("import-file");
    const summaryBox = document.getElementById("summary-box");
    const filterKindSelect = document.getElementById("filter-kind");
    const sortKeySelect = document.getElementById("sort-key");
    const popBtn = document.getElementById("pop-btn");
    const memoPopBtn = document.getElementById("memo-pop-btn");
    const clearBtn = document.getElementById("clear-btn");

    const baseDialog = document.getElementById("base-dialog");
    const dlgSide = document.getElementById("dlg-side");
    const dlgAlliance = document.getElementById("dlg-alliance");
    const dlgName = document.getElementById("dlg-name");
    const dlgTeam = document.getElementById("dlg-team");
    const teamRow = document.getElementById("team-row");
    const dlgStatus = document.getElementById("dlg-status");
    const dlgLevel = document.getElementById("dlg-level");
    const dlgTier = document.getElementById("dlg-tier");
    const dlgMemo = document.getElementById("dlg-memo");
    const dlgCoordText = document.getElementById("dlg-coord-text");
    const dlgCancel = document.getElementById("dlg-cancel");
    const dlgOk = document.getElementById("dlg-ok");
    const dlgDelete = document.getElementById("dlg-delete");

    const HEX_SIZE = 20;
    const GRID_MAX_X = 999;
    const GRID_MAX_Y = 999;
    const HEX_HEIGHT = 2 * HEX_SIZE;
    const HEX_WIDTH  = Math.sqrt(3) * HEX_SIZE;
    const HEX_VERT_SPACING  = 1.5 * HEX_SIZE;
    const HEX_HORIZ_SPACING = HEX_WIDTH;
    const EDGE_THICKNESS_WORLD = HEX_SIZE * 0.8;
    const STORAGE_KEY = "hexmap_bases_v9";

    let scale = 0.35;
    let offsetX = 0;
    let offsetY = 0;
    const MIN_SCALE = 0.08;
    const MAX_SCALE = 3.0;

    let canvasCssWidth = 0;
    let canvasCssHeight = 0;

    let isPanning = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let selectedCell = null;

    let touchStartX = 0;
    let touchStartY = 0;
    let lastTapTime = 0;
    let lastTapCell = null;
    const TAP_MAX_DELAY = 320;
    const TAP_MAX_MOVE  = 12;

    let draggingBaseId = null;
    let lastDragCell = null;

    const bases = [];
    let baseCount = 0;

    const CAPITAL_CENTER_X = 500;
    const CAPITAL_CENTER_Y = 500;
    const VIEW_RADIUS = 50;
    const VIEW_MIN_X = Math.max(0, CAPITAL_CENTER_X - VIEW_RADIUS);
    const VIEW_MAX_X = Math.min(GRID_MAX_X, CAPITAL_CENTER_X + VIEW_RADIUS);
    const VIEW_MIN_Y = Math.max(0, CAPITAL_CENTER_Y - VIEW_RADIUS);
    const VIEW_MAX_Y = Math.min(GRID_MAX_Y, CAPITAL_CENTER_Y + VIEW_RADIUS);

    // ★ 敵/味方 1000人分の仮メンバー
    const ENEMY_MEMBERS = Array.from({ length: 1000 }, (_, i) =>
      `敵${String(i + 1).padStart(3, "0")}`
    );
    const ALLY_MEMBERS = Array.from({ length: 1000 }, (_, i) =>
      `味方${String(i + 1).padStart(3, "0")}`
    );

    const ALLIANCES = [
      {
        key: "B777",
        name: "B777",
        color: "#ffcc00",
        textColor: "#201500",
        members: [
          "SuperZeus","Ram","ponsu","すぎっしー","NEXUS21","neku-ra","Crazy楊Frog",
          "GENLuckyTrigger","マナ","Ramen-X","やちこ","ヨホホホホ","Lamawa","Carna the God","jun33",
          "オーシマン","るんず","WDギャン","Hans 23","アカサ","えび","ステカセ王","ケイー","Yanoyano",
          "赤ヘル","タカちゃん","RUKA0806","ポル","yanchaaan","zerozerozero","アルアル","M731","Vikara",
          "RUSK222","JoJo11","フランメ","Happyぼっち","keioka","みにこり","キャノン","靈魂拷問者","迷子",
          "simon-nu","まむし","OneTop","しまんちゅ","Vivihana","PIPECUT","ロッシー","Ra-Men-Man","yusukerion",
          "onaka","xJISOOx","れみす","ヴォーグ","mr344","浮亂苦","Nescop","irohoma","くまみーん","亞丘?斯",
          "岡ティー","アイアイ","サムエル","もえご","QQ27","elchaaaan","Coffee jelly","ぺけたん","SEELE",
          "mamimumemo","あこまき","ジャン","1m2","ユウディ","ウニいくら","いろはす","Tnation","バイソン",
          "たけむー","CraZyLiOn","アジング","lupiX","nyu-ha-to","＊MISERY＊","もーー","Sakura0207","ピザコーラ",
          "ronrico","余韻","GSX1300R"
        ]
      },
      {
        key: "EclA",
        name: "EclA",
        color: "#66ccff",
        textColor: "#002233",
        members: [
          "伏黒 恵","冨岡 義勇","RENOVATIO","reaper777","Lucien Dodsa","はるちゃん","D0NKI호테",
          "ダンテ　G","Jabol86","DV 디뷔","온새결","c-137","SimpleDude","まるる","以蔵 -IZO-",
          "はだて","岳仔","バトウアン","RaineForest","Nishi7","hajime77777","Nobodymeow",
          "CORONELNEMO","조다슬남편","v끝판대장v","めいちゃん","NAT-","현대제철","Squidward jr",
          "AINS","RAVI10","Kori77","SeoulGirl","User2abcd","makonosuke","Wolfdog Walker",
          "Kiki777","nelipot","StoyanS","VIadimir Fido","Suokki","Jesterko","t imo",
          "Machang Bubok","plwro","CーPON","RastaRob","CRAZY H","SoupySuperStar","Dentrival",
          "Z‌‌","KANASAl","godjji","cubelee","DoMToDd","Craigクレグ","Aiaaahhh","fun die ?",
          "PaladinFriend","omjmj","日出打金","duberman","アビー","White Paladin",
          "•BadKitty18","MegaDragonite","にぃ","R0KAN","香ばしい","Sky18","Tiara333",
          "Taro12","masa1121","simply red","Mirellle","Diegomv","・LUZ","SurvivorREM",
          "AlexNesty","Idealize","Decade 2","Mos M Zer Lor","Jeyci","DiegoX","anhcatim",
          "Emmanuel Wick","야찰퀸","poem0320","Crimson-Sky","Noval Yoko","Lariatte",
          "Maelle SZ","조다슬남편"
        ]
      },
      {
        key: "ALLY",
        name: "味方",
        color: "#66ff99",
        textColor: "#002011",
        members: ALLY_MEMBERS
      },
      {
        key: "ENEMY",
        name: "敵",
        color: "#ff6666",
        textColor: "#2a0000",
        members: ENEMY_MEMBERS
      }
    ];
    const allianceMap = {};
    ALLIANCES.forEach(a => { allianceMap[a.key] = a; });

    const desertVerticesGrid = [
      { x: 482, y: 465 },
      { x: 465, y: 500 },
      { x: 482, y: 535 },
      { x: 517, y: 535 },
      { x: 535, y: 500 },
      { x: 517, y: 465 }
    ];
    const blockedVerticesGrid = [
      { x: 483, y: 500 },
      { x: 491, y: 517 },
      { x: 508, y: 517 },
      { x: 517, y: 500 },
      { x: 508, y: 483 },
      { x: 491, y: 483 }
    ];
    const extraBlockedCells = [
      { x: 489, y: 515 },{ x: 490, y: 516 },{ x: 490, y: 517 },{ x: 491, y: 518 },
      { x: 491, y: 585 },{ x: 492, y: 518 },{ x: 493, y: 518 },{ x: 494, y: 518 },
      { x: 489, y: 516 },{ x: 489, y: 517 },{ x: 490, y: 518 },{ x: 490, y: 519 },
      { x: 491, y: 519 },{ x: 492, y: 519 },{ x: 493, y: 519 },
      { x: 517, y: 502 },{ x: 517, y: 501 },{ x: 517, y: 502 },{ x: 518, y: 500 },
      { x: 518, y: 499 },{ x: 518, y: 498 },{ x: 517, y: 497 },{ x: 517, y: 496 },
      { x: 517, y: 499 },{ x: 517, y: 498 },{ x: 516, y: 497 },{ x: 516, y: 496 },
      { x: 489, y: 485 },{ x: 489, y: 484 },{ x: 489, y: 483 },{ x: 490, y: 482 },
      { x: 490, y: 484 },{ x: 490, y: 483 },{ x: 491, y: 482 },{ x: 491, y: 481 },
      { x: 492, y: 482 },{ x: 492, y: 481 },{ x: 493, y: 482 },{ x: 494, y: 482 },
      { x: 490, y: 481 },{ x: 493, y: 481 },{ x: 494, y: 482 }
    ];
    let desertPolygonWorld = [];
    let blockedPolygonWorld = [];

    const basePatternAxial = [
      { dq: 0, dr: 0 },
      { dq: 1, dr: 0 },
      { dq: 0, dr: 1 },
      { dq: -1, dr: 1 },
      { dq: -1, dr: 0 },
      { dq: 0, dr: -1 },
      { dq: 1, dr: -1 }
    ];

    // フィルター・ソート・POP 状態
    let filterKind = "ALL";
    let sortKey = "ALLIANCE";
    let showBasePopups = true;
    let showMemoPopups = false;

    // ダイアログ状態
    let dialogMode = "create"; // "create" | "edit"
    let dialogCell = null;
    let dialogEditingBase = null;

    function oddrToAxial(col, row) {
      const q = col - (row - (row & 1)) / 2;
      const r = row;
      return { q, r };
    }
    function axialToOddr(q, r) {
      const row = r;
      const col = q + (r - (r & 1)) / 2;
      return { x: col, y: row };
    }

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvasCssWidth = rect.width;
      canvasCssHeight = rect.height;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // 高解像度描画

      if (!resizeCanvas.initialized) {
        resizeCanvas.initialized = true;
        const midWorld = gridToWorld(CAPITAL_CENTER_X, CAPITAL_CENTER_Y);
        offsetX = rect.width / 2 - midWorld.x * scale;
        offsetY = rect.height / 2 - midWorld.y * scale;

        desertPolygonWorld = desertVerticesGrid.map(v => gridToWorld(v.x, v.y));
        blockedPolygonWorld = blockedVerticesGrid.map(v => gridToWorld(v.x, v.y));

        initDialogSelectors();
        loadBases();
        updateBaseListUI();

        if (window.innerWidth <= 768) {
          sidebarEl.classList.add("collapsed");
          toggleSidebarBtn.textContent = "＋";
        }
      }
      draw();
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function gridToWorld(gx, gy) {
      const wx = HEX_HORIZ_SPACING * (gx + (gy & 1) * 0.5);
      const wy = HEX_VERT_SPACING * gy;
      return { x: wx, y: wy };
    }
    function worldToScreen(wx, wy) {
      return { x: wx * scale + offsetX, y: wy * scale + offsetY };
    }
    function screenToWorld(sx, sy) {
      return { x: (sx - offsetX) / scale, y: (sy - offsetY) / scale };
    }
    function screenToGrid(sx, sy) {
      const w = screenToWorld(sx, sy);
      let gy = Math.round(w.y / HEX_VERT_SPACING);
      gy = Math.max(0, Math.min(GRID_MAX_Y, gy));
      const rowOffset = (gy & 1) ? HEX_HORIZ_SPACING * 0.5 : 0;
      let gx = Math.round((w.x - rowOffset) / HEX_HORIZ_SPACING);
      gx = Math.max(0, Math.min(GRID_MAX_X, gx));
      return { x: gx, y: gy };
    }

    function pointInPolygon(point, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect =
          ((yi > point.y) !== (yj > point.y)) &&
          (point.x < (xj - xi) * (point.y - yi) / (yj - yi + 1e-9) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    function pointToSegmentDistance(p, a, b) {
      const vx = b.x - a.x;
      const vy = b.y - a.y;
      const wx = p.x - a.x;
      const wy = p.y - a.y;
      const c1 = vx * wx + vy * wy;
      if (c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y);
      const c2 = vx * vx + vy * vy;
      if (c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y);
      const t = c1 / c2;
      const projx = a.x + t * vx;
      const projy = a.y + t * vy;
      return Math.hypot(p.x - projx, p.y - projy);
    }
    function distanceToPolygonEdges(p, polygon) {
      let minD = Infinity;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const d = pointToSegmentDistance(p, polygon[j], polygon[i]);
        if (d < minD) minD = d;
      }
      return minD;
    }

    function isBlockedCell(gx, gy) {
      for (const c of extraBlockedCells) {
        if (c.x === gx && c.y === gy) return true;
      }
      const w = gridToWorld(gx, gy);
      const inside = pointInPolygon(w, blockedPolygonWorld);
      const dist = distanceToPolygonEdges(w, blockedPolygonWorld);
      return inside || dist <= EDGE_THICKNESS_WORLD;
    }

    function findBaseAtCell(gx, gy) {
      return bases.find(b => b.cells.some(c => c.x === gx && c.y === gy)) || null;
    }

    function createBaseCellsForAnchor(gx, gy, ignoreBaseId = null) {
      const { q, r } = oddrToAxial(gx, gy);
      const cells = basePatternAxial.map(off => {
        const oq = q + off.dq;
        const or = r + off.dr;
        return axialToOddr(oq, or);
      });
      for (const c of cells) {
        if (c.x < 0 || c.x > GRID_MAX_X || c.y < 0 || c.y > GRID_MAX_Y) return null;
        if (isBlockedCell(c.x, c.y)) return null;
        for (const b of bases) {
          if (ignoreBaseId && b.id === ignoreBaseId) continue;
          if (b.cells.some(d => d.x === c.x && d.y === c.y)) return null;
        }
      }
      return cells;
    }

    function deleteBaseById(id) {
      const idx = bases.findIndex(b => b.id === id);
      if (idx !== -1) {
        bases.splice(idx, 1);
        saveBases();
        updateBaseListUI();
        draw();
      }
    }

    function makeSerializableData() {
      return {
        bases: bases.map(b => ({
          id: b.id,
          side: b.side,
          allianceKey: b.allianceKey,
          name: b.name,
          team: b.team,
          status: b.status,
          level: b.level,
          tier: b.tier,
          memo: b.memo || "",
          anchor: b.anchor
        }))
      };
    }

    function saveBases() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(makeSerializableData()));
      } catch (e) {
        console.warn("saveBases error:", e);
      }
    }

    function loadBases() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      try {
        const data = JSON.parse(raw);
        if (!data || !Array.isArray(data.bases)) return;
        data.bases.forEach(rec => {
          if (!rec.anchor) return;
          const cells = createBaseCellsForAnchor(rec.anchor.x, rec.anchor.y, null);
          if (!cells) return;
          bases.push({
            id: rec.id || (Date.now().toString(36) + Math.random().toString(36).slice(2,7)),
            side: rec.side || "ALLY",
            allianceKey: rec.allianceKey || "B777",
            name: rec.name || "基地",
            team: rec.team || "NONE",
            status: rec.status || "不明",
            level: rec.level ?? null,
            tier: rec.tier || "T1",
            memo: rec.memo || "",
            cells,
            anchor: rec.anchor
          });
        });
        baseCount = bases.length;
      } catch (e) {
        console.warn("loadBases error:", e);
      }
    }

    function importBasesFromData(data) {
      if (!data || !Array.isArray(data.bases)) {
        alert("インポートするJSONの形式が不正です。");
        return;
      }
      if (!confirm("現在の基地データを全て置き換えますか？")) return;

      bases.length = 0;
      data.bases.forEach(rec => {
        if (!rec.anchor) return;
        const cells = createBaseCellsForAnchor(rec.anchor.x, rec.anchor.y, null);
        if (!cells) return;
        bases.push({
          id: rec.id || (Date.now().toString(36) + Math.random().toString(36).slice(2,7)),
          side: rec.side || "ALLY",
          allianceKey: rec.allianceKey || "B777",
          name: rec.name || "基地",
          team: rec.team || "NONE",
          status: rec.status || "不明",
          level: rec.level ?? null,
          tier: rec.tier || "T1",
          memo: rec.memo || "",
          cells,
          anchor: rec.anchor
        });
      });
      baseCount = bases.length;
      saveBases();
      updateBaseListUI();
      draw();
    }

    function exportBasesToFile() {
      const data = makeSerializableData();
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "bases.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function handleImportFile(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        try {
          const data = JSON.parse(ev.target.result);
          importBasesFromData(data);
        } catch (err) {
          console.error(err);
          alert("JSONの読み込みに失敗しました。");
        } finally {
          importFileInput.value = "";
        }
      };
      reader.readAsText(file, "utf-8");
    }

    // ===== ダイアログ関連 =====
    function initDialogSelectors() {
      // Lv: 30 -> 1
      dlgLevel.innerHTML = "";
      for (let lv = 30; lv >= 1; lv--) {
        const opt = document.createElement("option");
        opt.value = String(lv);
        opt.textContent = `Lv.${lv}`;
        dlgLevel.appendChild(opt);
      }
      // T: 10 -> 1
      dlgTier.innerHTML = "";
      for (let t = 10; t >= 1; t--) {
        const opt = document.createElement("option");
        opt.value = `T${t}`;
        opt.textContent = `T${t}`;
        dlgTier.appendChild(opt);
      }
      // Side 初期値は味方
      dlgSide.value = "ALLY";
      updateAllianceSelectorForSide("ALLY");
    }

    function updateAllianceSelectorForSide(side) {
      dlgAlliance.innerHTML = "";
      let keys;
      if (side === "ALLY") {
        keys = ["ALLY", "B777", "EclA"];
        teamRow.style.display = "";
      } else {
        keys = ["ENEMY"];
        teamRow.style.display = "none";
      }
      keys.forEach(k => {
        const a = allianceMap[k];
        if (!a) return;
        const opt = document.createElement("option");
        opt.value = a.key;
        opt.textContent = a.name;
        dlgAlliance.appendChild(opt);
      });
      const key = dlgAlliance.value;
      const currentName = dialogEditingBase ? dialogEditingBase.name : null;
      updateNameOptionsForAlliance(key, currentName);
    }

    function updateNameOptionsForAlliance(allianceKey, currentName = null) {
      const alliance = allianceMap[allianceKey];
      dlgName.innerHTML = "";
      if (!alliance) return;
      const usedNames = new Set(bases.map(b => b.name));
      alliance.members.forEach(name => {
        if (dialogMode === "edit" && name === currentName) {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          dlgName.appendChild(opt);
        } else if (!usedNames.has(name)) {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          dlgName.appendChild(opt);
        }
      });
      if (dlgName.options.length === 0) {
        const opt = document.createElement("option");
        opt.value = currentName || "";
        opt.textContent = currentName || "(空き基地名なし)";
        dlgName.appendChild(opt);
      }
    }

    function openBaseDialogForCreate(cell) {
      dialogMode = "create";
      dialogCell = cell;
      dialogEditingBase = null;
      dlgDelete.style.display = "none";

      // デフォルト：味方・参加・Lv27・T9・チームなし
      dlgSide.value = "ALLY";
      updateAllianceSelectorForSide("ALLY");
      dlgStatus.value = "参加";
      dlgLevel.value = "27";
      dlgTier.value = "T9";
      dlgTeam.value = "NONE";
      dlgMemo.value = "";

      dlgCoordText.textContent = `配置セル: X${cell.x} Y${cell.y}`;
      baseDialog.style.display = "flex";
    }

    function openBaseDialogForEdit(base) {
      dialogMode = "edit";
      dialogEditingBase = base;
      dialogCell = base.anchor;
      dlgDelete.style.display = "inline-block";

      dlgSide.value = base.side || "ALLY";
      updateAllianceSelectorForSide(dlgSide.value);
      dlgAlliance.value = base.allianceKey || "B777";
      updateNameOptionsForAlliance(dlgAlliance.value, base.name);
      dlgName.value = base.name;
      dlgStatus.value = base.status || "不明";
      if (base.level != null) dlgLevel.value = String(base.level);
      dlgTier.value = base.tier || "T1";
      dlgTeam.value = base.team || "NONE";
      dlgMemo.value = base.memo || "";

      dlgCoordText.textContent = `配置セル: X${base.anchor.x} Y${base.anchor.y}`;
      baseDialog.style.display = "flex";
    }

    function closeBaseDialog() {
      baseDialog.style.display = "none";
      dialogCell = null;
      dialogEditingBase = null;
    }

    dlgSide.addEventListener("change", () => {
      updateAllianceSelectorForSide(dlgSide.value);
    });

    dlgAlliance.addEventListener("change", () => {
      const key = dlgAlliance.value;
      const currentName = dialogEditingBase ? dialogEditingBase.name : null;
      updateNameOptionsForAlliance(key, currentName);
    });

    dlgCancel.addEventListener("click", closeBaseDialog);

    dlgDelete.addEventListener("click", () => {
      if (!dialogEditingBase) return;
      if (confirm(`基地「${dialogEditingBase.name}」を削除しますか？`)) {
        deleteBaseById(dialogEditingBase.id);
        closeBaseDialog();
      }
    });

    dlgOk.addEventListener("click", () => {
      const side = dlgSide.value;
      const allianceKey = dlgAlliance.value;
      const alliance = allianceMap[allianceKey] || ALLIANCES[0];
      const name = dlgName.value || "基地";
      const status = dlgStatus.value || "不明";
      const level = Number(dlgLevel.value || "0");
      const tier = dlgTier.value || "T1";
      const team = side === "ALLY" ? dlgTeam.value : "NONE";
      const memo = dlgMemo.value || "";

      if (!dialogCell) { closeBaseDialog(); return; }
      const gx = dialogCell.x;
      const gy = dialogCell.y;

      if (dialogMode === "create") {
        const cells = createBaseCellsForAnchor(gx, gy, null);
        if (!cells) {
          alert("この位置には基地を配置できません。");
          return;
        }
        const id = Date.now().toString(36) + Math.random().toString(36).slice(2, 7);
        bases.push({
          id,
          side,
          allianceKey: alliance.key,
          name,
          status,
          level: isNaN(level) ? null : level,
          tier,
          team,
          memo,
          cells,
          anchor: { x: gx, y: gy }
        });
        baseCount++;
      } else if (dialogMode === "edit" && dialogEditingBase) {
        const cells = createBaseCellsForAnchor(gx, gy, dialogEditingBase.id);
        if (!cells) {
          alert("この位置には基地を配置できません。");
          return;
        }
        dialogEditingBase.side = side;
        dialogEditingBase.allianceKey = alliance.key;
        dialogEditingBase.name = name;
        dialogEditingBase.status = status;
        dialogEditingBase.level = isNaN(level) ? null : level;
        dialogEditingBase.tier = tier;
        dialogEditingBase.team = team;
        dialogEditingBase.memo = memo;
        dialogEditingBase.cells = cells;
        dialogEditingBase.anchor = { x: gx, y: gy };
      }

      saveBases();
      updateBaseListUI();
      draw();
      closeBaseDialog();
    });

    // ===== リスト UI + ソート・集計 =====
    function passesFilter(b) {
      switch (filterKind) {
        case "ALLY": return b.side === "ALLY";
        case "ENEMY": return b.side === "ENEMY";
        case "CAPITAL": return b.team === "CAPITAL";
        case "CANNON": return b.team === "CANNON";
        case "SUPPORT": return b.team === "SUPPORT";
        default: return true;
      }
    }

    function compareBase(a, b) {
      const allianceA = allianceMap[a.allianceKey] || ALLIANCES[0];
      const allianceB = allianceMap[b.allianceKey] || ALLIANCES[0];
      const nameA = a.name || "";
      const nameB = b.name || "";
      const lvA = a.level || 0;
      const lvB = b.level || 0;
      const tierNumA = parseInt((a.tier || "T1").substring(1), 10) || 1;
      const tierNumB = parseInt((b.tier || "T1").substring(1), 10) || 1;

      switch (sortKey) {
        case "NAME":
          return nameA.localeCompare(nameB);
        case "LEVEL":
          if (lvA !== lvB) return lvB - lvA;
          return nameA.localeCompare(nameB);
        case "TIER":
          if (tierNumA !== tierNumB) return tierNumB - tierNumA;
          return nameA.localeCompare(nameB);
        case "TEAM":
          const orderTeam = { "CAPITAL": 0, "CANNON": 1, "SUPPORT": 2, "NONE": 3 };
          const ta = orderTeam[a.team || "NONE"];
          const tb = orderTeam[b.team || "NONE"];
          if (ta !== tb) return ta - tb;
          return nameA.localeCompare(nameB);
        case "STATUS":
          const orderSt = { "参加": 0, "不明": 1, "不参加": 2 };
          const sa = orderSt[a.status] ?? 99;
          const sb = orderSt[b.status] ?? 99;
          if (sa !== sb) return sa - sb;
          return nameA.localeCompare(nameB);
        case "ALLIANCE":
        default:
          if (allianceA.name !== allianceB.name) {
            return allianceA.name.localeCompare(allianceB.name);
          }
          return nameA.localeCompare(nameB);
      }
    }

    function updateBaseListUI() {
      baseListEl.innerHTML = "";
      const filtered = bases.filter(passesFilter);
      const sorted = [...filtered].sort(compareBase);

      // 集計
      const teamCount = { CAPITAL:0, CANNON:0, SUPPORT:0, NONE:0 };
      const statusCount = { "参加":0, "不参加":0, "不明":0 };
      const lvCount = Array(31).fill(0); // 0〜30
      const tCount = Array(11).fill(0);  // 0〜10 (T1〜T10)

      sorted.forEach(b => {
        const t = b.team || "NONE";
        if (teamCount[t] != null) teamCount[t]++;
        if (statusCount[b.status] != null) statusCount[b.status]++;
        if (b.level != null && b.level >= 1 && b.level <= 30) lvCount[b.level]++;
        const tn = parseInt((b.tier || "T1").substring(1), 10);
        if (!isNaN(tn) && tn >= 1 && tn <= 10) tCount[tn]++;
      });

      // リスト要素
      sorted.forEach(b => {
        const li = document.createElement("li");
        li.className = "base-item";

        const alliance = allianceMap[b.allianceKey] || ALLIANCES[0];
        const dot = document.createElement("div");
        dot.className = "base-color-dot";

        // チーム別で少し色調整（合成）
        let baseColor = alliance.color;
        if (b.team === "CAPITAL") {
          baseColor = "#ffdd55";
        } else if (b.team === "CANNON") {
          baseColor = "#ff8888";
        } else if (b.team === "SUPPORT") {
          baseColor = "#88ffdd";
        }
        dot.style.background = baseColor;

        const info = document.createElement("div");
        info.className = "base-item-info";

        const nameRow = document.createElement("div");
        nameRow.className = "base-item-name-row";

        const nameSpan = document.createElement("span");
        nameSpan.className = "base-name";
        nameSpan.textContent = b.name;

        const allianceSpan = document.createElement("span");
        allianceSpan.className = "base-alliance";
        allianceSpan.textContent = alliance.name;

        nameRow.appendChild(nameSpan);
        nameRow.appendChild(allianceSpan);

        const metaRow = document.createElement("div");
        metaRow.className = "base-item-meta-row";

        const coordSpan = document.createElement("span");
        coordSpan.className = "base-coord";
        coordSpan.textContent = `X${b.anchor.x} Y${b.anchor.y}`;

        const tagSpan = document.createElement("span");
        tagSpan.className = "base-tagline";
        const lv = b.level != null ? `Lv.${b.level}` : "Lv.-";
        let teamLabel = "";
        if (b.team === "CAPITAL") teamLabel = "首都";
        else if (b.team === "CANNON") teamLabel = "大砲";
        else if (b.team === "SUPPORT") teamLabel = "援護";
        else teamLabel = "";
        tagSpan.textContent = `${b.status} ${b.tier} ${lv}${teamLabel ? " / " + teamLabel : ""}`;

        metaRow.appendChild(coordSpan);
        metaRow.appendChild(tagSpan);

        info.appendChild(nameRow);
        info.appendChild(metaRow);

        li.appendChild(dot);
        li.appendChild(info);

        // ダブルクリック / ダブルタップで編集
        let lastClickTime = 0;
        li.addEventListener("click", (e) => {
          const now = Date.now();
          // シングルクリック → フォーカス移動
          focusOnBase(b);
          // 250ms 以内にもう一度来たらダブルクリック扱い
          if (now - lastClickTime < 250) {
            openBaseDialogForEdit(b);
          }
          lastClickTime = now;
        });

        baseListEl.appendChild(li);
      });

      // 集計表示
      const lines = [];

      lines.push(`基地数: ${filtered.length}`);
      lines.push(
        `チーム: 首都 ${teamCount.CAPITAL} / 大砲 ${teamCount.CANNON} / 援護 ${teamCount.SUPPORT} / なし ${teamCount.NONE}`
      );
      lines.push(
        `状態: 参加 ${statusCount["参加"]} / 不参加 ${statusCount["不参加"]} / 不明 ${statusCount["不明"]}`
      );

      // Lv 合計（あるものだけ）
      const lvParts = [];
      for (let lv = 30; lv >= 1; lv--) {
        if (lvCount[lv] > 0) lvParts.push(`Lv.${lv}:${lvCount[lv]}`);
      }
      if (lvParts.length > 0) {
        lines.push("Lv内訳: " + lvParts.join(" / "));
      }

      const tParts = [];
      for (let t = 10; t >= 1; t--) {
        if (tCount[t] > 0) tParts.push(`T${t}:${tCount[t]}`);
      }
      if (tParts.length > 0) {
        lines.push("T内訳: " + tParts.join(" / "));
      }

      summaryBox.textContent = lines.join("\n");
    }

    // ===== 描画系 =====
    function drawHexCenter(wx, wy, strokeStyle, fillStyle, lineWidth = 1) {
      const { x: sx, y: sy } = worldToScreen(wx, wy);
      const s = HEX_SIZE * scale;
      const w = Math.sqrt(3) * s;
      const h = s;

      const pts = [
        { x: sx,        y: sy - h },
        { x: sx + w/2,  y: sy - h/2 },
        { x: sx + w/2,  y: sy + h/2 },
        { x: sx,        y: sy + h },
        { x: sx - w/2,  y: sy + h/2 },
        { x: sx - w/2,  y: sy - h/2 }
      ];

      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.closePath();

      if (fillStyle) {
        ctx.fillStyle = fillStyle;
        ctx.fill();
      }
      if (strokeStyle) {
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = lineWidth;
        ctx.stroke();
      }
    }

    function drawGrid() {
      const w = canvasCssWidth;
      const h = canvasCssHeight;
      const margin = 80 / scale;
      const topLeftWorld = screenToWorld(-margin, -margin);
      const bottomRightWorld = screenToWorld(w + margin, h + margin);

      let gyMin = Math.floor(topLeftWorld.y / HEX_VERT_SPACING) - 2;
      let gyMax = Math.ceil(bottomRightWorld.y / HEX_VERT_SPACING) + 2;
      gyMin = Math.max(0, gyMin);
      gyMax = Math.min(GRID_MAX_Y, gyMax);
      gyMin = Math.max(gyMin, VIEW_MIN_Y);
      gyMax = Math.min(gyMax, VIEW_MAX_Y);

      for (let gy = gyMin; gy <= gyMax; gy++) {
        const rowOffset = (gy & 1) ? HEX_HORIZ_SPACING * 0.5 : 0;

        let gxMin = Math.floor((topLeftWorld.x - rowOffset) / HEX_HORIZ_SPACING) - 2;
        let gxMax = Math.ceil((bottomRightWorld.x - rowOffset) / HEX_HORIZ_SPACING) + 2;
        gxMin = Math.max(0, gxMin);
        gxMax = Math.min(GRID_MAX_X, gxMax);
        gxMin = Math.max(gxMin, VIEW_MIN_X);
        gxMax = Math.min(gxMax, VIEW_MAX_X);

        for (let gx = gxMin; gx <= gxMax; gx++) {
          const { x: wx, y: wy } = gridToWorld(gx, gy);
          const center = { x: wx, y: wy };

          const isSelectedCell =
            selectedCell && selectedCell.x === gx && selectedCell.y === gy;

          const desertIn = pointInPolygon(center, desertPolygonWorld);
          const desertDist = distanceToPolygonEdges(center, desertPolygonWorld);
          const inDesert = desertIn || desertDist <= EDGE_THICKNESS_WORLD;

          const blkIn = pointInPolygon(center, blockedPolygonWorld);
          const blkDist = distanceToPolygonEdges(center, blockedPolygonWorld);
          const inBlockedPolygon = blkIn || blkDist <= EDGE_THICKNESS_WORLD;

          let inExtraBlocked = false;
          for (const c of extraBlockedCells) {
            if (gx === c.x && gy === c.y) { inExtraBlocked = true; break; }
          }
          const inBlocked = inBlockedPolygon || inExtraBlocked;

          const baseAt = bases.find(b =>
            b.cells.some(c => c.x === gx && c.y === gy) && passesFilter(b)
          );

          let stroke, fill, lw;
          if (isSelectedCell) {
            stroke = "rgba(255,221,85,0.7)";
            fill   = "rgba(255,221,85,0.15)";
            lw = 1.6;
          } else if (inBlocked) {
            stroke = "rgba(255,80,80,0.7)";
            fill   = "rgba(255,80,80,0.22)";
            lw = 1.2;
          } else if (baseAt) {
            const alliance = allianceMap[baseAt.allianceKey] || ALLIANCES[0];
            let baseColor = alliance.color;
            if (baseAt.team === "CAPITAL") baseColor = "#ffdd55";
            else if (baseAt.team === "CANNON") baseColor = "#ff8888";
            else if (baseAt.team === "SUPPORT") baseColor = "#88ffdd";
            let alphaFill = 0.25;
            if (baseAt.status === "参加") alphaFill = 0.34;
            else if (baseAt.status === "不参加") alphaFill = 0.22;
            stroke = hexToRgba(baseColor, 0.95);
            fill   = hexToRgba(baseColor, alphaFill);
            lw = 1.5;
          } else {
            stroke = inDesert
              ? "rgba(235,220,150,0.12)"
              : "rgba(210,255,210,0.10)";
            fill = null;
            lw = 0.7;
          }

          drawHexCenter(wx, wy, stroke, fill, lw);
        }
      }
    }

    function drawDesertOutline() {
      ctx.beginPath();
      desertPolygonWorld.forEach((p, i) => {
        const s = worldToScreen(p.x, p.y);
        if (i === 0) ctx.moveTo(s.x, s.y);
        else ctx.lineTo(s.x, s.y);
      });
      ctx.closePath();
      ctx.strokeStyle = "rgba(230,210,120,0.8)";
      ctx.lineWidth = 1.2;
      ctx.stroke();
    }

    function drawBlockedOutline() {
      ctx.beginPath();
      blockedPolygonWorld.forEach((p, i) => {
        const s = worldToScreen(p.x, p.y);
        if (i === 0) ctx.moveTo(s.x, s.y);
        else ctx.lineTo(s.x, s.y);
      });
      ctx.closePath();
      ctx.strokeStyle = "rgba(255,80,80,0.75)";
      ctx.lineWidth = 1.2;
      ctx.stroke();
    }

    function drawRegionLabels() {
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.textAlign = "center";

      let cx = 0, cy = 0;
      desertVerticesGrid.forEach(v => { cx += v.x; cy += v.y; });
      cx /= desertVerticesGrid.length;
      cy /= desertVerticesGrid.length;
      const desertWorld = gridToWorld(cx, cy);
      const desertScreen = worldToScreen(desertWorld.x, desertWorld.y);

      let fontSize = Math.max(12, Math.min(24, 15 * scale * 2.5));
      ctx.font = `${fontSize}px system-ui,"-apple-system","BlinkMacSystemFont","Segoe UI",sans-serif`;
      ctx.textBaseline = "middle";
      ctx.fillText("砂漠エリア", desertScreen.x, desertScreen.y);

      const grassWorld = gridToWorld(500, 550);
      const grassScreen = worldToScreen(grassWorld.x, grassWorld.y);
      ctx.fillStyle = "rgba(200,255,200,0.85)";
      ctx.fillText("芝生エリア", grassScreen.x, grassScreen.y);

      const fixedLabels = [
        { x: 500, y: 500, text: "配置不可エリア" },
        { x: 517, y: 500, text: "砲台3号" },
        { x: 491, y: 483, text: "砲台2号" },
        { x: 491, y: 517, text: "砲台1号" }
      ];

      fontSize = Math.max(10, Math.min(20, 13 * scale * 2));
      ctx.font = `${fontSize}px system-ui,"-apple-system","BlinkMacSystemFont","Segoe UI",sans-serif`;
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.textBaseline = "top";

      fixedLabels.forEach(obj => {
        const w = gridToWorld(obj.x, obj.y);
        const s = worldToScreen(w.x, w.y);
        const offset = HEX_SIZE * scale * 1.3;
        ctx.fillText(obj.text, s.x, s.y + offset);
      });

      ctx.restore();
    }

    function drawRoundedRect(ctx, x, y, w, h, r) {
      const radius = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + w - radius, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
      ctx.lineTo(x + w, y + h - radius);
      ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
      ctx.lineTo(x + radius, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    function drawBaseLabels() {
      if (!showBasePopups) return;
      ctx.save();

      bases.filter(passesFilter).forEach(b => {
        const anchor = b.anchor || b.cells[0];
        const world = gridToWorld(anchor.x, anchor.y);
        const screen = worldToScreen(world.x, world.y);

        const alliance = allianceMap[b.allianceKey] || ALLIANCES[0];
        const nameText = b.name;
        const statusText = b.status || "不明";
        const levelText = b.level != null ? `Lv.${b.level}` : "Lv.-";
        const tierText = b.tier || "T1";
        const statusLine = `${statusText} ${tierText} ${levelText}`;
        const coordText = `X${anchor.x} Y${anchor.y}`;

        const baseFontSize = Math.max(6, Math.min(12, 10 * scale * 2.0));
        const lineHeight = baseFontSize * 1.05;

        ctx.font = `${baseFontSize}px system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif`;

        const nameWidth = ctx.measureText(nameText).width;
        const statusWidth = ctx.measureText(statusLine).width;
        const coordWidth = ctx.measureText(coordText).width;
        const textWidth = Math.max(nameWidth, statusWidth, coordWidth);

        const iconSize = lineHeight * 1.8;
        const paddingX = 4 * scale * 1.5;
        const paddingY = 3 * scale * 1.5;

        const panelWidth = Math.max(textWidth, iconSize) + paddingX * 2;
        const panelHeight = paddingY * 2 + iconSize + 4 + lineHeight * 3;
        const offsetAboveHex = HEX_SIZE * scale * 1.6;

        const panelX = screen.x - panelWidth / 2;
        const panelY = screen.y - offsetAboveHex - panelHeight;

        ctx.globalAlpha = 0.9;
        ctx.fillStyle = "rgba(0,0,0,0.75)";
        drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 6);
        ctx.fill();
        ctx.globalAlpha = 1.0;
        ctx.strokeStyle = "rgba(255,255,255,0.12)";
        ctx.lineWidth = 1;
        drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 6);
        ctx.stroke();

        ctx.textAlign = "center";
        ctx.textBaseline = "top";

        let cursorY = panelY + paddingY;

        const iconX = screen.x - iconSize / 2;
        const iconY = cursorY;
        let baseColor = alliance.color;
        if (b.team === "CAPITAL") baseColor = "#ffdd55";
        else if (b.team === "CANNON") baseColor = "#ff8888";
        else if (b.team === "SUPPORT") baseColor = "#88ffdd";

        ctx.fillStyle = baseColor;
        drawRoundedRect(ctx, iconX, iconY, iconSize, iconSize, 4);
        ctx.fill();

        ctx.fillStyle = alliance.textColor || "#000";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = `${baseFontSize}px system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif`;
        ctx.fillText(alliance.name, screen.x, iconY + iconSize / 2);

        cursorY += iconSize + 4;

        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.font = `${baseFontSize}px system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif`;

        ctx.fillStyle = "rgba(255,255,255,0.96)";
        ctx.fillText(nameText, screen.x, cursorY);
        cursorY += lineHeight;

        ctx.fillStyle =
          statusText === "参加" ? "rgba(150,255,190,0.96)"
          : statusText === "不参加" ? "rgba(255,170,170,0.96)"
          : "rgba(255,230,170,0.96)";
        ctx.fillText(statusLine, screen.x, cursorY);
        cursorY += lineHeight;

        ctx.fillStyle = "rgba(210,230,255,0.96)";
        ctx.fillText(coordText, screen.x, cursorY);
      });

      ctx.restore();
    }

    function drawMemoLabels() {
      if (!showMemoPopups) return;
      ctx.save();

      const memoBases = bases.filter(b => b.memo && b.memo.trim() && passesFilter(b));
      memoBases.forEach(b => {
        const anchor = b.anchor || b.cells[0];
        const world = gridToWorld(anchor.x, anchor.y);
        const screen = worldToScreen(world.x, world.y);

        const text = b.memo.trim();
        const fontSize = Math.max(10, Math.min(18, 14 * scale * 2.0));
        const lineHeight = fontSize * 1.2;

        ctx.font = `${fontSize}px system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif`;

        const lines = text.split(/\r?\n/);
        const widths = lines.map(line => ctx.measureText(line).width);
        const textWidth = Math.max(...widths, 40);
        const paddingX = 6;
        const paddingY = 4;
        const panelWidth = textWidth + paddingX * 2;
        const panelHeight = lineHeight * lines.length + paddingY * 2;

        const offsetBelowHex = HEX_SIZE * scale * 1.8;
        const panelX = screen.x - panelWidth / 2;
        const panelY = screen.y + offsetBelowHex;

        ctx.globalAlpha = 0.95;
        ctx.fillStyle = "rgba(0,0,0,0.85)";
        drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 8);
        ctx.fill();
        ctx.globalAlpha = 1.0;
        ctx.strokeStyle = "rgba(255,255,255,0.35)";
        ctx.lineWidth = 1.2;
        drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 8);
        ctx.stroke();

        ctx.fillStyle = "rgba(255,255,255,0.96)";
        ctx.textAlign = "center";
        ctx.textBaseline = "top";

        let y = panelY + paddingY;
        lines.forEach(line => {
          ctx.fillText(line, screen.x, y);
          y += lineHeight;
        });
      });

      ctx.restore();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid();
      drawDesertOutline();
      drawBlockedOutline();
      drawRegionLabels();
      drawBaseLabels();
      drawMemoLabels();

      zoomDisplay.textContent = Math.round(scale * 100) + "%";
      cellDisplay.textContent = selectedCell
        ? `X${selectedCell.x} Y${selectedCell.y}`
        : "—";
    }

    // ===== 操作 =====
    function handleCellDoubleAction(cell) {
      const base = findBaseAtCell(cell.x, cell.y);
      if (base) openBaseDialogForEdit(base);
      else openBaseDialogForCreate(cell);
    }

    function zoomAt(mx, my, zoomDelta) {
      let newScale = scale + zoomDelta * scale;
      newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
      if (newScale === scale) return;
      const worldBefore = screenToWorld(mx, my);
      scale = newScale;
      const worldAfter = screenToWorld(mx, my);
      offsetX += (worldAfter.x - worldBefore.x) * scale;
      offsetY += (worldAfter.y - worldBefore.y) * scale;
      draw();
    }

    function focusOnBase(b) {
      const world = gridToWorld(b.anchor.x, b.anchor.y);
      const midX = canvasCssWidth / 2;
      const midY = canvasCssHeight / 2;
      offsetX = midX - world.x * scale;
      offsetY = midY - world.y * scale;
      selectedCell = { x: b.anchor.x, y: b.anchor.y };
      draw();
    }

    canvas.addEventListener("mousedown", (e) => {
      if (e.button !== 0) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;

      const base = findBaseAtCell(cell.x, cell.y);
      if (base) {
        draggingBaseId = base.id;
        lastDragCell = cell;
      } else {
        isPanning = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      }
      canvas.classList.add("dragging");
      draw();
    });

    window.addEventListener("mousemove", (e) => {
      if (draggingBaseId) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const cell = screenToGrid(mx, my);
        if (!lastDragCell || cell.x !== lastDragCell.x || cell.y !== lastDragCell.y) {
          moveBaseToGrid(draggingBaseId, cell.x, cell.y);
          lastDragCell = cell;
        }
        return;
      }
      if (!isPanning) return;
      const dx = e.clientX - lastMouseX;
      const dy = e.clientY - lastMouseY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      offsetX += dx;
      offsetY += dy;
      draw();
    });

    window.addEventListener("mouseup", () => {
      isPanning = false;
      draggingBaseId = null;
      lastDragCell = null;
      canvas.classList.remove("dragging");
    });

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      zoomAt(mx, my, delta);
    }, { passive: false });

    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;
      draw();
    });

    canvas.addEventListener("dblclick", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;
      handleCellDoubleAction(cell);
    });

    // スマホ用タッチ（ダブルタップ判定＋ドラッグ）
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mx = t.clientX - rect.left;
      const my = t.clientY - rect.top;

      touchStartX = t.clientX;
      touchStartY = t.clientY;

      const cell = screenToGrid(mx, my);
      selectedCell = cell;

      const base = findBaseAtCell(cell.x, cell.y);
      if (base) {
        draggingBaseId = base.id;
        lastDragCell = cell;
      } else {
        isPanning = true;
        lastMouseX = t.clientX;
        lastMouseY = t.clientY;
      }
      canvas.classList.add("dragging");
      draw();
    }, { passive: false });

    canvas.addEventListener("touchmove", (e) => {
      e.preventDefault();
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mx = t.clientX - rect.left;
      const my = t.clientY - rect.top;

      if (draggingBaseId) {
        const cell = screenToGrid(mx, my);
        if (!lastDragCell || cell.x !== lastDragCell.x || cell.y !== lastDragCell.y) {
          moveBaseToGrid(draggingBaseId, cell.x, cell.y);
          lastDragCell = cell;
        }
        return;
      }

      if (!isPanning) return;
      const dx = t.clientX - lastMouseX;
      const dy = t.clientY - lastMouseY;
      lastMouseX = t.clientX;
      lastMouseY = t.clientY;
      offsetX += dx;
      offsetY += dy;
      draw();
    }, { passive: false });

    window.addEventListener("touchend", (e) => {
      e.preventDefault();
      const now = Date.now();
      const rect = canvas.getBoundingClientRect();

      if (e.changedTouches && e.changedTouches.length === 1) {
        const t = e.changedTouches[0];
        const moveDist = Math.hypot(t.clientX - touchStartX, t.clientY - touchStartY);
        if (moveDist < TAP_MAX_MOVE) {
          const mx = t.clientX - rect.left;
          const my = t.clientY - rect.top;
          const cell = screenToGrid(mx, my);

          if (
            lastTapCell &&
            now - lastTapTime < TAP_MAX_DELAY &&
            lastTapCell.x === cell.x &&
            lastTapCell.y === cell.y
          ) {
            handleCellDoubleAction(cell);
            lastTapTime = 0;
            lastTapCell = null;
          } else {
            lastTapTime = now;
            lastTapCell = cell;
          }
        }
      }

      isPanning = false;
      draggingBaseId = null;
      lastDragCell = null;
      canvas.classList.remove("dragging");
    }, { passive: false });

    // ===== ボタン・UIイベント =====
    zoomInBtn.addEventListener("click", () => {
      const rect = canvas.getBoundingClientRect();
      zoomAt(rect.width / 2, rect.height / 2, 0.2);
    });
    zoomOutBtn.addEventListener("click", () => {
      const rect = canvas.getBoundingClientRect();
      zoomAt(rect.width / 2, rect.height / 2, -0.2);
    });

    toggleSidebarBtn.addEventListener("click", () => {
      sidebarEl.classList.toggle("collapsed");
      toggleSidebarBtn.textContent = sidebarEl.classList.contains("collapsed") ? "＋" : "－";
    });

    exportBtn.addEventListener("click", exportBasesToFile);
    importBtn.addEventListener("click", () => importFileInput.click());
    importFileInput.addEventListener("change", handleImportFile);

    filterKindSelect.addEventListener("change", () => {
      filterKind = filterKindSelect.value;
      updateBaseListUI();
      draw();
    });
    sortKeySelect.addEventListener("change", () => {
      sortKey = sortKeySelect.value;
      updateBaseListUI();
      draw();
    });

    popBtn.addEventListener("click", () => {
      showBasePopups = !showBasePopups;
      popBtn.classList.toggle("toggle-on", showBasePopups);
      draw();
    });
    popBtn.classList.add("toggle-on");

    memoPopBtn.addEventListener("click", () => {
      showMemoPopups = !showMemoPopups;
      memoPopBtn.classList.toggle("toggle-on", showMemoPopups);
      draw();
    });

    clearBtn.addEventListener("click", () => {
      if (!bases.length) {
        alert("削除する基地がありません。");
        return;
      }
      if (confirm("全ての基地を一括削除しますか？")) {
        bases.length = 0;
        saveBases();
        updateBaseListUI();
        draw();
      }
    });

    copyBtn.addEventListener("click", async () => {
      if (bases.length === 0) {
        alert("コピーする基地がありません。");
        return;
      }
      const filtered = bases.filter(passesFilter).sort(compareBase);
      const allianceNames = filtered.map(b => (allianceMap[b.allianceKey] || ALLIANCES[0]).name);
      const baseNames = filtered.map(b => b.name);
      const coords = filtered.map(b => `X${b.anchor.x} Y${b.anchor.y}`);

      const maxAlliance = Math.max(...allianceNames.map(s => s.length));
      const maxBase = Math.max(...baseNames.map(s => s.length));

      const lines = filtered.map((b, idx) => {
        const aName = allianceNames[idx].padEnd(maxAlliance, " ");
        const bName = baseNames[idx].padEnd(maxBase, " ");
        const coord = coords[idx];
        return `${aName}  ${bName}  ${coord}`;
      });

      const text = lines.join("\n");
      try {
        await navigator.clipboard.writeText(text);
        alert("同盟名・基地名・座標をコピーしました。");
      } catch (e) {
        console.warn(e);
        alert("クリップボードへのコピーに失敗しました。");
      }
    });

    function moveBaseToGrid(baseId, gx, gy) {
      const base = bases.find(b => b.id === baseId);
      if (!base) return;
      const cells = createBaseCellsForAnchor(gx, gy, baseId);
      if (!cells) return;
      base.cells = cells;
      base.anchor = { x: gx, y: gy };
      saveBases();
      updateBaseListUI();
      draw();
    }

    function hexToRgba(hex, alpha) {
      let c = hex.replace("#", "");
      if (c.length === 3) {
        c = c.split("").map(ch => ch + ch).join("");
      }
      const r = parseInt(c.slice(0,2), 16);
      const g = parseInt(c.slice(2,4), 16);
      const b = parseInt(c.slice(4,6), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }
  </script>
</body>
</html>
