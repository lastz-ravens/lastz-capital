<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>284 Capital</title>

  <!-- favicon -->
  <link rel="icon" type="image/png" href="favicon.png" />
  <!-- iPhone ホーム画面用 -->
  <link rel="apple-touch-icon" href="apple-touch-icon.png" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <!-- スマホのページ拡大を極力禁止 -->
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
  />

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      height: 100%;
      overflow: hidden;
      background: #050608;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5f5;
      font-size: 15px;
      touch-action: none; /* ページ自体のダブルタップ拡大抑制 */
    }
    #map-canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: radial-gradient(circle at top, #1d2838 0, #050608 50%);
      cursor: grab;
      touch-action: none;
    }
    #map-canvas.dragging { cursor: grabbing; }

    /* HUD */
    .hud {
      position: fixed;
      right: 10px;
      bottom: 10px;
      padding: 7px 11px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.65);
      backdrop-filter: blur(10px);
      font-size: 13px;
      display: flex;
      gap: 8px;
      align-items: center;
      pointer-events: none;
      z-index: 10;
    }
    .hud span.label { opacity: 0.6; }
    .hud span.value { font-variant-numeric: tabular-nums; }

    /* サイドバー */
    .sidebar {
      position: fixed;
      left: 10px;
      top: 10px;
      width: 340px;
      padding: 12px;
      border-radius: 16px;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(14px);
      font-size: 14px;
      z-index: 20;
      pointer-events: auto;
      max-height: calc(100% - 20px);
      display: flex;
      flex-direction: column;
    }
    .sidebar.collapsed {
      height: auto;
      max-height: none;
      padding: 8px 12px;
    }
    /* PCでサイドバーを畳んだときはリスト＆合計＆説明を隠す */
    .sidebar.collapsed #base-list-wrapper,
    .sidebar.collapsed #sidebar-totals,
    .sidebar.collapsed .sidebar-note {
      display: none;
    }

    /* スマホで情報だけ隠す用（ヘッダー＋ツールバーだけ残す） */
    .sidebar.info-hidden .sidebar-note,
    .sidebar.info-hidden #sidebar-totals {
      display: none;
    }

    .sidebar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      margin-bottom: 6px;
    }
    .sidebar-title {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      opacity: 0.85;
    }
    #toggle-sidebar {
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      padding: 3px 9px;
      background: rgba(0,0,0,0.9);
      color: #f5f5f5;
      cursor: pointer;
      font-size: 12px;
      pointer-events: auto;
      z-index: 1;
    }

    .sidebar-actions {
      display: flex;
      flex-direction: column;
      gap: 4px;
      flex-shrink: 0;
      align-items: flex-end;
    }
    .toolbar-row {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      justify-content: flex-end;
    }
    .sidebar-actions button,
    .sidebar-actions select {
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.15);
      padding: 3px 8px;
      font-size: 12px;
      background: rgba(10,10,10,0.9);
      color: #f5f5f5;
      cursor: pointer;
      white-space: nowrap;
    }
    .sidebar-actions button:hover {
      background: rgba(255,255,255,0.15);
    }
    .sidebar-actions select {
      appearance: none;
    }

    #base-list-wrapper {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
      margin-top: 6px;
    }
    #base-list {
      list-style: none;
      margin: 0;
      padding: 0;
      overflow-y: auto;
      flex: 1;
    }

    .sidebar-totals {
      margin-top: 4px;
      font-size: 12px;
      opacity: 0.9;
      line-height: 1.4;
      border-top: 1px solid rgba(255,255,255,0.08);
      padding-top: 4px;
    }

    .sidebar-note {
      margin-top: 6px;
      font-size: 11px;
      opacity: 0.7;
      border-top: 1px solid rgba(255,255,255,0.08);
      padding-top: 4px;
    }
    .note-pc { display: block; }
    .note-sp { display: none; margin-top: 2px; }

    #base-list li.base-item {
      display: flex;
      gap: 7px;
      padding: 7px 8px;
      border-radius: 10px;
      background: rgba(255,255,255,0.04);
      margin-bottom: 4px;
      border: 1px solid transparent;
      align-items: center;
      cursor: pointer;
      transition: opacity 0.15s;
    }
    #base-list li.base-item:hover {
      background: rgba(255,255,255,0.08);
    }
    #base-list li.base-item.selected {
      border-color: rgba(255,221,85,0.8);
      box-shadow: 0 0 0 1px rgba(255,221,85,0.4);
    }
    /* フィルターで薄表示 */
    #base-list li.base-item.dimmed {
      opacity: 0.3;
    }

    .base-color-dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      flex-shrink: 0;
      border: 1px solid rgba(0,0,0,0.7);
    }
    .base-item-info {
      flex: 1;
      min-width: 0;
    }
    .base-item-name-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 4px;
    }
    .base-name {
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .base-alliance {
      font-size: 13px;
      opacity: 0.85;
      white-space: nowrap;
    }
    .base-item-meta-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 2px;
      gap: 4px;
      font-size: 13px;
    }
    .base-coord {
      opacity: 0.8;
      white-space: nowrap;
    }
    .base-tagline {
      opacity: 0.9;
      white-space: nowrap;
    }

    /* ズームボタン */
    .zoom-buttons {
      position: fixed;
      right: 10px;
      bottom: 72px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 10;
    }
    .zoom-buttons button {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      border: none;
      background: rgba(0,0,0,0.75);
      color: #fff;
      font-size: 22px;
      cursor: pointer;
      touch-action: manipulation; /* 二度押し拡大を抑える */
    }

    /* ダイアログ用共通 */
    select, input, textarea {
      background: #111;
      color: #f5f5f5;
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 8px;
      padding: 3px 6px;
      font-size: 14px;
    }

    /* 基地追加・編集ダイアログ */
    #base-dialog {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 30;
      background: rgba(0,0,0,0.6);
    }

    @media (max-width: 768px) {
      .hud {
        right: 8px;
        top: 8px;
        bottom: auto;
        font-size: 12px;
      }
      .zoom-buttons {
        right: 8px;
        top: 60px;
        bottom: auto;
      }
      .zoom-buttons button {
        width: 44px;
        height: 44px;
        font-size: 24px;
      }
      .sidebar {
        width: 100%;
        left: 0;
        right: 0;
        top: auto;
        bottom: 0;
        border-radius: 16px 16px 0 0;
        max-height: 50vh; /* スマホでは画面の半分まで */
        font-size: 14px;
      }
      .sidebar-actions {
        align-items: flex-start;
      }
      .sidebar-actions button,
      .sidebar-actions select {
        font-size: 12px;
        padding: 4px 7px;
      }
      #base-list li.base-item {
        padding: 8px 9px;
      }
      .note-pc { display: none; }
      .note-sp { display: block; }

      /* スマホで info-hidden のときはリストも畳む */
      .sidebar.info-hidden #base-list-wrapper,
      .sidebar.info-hidden #sidebar-totals,
      .sidebar.info-hidden .sidebar-note {
        display: none;
      }
    }
  </style>
</head>
<body>
  <canvas id="map-canvas"></canvas>

  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title">284 Capital - 基地一覧</div>
      <button id="toggle-sidebar">－</button>
    </div>

    <div class="sidebar-actions">
      <!-- 上段：ボタン -->
      <div class="toolbar-row">
        <button id="copy-btn">Copy</button>
        <button id="export-btn">Exp</button>
        <button id="import-btn">Imp</button>
        <button id="auto-btn">Auto</button>
        <button id="clear-btn">Clear</button>
        <button id="pop-toggle-btn">Pop</button>
        <button id="memo-toggle-btn">Memo</button>
        <input type="file" id="import-file" accept="application/json" style="display:none" />
      </div>
      <!-- 下段：フィルター＆ソート -->
      <div class="toolbar-row">
        <label style="font-size:11px;">
          陣営
          <select id="filter-side">
            <option value="ALL">全て</option>
            <option value="ALLY">味方</option>
            <option value="ENEMY">敵</option>
          </select>
        </label>
        <label style="font-size:11px;">
          チーム
          <select id="filter-team">
            <option value="ALL">全て</option>
            <option value="首都">首都</option>
            <option value="砲台">砲台</option>
            <option value="援護">援護</option>
          </select>
        </label>
        <label style="font-size:11px;">
          ソート
          <select id="sort-key">
            <option value="alliance">同盟</option>
            <option value="name">基地名</option>
            <option value="level">Lv.</option>
            <option value="tier">T</option>
            <option value="team">チーム</option>
          </select>
        </label>
      </div>
    </div>

    <div id="base-list-wrapper">
      <ul id="base-list"></ul>
    </div>

    <div class="sidebar-totals" id="sidebar-totals"></div>

    <div class="sidebar-note">
      <div class="note-pc">
        【PC 操作】<br>
        ・空きマス：ダブルクリックで基地追加<br>
        ・基地マス：ダブルクリックで編集・削除、ドラッグで移動<br>
        ・マップ移動：左ドラッグ / ホイールでズーム / ＋－ボタンでズーム<br>
        ・Auto：選んだ同盟の「空き基地名」を、現在フォーカスしている座標周辺に自動配置<br>
        ・陣営 / チーム：リスト＆マップをフィルター（対象外は薄表示）<br>
        ・ソート：同盟 / 基地名 / Lv. / T / チームで並べ替え<br>
        ・Pop：基地情報ポップ表示 ON/OFF<br>
        ・Memo：メモポップだけ ON/OFF<br>
        ・Clear：全基地を一括削除（確認ダイアログあり）<br>
        ・Copy：同盟名・基地名・座標をコピー<br>
        ・Exp/Imp：JSONでエクスポート／インポート
      </div>
      <div class="note-sp">
        【スマホ 操作】<br>
        ・空きマス：同じマスを素早く2回タップで基地追加<br>
        ・基地マス：2回タップで編集・削除、ドラッグで移動<br>
        ・マップ移動：1本指ドラッグ / ＋－ボタンでズーム<br>
        ・Auto：フォーカス中の座標周辺に、選んだ同盟の空き基地名を自動配置<br>
        ・陣営 / チーム：対象以外はリスト＆マップ上で薄表示<br>
        ・ソート：同盟 / 基地名 / Lv. / T / チームで並べ替え<br>
        ・Pop：基地ポップ表示 ON/OFF / Memo：メモのみポップ表示 ON/OFF<br>
        ・Clear：全基地を一括削除（確認あり）<br>
        ・Copy：同盟名・基地名・座標をコピー<br>
        ・Exp/Imp：JSONファイルで保存／読み込み
      </div>
    </div>
  </div>

  <div class="zoom-buttons">
    <button id="zoom-in">＋</button>
    <button id="zoom-out">－</button>
  </div>

  <div class="hud">
    <span class="label">Zoom</span>
    <span class="value" id="zoom-display">100%</span>
    <span class="label">Cell</span>
    <span class="value" id="cell-display">—</span>
  </div>

  <!-- 基地追加・編集ダイアログ -->
  <div id="base-dialog">
    <div style="background:#101317; padding:14px 16px; border-radius:12px; width:320px; max-width:90%; font-size:14px;">
      <div style="font-size:15px; font-weight:600; margin-bottom:8px;">基地の追加 / 編集</div>
      <div style="display:flex; flex-direction:column; gap:8px;">
        <label>
          <span>陣営（味方 / 敵）</span><br />
          <select id="dlg-side" style="width:100%; margin-top:2px;">
            <option value="ALLY">味方</option>
            <option value="ENEMY">敵</option>
          </select>
        </label>
        <label>
          <span>所属同盟</span><br />
          <select id="dlg-alliance" style="width:100%; margin-top:2px;"></select>
        </label>
        <label>
          <span>基地名</span><br />
          <select id="dlg-name" style="width:100%; margin-top:2px;"></select>
        </label>
        <label>
          <span>チーム</span><br />
          <select id="dlg-team" style="width:100%; margin-top:2px;">
            <option value="">なし</option>
            <option value="首都">首都</option>
            <option value="砲台">砲台</option>
            <option value="援護">援護</option>
          </select>
        </label>
        <label>
          <span>参加状態</span><br />
          <select id="dlg-status" style="width:100%; margin-top:2px;">
            <option value="参加">参加</option>
            <option value="不参加">不参加</option>
            <option value="不明">不明</option>
          </select>
        </label>
        <label>
          <span>レベル</span><br />
          <select id="dlg-level" style="width:100%; margin-top:2px;"></select>
        </label>
        <label>
          <span>Tランク</span><br />
          <select id="dlg-tier" style="width:100%; margin-top:2px;"></select>
        </label>
        <label>
          <span>メモ</span><br />
          <textarea id="dlg-memo" rows="2" style="width:100%; margin-top:2px; resize:vertical;"></textarea>
        </label>
        <div style="font-size:12px; opacity:0.7;" id="dlg-coord-text"></div>
      </div>
      <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:12px;">
        <button id="dlg-cancel"
          style="border:none; border-radius:999px; padding:5px 12px; font-size:14px; background:#444; color:#f5f5f5;">
          キャンセル
        </button>
        <button id="dlg-delete"
          style="border:none; border-radius:999px; padding:5px 12px; font-size:14px; background:#aa3333; color:#fff; display:none;">
          削除
        </button>
        <button id="dlg-ok"
          style="border:none; border-radius:999px; padding:5px 12px; font-size:14px; background:#2c7be5; color:#fff;">
          決定
        </button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("map-canvas");
    const ctx = canvas.getContext("2d");
    const zoomDisplay = document.getElementById("zoom-display");
    const cellDisplay = document.getElementById("cell-display");
    const baseListEl = document.getElementById("base-list");
    const sidebarEl = document.getElementById("sidebar");
    const sidebarTotalsEl = document.getElementById("sidebar-totals");

    const copyBtn = document.getElementById("copy-btn");
    const toggleSidebarBtn = document.getElementById("toggle-sidebar");
    const zoomInBtn = document.getElementById("zoom-in");
    const zoomOutBtn = document.getElementById("zoom-out");
    const exportBtn = document.getElementById("export-btn");
    const importBtn = document.getElementById("import-btn");
    const autoBtn = document.getElementById("auto-btn");
    const clearBtn = document.getElementById("clear-btn");
    const importFileInput = document.getElementById("import-file");

    const filterSideSel = document.getElementById("filter-side");
    const filterTeamSel = document.getElementById("filter-team");
    const sortKeySel = document.getElementById("sort-key");
    const popToggleBtn = document.getElementById("pop-toggle-btn");
    const memoToggleBtn = document.getElementById("memo-toggle-btn");

    const baseDialog = document.getElementById("base-dialog");
    const dlgSide = document.getElementById("dlg-side");
    const dlgAlliance = document.getElementById("dlg-alliance");
    const dlgName = document.getElementById("dlg-name");
    const dlgTeam = document.getElementById("dlg-team");
    const dlgStatus = document.getElementById("dlg-status");
    const dlgLevel = document.getElementById("dlg-level");
    const dlgTier = document.getElementById("dlg-tier");
    const dlgMemo = document.getElementById("dlg-memo");
    const dlgCoordText = document.getElementById("dlg-coord-text");
    const dlgCancel = document.getElementById("dlg-cancel");
    const dlgOk = document.getElementById("dlg-ok");
    const dlgDelete = document.getElementById("dlg-delete");

    const HEX_SIZE = 20;
    const GRID_MAX_X = 999;
    const GRID_MAX_Y = 999;
    const HEX_VERT_SPACING = 1.5 * HEX_SIZE;
    const HEX_HORIZ_SPACING = Math.sqrt(3) * HEX_SIZE;
    const EDGE_THICKNESS_WORLD = HEX_SIZE * 0.8;
    const STORAGE_KEY = "hexmap_bases_v11";

    let scale = 0.35;
    let offsetX = 0;
    let offsetY = 0;
    const MIN_SCALE = 0.08;
    const MAX_SCALE = 3.0;

    let isPanning = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let selectedCell = null;
    let selectedBaseId = null;

    let touchStartX = 0;
    let touchStartY = 0;
    let lastTapTime = 0;
    let lastTapCell = null;
    const TAP_MAX_DELAY = 320;
    const TAP_MAX_MOVE = 12;

    let draggingBaseId = null;
    let lastDragCell = null;

    const bases = [];

    const CAPITAL_CENTER_X = 500;
    const CAPITAL_CENTER_Y = 500;
    const VIEW_RADIUS = 50;
    const VIEW_MIN_X = Math.max(0, CAPITAL_CENTER_X - VIEW_RADIUS);
    const VIEW_MAX_X = Math.min(GRID_MAX_X, CAPITAL_CENTER_X + VIEW_RADIUS);
    const VIEW_MIN_Y = Math.max(0, CAPITAL_CENTER_Y - VIEW_RADIUS);
    const VIEW_MAX_Y = Math.min(GRID_MAX_Y, CAPITAL_CENTER_Y + VIEW_RADIUS);

    // 敵/味方 1000人
    const ENEMY_MEMBERS = Array.from({ length: 1000 }, (_, i) => "敵" + String(i + 1).padStart(3, "0"));
    const ALLY_MEMBERS = Array.from({ length: 1000 }, (_, i) => "味方" + String(i + 1).padStart(3, "0"));

    // 味方/敵 基本色＋チーム色
    function getBaseColor(b) {
      const side = b.side || "ALLY";
      const team = b.team || "";
      if (side === "ALLY") {
        if (team === "首都") return "#99ffcc";
        if (team === "砲台") return "#55dd88";
        if (team === "援護") return "#44bb77";
        return "#66ff99"; // デフォルト味方
      } else {
        if (team === "首都") return "#ff9999";
        if (team === "砲台") return "#ff4444";
        if (team === "援護") return "#dd5555";
        return "#ff6666"; // デフォルト敵
      }
    }

    const ALLIANCES = [
      {
        key: "B777",
        name: "B777",
        side: "ALLY",
        color: "#ffcc00",
        textColor: "#201500",
        members: [
          "SuperZeus","Ram","ponsu","すぎっしー","NEXUS21","neku-ra","Crazy楊Frog",
          "GENLuckyTrigger","マナ","Ramen-X","やちこ","ヨホホホホ","Lamawa","Carna the God","jun33",
          "オーシマン","るんず","WDギャン","Hans 23","アカサ","えび","ステカセ王","ケイー","Yanoyano",
          "赤ヘル","タカちゃん","RUKA0806","ポル","yanchaaan","zerozerozero","アルアル","M731","Vikara",
          "RUSK222","JoJo11","フランメ","Happyぼっち","keioka","みにこり","キャノン","靈魂拷問者","迷子",
          "simon-nu","まむし","OneTop","しまんちゅ","Vivihana","PIPECUT","ロッシー","Ra-Men-Man","yusukerion",
          "onaka","xJISOOx","れみす","ヴォーグ","mr344","浮亂苦","Nescop","irohoma","くまみーん","亞丘?斯",
          "岡ティー","アイアイ","サムエル","もえご","QQ27","elchaaaan","Coffee jelly","ぺけたん","SEELE",
          "mamimumemo","あこまき","ジャン","1m2","ユウディ","ウニいくら","いろはす","Tnation","バイソン",
          "たけむー","CraZyLiOn","アジング","lupiX","nyu-ha-to","＊MISERY＊","もーー","Sakura0207","ピザコーラ",
          "ronrico","余韻","GSX1300R"
        ]
      },
      {
        key: "EclA",
        name: "EclA",
        side: "ALLY",
        color: "#66ccff",
        textColor: "#002233",
        members: [
          "伏黒 恵","冨岡 義勇","RENOVATIO","reaper777","Lucien Dodsa","はるちゃん","D0NKI호테",
          "ダンテ　G","Jabol86","DV 디뷔","온새결","c-137","SimpleDude","まるる","以蔵 -IZO-",
          "はだて","岳仔","バトウアン","RaineForest","Nishi7","hajime77777","Nobodymeow",
          "CORONELNEMO","조다슬남편","v끝판대장v","めいちゃん","NAT-","현대제철","Squidward jr",
          "AINS","RAVI10","Kori77","SeoulGirl","User2abcd","makonosuke","Wolfdog Walker",
          "Kiki777","nelipot","StoyanS","VIadimir Fido","Suokki","Jesterko","t imo",
          "Machang Bubok","plwro","CーPON","RastaRob","CRAZY H","SoupySuperStar","Dentrival",
          "Z‌‌","KANASAl","godjji","cubelee","DoMToDd","Craigクレグ","Aiaaahhh","fun die ?",
          "PaladinFriend","omjmj","日出打金","duberman","アビー","White Paladin",
          "•BadKitty18","MegaDragonite","にぃ","R0KAN","香ばしい","Sky18","Tiara333",
          "Taro12","masa1121","simply red","Mirellle","Diegomv","・LUZ","SurvivorREM",
          "AlexNesty","Idealize","Decade 2","Mos M Zer Lor","Jeyci","DiegoX","anhcatim",
          "Emmanuel Wick","야찰퀸","poem0320","Crimson-Sky","Noval Yoko","Lariatte",
          "Maelle SZ","조다슬남편"
        ]
      },
      {
        key: "ALLY",
        name: "味方",
        side: "ALLY",
        color: "#99ffcc",
        textColor: "#002010",
        members: ALLY_MEMBERS
      },
      {
        key: "ENEMY",
        name: "敵",
        side: "ENEMY",
        color: "#ff6666",
        textColor: "#2a0000",
        members: ENEMY_MEMBERS
      }
    ];

    const allianceMap = {};
    ALLIANCES.forEach(a => { allianceMap[a.key] = a; });

    const desertVerticesGrid = [
      { x: 482, y: 465 },
      { x: 465, y: 500 },
      { x: 482, y: 535 },
      { x: 517, y: 535 },
      { x: 535, y: 500 },
      { x: 517, y: 465 }
    ];
    const blockedVerticesGrid = [
      { x: 483, y: 500 },
      { x: 491, y: 517 },
      { x: 508, y: 517 },
      { x: 517, y: 500 },
      { x: 508, y: 483 },
      { x: 491, y: 483 }
    ];
    const extraBlockedCells = [
      { x: 489, y: 515 },{ x: 490, y: 516 },{ x: 490, y: 517 },{ x: 491, y: 518 },
      { x: 491, y: 585 },{ x: 492, y: 518 },{ x: 493, y: 518 },{ x: 494, y: 518 },
      { x: 489, y: 516 },{ x: 489, y: 517 },{ x: 490, y: 518 },{ x: 490, y: 519 },
      { x: 491, y: 519 },{ x: 492, y: 519 },{ x: 493, y: 519 },
      { x: 517, y: 502 },{ x: 517, y: 501 },{ x: 517, y: 502 },{ x: 518, y: 500 },
      { x: 518, y: 499 },{ x: 518, y: 498 },{ x: 517, y: 497 },{ x: 517, y: 496 },
      { x: 517, y: 499 },{ x: 517, y: 498 },{ x: 516, y: 497 },{ x: 516, y: 496 },
      { x: 489, y: 485 },{ x: 489, y: 484 },{ x: 489, y: 483 },{ x: 490, y: 482 },
      { x: 490, y: 484 },{ x: 490, y: 483 },{ x: 491, y: 482 },{ x: 491, y: 481 },
      { x: 492, y: 482 },{ x: 492, y: 481 },{ x: 493, y: 482 },{ x: 494, y: 482 },
      { x: 490, y: 481 },{ x: 493, y: 481 },{ x: 494, y: 482 }
    ];

    let desertPolygonWorld = [];
    let blockedPolygonWorld = [];

    const basePatternAxial = [
      { dq: 0, dr: 0 },
      { dq: 1, dr: 0 },
      { dq: 0, dr: 1 },
      { dq: -1, dr: 1 },
      { dq: -1, dr: 0 },
      { dq: 0, dr: -1 },
      { dq: 1, dr: -1 }
    ];

    function oddrToAxial(col, row) {
      const q = col - (row - (row & 1)) / 2;
      const r = row;
      return { q, r };
    }
    function axialToOddr(q, r) {
      const row = r;
      const col = q + (r - (r & 1)) / 2;
      return { x: col, y: row };
    }

    function gridToWorld(gx, gy) {
      const wx = HEX_HORIZ_SPACING * (gx + (gy & 1) * 0.5);
      const wy = HEX_VERT_SPACING * gy;
      return { x: wx, y: wy };
    }
    function worldToScreen(wx, wy) {
      return { x: wx * scale + offsetX, y: wy * scale + offsetY };
    }
    function screenToWorld(sx, sy) {
      return { x: (sx - offsetX) / scale, y: (sy - offsetY) / scale };
    }
    function screenToGrid(sx, sy) {
      const w = screenToWorld(sx, sy);
      let gy = Math.round(w.y / HEX_VERT_SPACING);
      gy = Math.max(0, Math.min(GRID_MAX_Y, gy));
      const rowOffset = (gy & 1) ? HEX_HORIZ_SPACING * 0.5 : 0;
      let gx = Math.round((w.x - rowOffset) / HEX_HORIZ_SPACING);
      gx = Math.max(0, Math.min(GRID_MAX_X, gx));
      return { x: gx, y: gy };
    }

    function pointInPolygon(point, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect =
          ((yi > point.y) !== (yj > point.y)) &&
          (point.x < (xj - xi) * (point.y - yi) / (yj - yi + 1e-9) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    function pointToSegmentDistance(p, a, b) {
      const vx = b.x - a.x;
      const vy = b.y - a.y;
      const wx = p.x - a.x;
      const wy = p.y - a.y;
      const c1 = vx * wx + vy * wy;
      if (c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y);
      const c2 = vx * vx + vy * vy;
      if (c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y);
      const t = c1 / c2;
      const projx = a.x + t * vx;
      const projy = a.y + t * vy;
      return Math.hypot(p.x - projx, p.y - projy);
    }
    function distanceToPolygonEdges(p, polygon) {
      let minD = Infinity;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const d = pointToSegmentDistance(p, polygon[j], polygon[i]);
        if (d < minD) minD = d;
      }
      return minD;
    }

    function isBlockedCell(gx, gy) {
      for (let i = 0; i < extraBlockedCells.length; i++) {
        const c = extraBlockedCells[i];
        if (c.x === gx && c.y === gy) return true;
      }
      const w = gridToWorld(gx, gy);
      const inside = pointInPolygon(w, blockedPolygonWorld);
      const dist = distanceToPolygonEdges(w, blockedPolygonWorld);
      return inside || dist <= EDGE_THICKNESS_WORLD;
    }

    function findBaseAtCell(gx, gy) {
      for (let i = 0; i < bases.length; i++) {
        const b = bases[i];
        for (let j = 0; j < b.cells.length; j++) {
          const c = b.cells[j];
          if (c.x === gx && c.y === gy) {
            return b;
          }
        }
      }
      return null;
    }

    function createBaseCellsForAnchor(gx, gy, ignoreBaseId) {
      const ar = oddrToAxial(gx, gy);
      const cells = [];
      for (let i = 0; i < basePatternAxial.length; i++) {
        const off = basePatternAxial[i];
        const oq = ar.q + off.dq;
        const or = ar.r + off.dr;
        const o = axialToOddr(oq, or);
        cells.push(o);
      }
      for (let i = 0; i < cells.length; i++) {
        const c = cells[i];
        if (c.x < 0 || c.x > GRID_MAX_X || c.y < 0 || c.y > GRID_MAX_Y) return null;
        if (isBlockedCell(c.x, c.y)) return null;
        for (let bi = 0; bi < bases.length; bi++) {
          const b = bases[bi];
          if (ignoreBaseId && b.id === ignoreBaseId) continue;
          for (let cj = 0; cj < b.cells.length; cj++) {
            const bc = b.cells[cj];
            if (bc.x === c.x && bc.y === c.y) return null;
          }
        }
      }
      return cells;
    }

    function deleteBaseById(id) {
      const idx = bases.findIndex(b => b.id === id);
      if (idx !== -1) {
        bases.splice(idx, 1);
        saveBases();
        updateBaseListUI();
        updateTotals();
        draw();
      }
    }

    function makeSerializableData() {
      return {
        bases: bases.map(b => ({
          id: b.id,
          side: b.side,
          allianceKey: b.allianceKey,
          name: b.name,
          team: b.team,
          status: b.status,
          level: b.level,
          tier: b.tier,
          memo: b.memo || "",
          anchor: b.anchor
        }))
      };
    }

    function saveBases() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(makeSerializableData()));
      } catch (e) {
        console.warn("saveBases error:", e);
      }
    }

    function loadBases() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      try {
        const data = JSON.parse(raw);
        if (!data || !Array.isArray(data.bases)) return;
        data.bases.forEach(rec => {
          if (!rec.anchor) return;
          const cells = createBaseCellsForAnchor(rec.anchor.x, rec.anchor.y, null);
          if (!cells) return;
          const alliance = allianceMap[rec.allianceKey] || ALLIANCES[0];
          bases.push({
            id: rec.id || (Date.now().toString(36) + Math.random().toString(36).slice(2,7)),
            side: rec.side || alliance.side || "ALLY",
            allianceKey: rec.allianceKey || "B777",
            name: rec.name || "基地",
            team: rec.team || "",
            status: rec.status || "不明",
            level: rec.level ?? null,
            tier: rec.tier || "T1",
            memo: rec.memo || "",
            cells,
            anchor: rec.anchor
          });
        });
      } catch (e) {
        console.warn("loadBases error:", e);
      }
    }

    function importBasesFromData(data) {
      if (!data || !Array.isArray(data.bases)) {
        alert("インポートするJSONの形式が不正です。");
        return;
      }
      if (!confirm("現在の基地データを全て置き換えますか？")) return;
      bases.length = 0;
      data.bases.forEach(rec => {
        if (!rec.anchor) return;
        const cells = createBaseCellsForAnchor(rec.anchor.x, rec.anchor.y, null);
        if (!cells) return;
        const alliance = allianceMap[rec.allianceKey] || ALLIANCES[0];
        bases.push({
          id: rec.id || (Date.now().toString(36) + Math.random().toString(36).slice(2,7)),
          side: rec.side || alliance.side || "ALLY",
          allianceKey: rec.allianceKey || "B777",
          name: rec.name || "基地",
          team: rec.team || "",
          status: rec.status || "不明",
          level: rec.level ?? null,
          tier: rec.tier || "T1",
          memo: rec.memo || "",
          cells,
          anchor: rec.anchor
        });
      });
      saveBases();
      updateBaseListUI();
      updateTotals();
      draw();
    }

    function exportBasesToFile() {
      const data = makeSerializableData();
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "bases.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function handleImportFile(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(ev) {
        try {
          const data = JSON.parse(ev.target.result);
          importBasesFromData(data);
        } catch (err) {
          console.error(err);
          alert("JSONの読み込みに失敗しました。");
        } finally {
          importFileInput.value = "";
        }
      };
      reader.readAsText(file, "utf-8");
    }

    exportBtn.addEventListener("click", exportBasesToFile);
    importBtn.addEventListener("click", function() {
      importFileInput.click();
    });
    importFileInput.addEventListener("change", handleImportFile);

    // フィルター状態
    let filterSide = "ALL";
    let filterTeam = "ALL";

    function isBaseMatchFilter(b) {
      if (filterSide !== "ALL" && b.side !== filterSide) return false;
      if (filterTeam !== "ALL" && b.team !== filterTeam) return false;
      return true;
    }

    function getFilteredBases() {
      return bases.filter(isBaseMatchFilter);
    }

    filterSideSel.addEventListener("change", function() {
      filterSide = filterSideSel.value;
      updateBaseListUI();
      updateTotals();
      draw();
    });
    filterTeamSel.addEventListener("change", function() {
      filterTeam = filterTeamSel.value;
      updateBaseListUI();
      updateTotals();
      draw();
    });
    sortKeySel.addEventListener("change", function() {
      updateBaseListUI();
    });

    // Pop ON/OFF
    let showBasePopups = true;
    let showMemoPopups = true;
    popToggleBtn.textContent = "Pop ON";
    memoToggleBtn.textContent = "Memo ON";

    popToggleBtn.addEventListener("click", function() {
      showBasePopups = !showBasePopups;
      popToggleBtn.textContent = showBasePopups ? "Pop ON" : "Pop OFF";
      draw();
    });
    memoToggleBtn.addEventListener("click", function() {
      showMemoPopups = !showMemoPopups;
      memoToggleBtn.textContent = showMemoPopups ? "Memo ON" : "Memo OFF";
      draw();
    });

    // ダイアログ状態
    let dialogMode = "create";
    let dialogCell = null;
    let dialogEditingBase = null;

    function initDialogSelectors() {
      dlgLevel.innerHTML = "";
      for (let lv = 30; lv >= 1; lv--) {
        const opt = document.createElement("option");
        opt.value = String(lv);
        opt.textContent = "Lv." + lv;
        dlgLevel.appendChild(opt);
      }
      dlgTier.innerHTML = "";
      for (let t = 10; t >= 1; t--) {
        const opt = document.createElement("option");
        opt.value = "T" + t;
        opt.textContent = "T" + t;
        dlgTier.appendChild(opt);
      }
      updateAllianceOptionsBySide("ALLY");
    }

    function updateAllianceOptionsBySide(side) {
      const list = ALLIANCES.filter(a => a.side === side);
      list.sort((a, b) => {
        const aGen = (a.key === side);
        const bGen = (b.key === side);
        if (aGen && !bGen) return -1;
        if (!aGen && bGen) return 1;
        return a.name.localeCompare(b.name, "ja");
      });
      dlgAlliance.innerHTML = "";
      list.forEach(a => {
        const opt = document.createElement("option");
        opt.value = a.key;
        opt.textContent = a.name;
        dlgAlliance.appendChild(opt);
      });
    }

    function updateNameOptionsForAlliance(allianceKey, currentName) {
      const alliance = allianceMap[allianceKey];
      dlgName.innerHTML = "";
      if (!alliance) return;
      // 同盟ごとの使用済み基地名だけをチェック
      const used = new Set(
        bases.filter(b => b.allianceKey === allianceKey).map(b => b.name)
      );
      alliance.members.forEach(function(name) {
        if (dialogMode === "edit" && name === currentName) {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          dlgName.appendChild(opt);
        } else if (!used.has(name)) {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          dlgName.appendChild(opt);
        }
      });
      if (dlgName.options.length === 0) {
        const opt = document.createElement("option");
        opt.value = currentName || "";
        opt.textContent = currentName || "(空き基地名なし)";
        dlgName.appendChild(opt);
      }
    }

    dlgSide.addEventListener("change", function() {
      const side = dlgSide.value;
      updateAllianceOptionsBySide(side);
      // デフォルトは味方→ALLY, 敵→ENEMY
      let defKey = side;
      let found = false;
      for (let i = 0; i < dlgAlliance.options.length; i++) {
        if (dlgAlliance.options[i].value === defKey) {
          dlgAlliance.value = defKey;
          found = true;
          break;
        }
      }
      if (!found && dlgAlliance.options.length) {
        dlgAlliance.value = dlgAlliance.options[0].value;
      }
      const currentName = dialogEditingBase ? dialogEditingBase.name : null;
      updateNameOptionsForAlliance(dlgAlliance.value, currentName);
    });

    dlgAlliance.addEventListener("change", function() {
      const key = dlgAlliance.value;
      const currentName = dialogEditingBase ? dialogEditingBase.name : null;
      updateNameOptionsForAlliance(key, currentName);
    });

    function openBaseDialogForCreate(cell) {
      dialogMode = "create";
      dialogCell = cell;
      dialogEditingBase = null;
      dlgDelete.style.display = "none";

      dlgSide.value = "ALLY";
      updateAllianceOptionsBySide("ALLY");
      // 所属同盟デフォルトは「味方」
      if ([...dlgAlliance.options].some(o => o.value === "ALLY")) {
        dlgAlliance.value = "ALLY";
      } else if (dlgAlliance.options.length) {
        dlgAlliance.value = dlgAlliance.options[0].value;
      }
      updateNameOptionsForAlliance(dlgAlliance.value, null);

      dlgTeam.value = "";          // デフォルト「なし」
      dlgStatus.value = "参加";    // デフォルト参加
      dlgLevel.value = "27";       // デフォルトLv.27
      dlgTier.value = "T9";        // デフォルトT9
      dlgMemo.value = "";

      dlgCoordText.textContent = "配置セル: X" + cell.x + " Y" + cell.y;
      baseDialog.style.display = "flex";
    }

    function openBaseDialogForEdit(base) {
      dialogMode = "edit";
      dialogEditingBase = base;
      dialogCell = base.anchor;
      dlgDelete.style.display = "inline-block";

      dlgSide.value = base.side || "ALLY";
      updateAllianceOptionsBySide(dlgSide.value);
      dlgAlliance.value = base.allianceKey || "B777";
      updateNameOptionsForAlliance(base.allianceKey || "B777", base.name);
      dlgName.value = base.name;
      dlgTeam.value = base.team || "";
      dlgStatus.value = base.status || "不明";
      if (base.level != null) dlgLevel.value = String(base.level);
      dlgTier.value = base.tier || "T1";
      dlgMemo.value = base.memo || "";

      dlgCoordText.textContent = "配置セル: X" + base.anchor.x + " Y" + base.anchor.y;
      baseDialog.style.display = "flex";
    }

    function closeBaseDialog() {
      baseDialog.style.display = "none";
      dialogCell = null;
      dialogEditingBase = null;
    }

    dlgCancel.addEventListener("click", function() {
      closeBaseDialog();
    });

    dlgDelete.addEventListener("click", function() {
      if (!dialogEditingBase) return;
      if (confirm("基地「" + dialogEditingBase.name + "」を削除しますか？")) {
        deleteBaseById(dialogEditingBase.id);
        closeBaseDialog();
      }
    });

    dlgOk.addEventListener("click", function() {
      const side = dlgSide.value;
      const allianceKey = dlgAlliance.value;
      const alliance = allianceMap[allianceKey] || ALLIANCES[0];
      const name = dlgName.value || "基地";
      const team = dlgTeam.value || "";
      const status = dlgStatus.value || "不明";
      const level = Number(dlgLevel.value || "0");
      const tier = dlgTier.value || "T1";
      const memo = dlgMemo.value || "";

      if (!dialogCell) {
        closeBaseDialog();
        return;
      }
      const gx = dialogCell.x;
      const gy = dialogCell.y;

      if (dialogMode === "create") {
        const cells = createBaseCellsForAnchor(gx, gy, null);
        if (!cells) {
          alert("この位置には基地を配置できません。");
          return;
        }
        const id = Date.now().toString(36) + Math.random().toString(36).slice(2,7);
        bases.push({
          id: id,
          side: side,
          allianceKey: alliance.key,
          name: name,
          team: team,
          status: status,
          level: isNaN(level) ? null : level,
          tier: tier,
          memo: memo,
          cells: cells,
          anchor: { x: gx, y: gy }
        });
      } else if (dialogMode === "edit" && dialogEditingBase) {
        const cells = createBaseCellsForAnchor(gx, gy, dialogEditingBase.id);
        if (!cells) {
          alert("この位置には基地を配置できません。");
          return;
        }
        dialogEditingBase.side = side;
        dialogEditingBase.allianceKey = alliance.key;
        dialogEditingBase.name = name;
        dialogEditingBase.team = team;
        dialogEditingBase.status = status;
        dialogEditingBase.level = isNaN(level) ? null : level;
        dialogEditingBase.tier = tier;
        dialogEditingBase.memo = memo;
        dialogEditingBase.cells = cells;
        dialogEditingBase.anchor = { x: gx, y: gy };
      }

      saveBases();
      updateBaseListUI();
      updateTotals();
      draw();
      closeBaseDialog();
    });

    function focusOnBase(b) {
      const rect = canvas.getBoundingClientRect();
      const world = gridToWorld(b.anchor.x, b.anchor.y);
      offsetX = rect.width / 2 - world.x * scale;
      offsetY = rect.height / 2 - world.y * scale;
      draw();
    }

    function updateBaseListUI() {
      baseListEl.innerHTML = "";
      const sortKey = sortKeySel.value;

      const sorted = bases.slice().sort(function(a, b) {
        if (sortKey === "alliance") {
          const aa = (allianceMap[a.allianceKey] && allianceMap[a.allianceKey].name) || a.allianceKey;
          const bb = (allianceMap[b.allianceKey] && allianceMap[b.allianceKey].name) || b.allianceKey;
          return aa.localeCompare(bb, "ja");
        } else if (sortKey === "name") {
          return (a.name || "").localeCompare(b.name || "", "ja");
        } else if (sortKey === "level") {
          const la = a.level || 0;
          const lb = b.level || 0;
          if (la !== lb) return lb - la;
          return (a.name || "").localeCompare(b.name || "", "ja");
        } else if (sortKey === "tier") {
          const ta = parseInt((a.tier || "T1").slice(1), 10) || 1;
          const tb = parseInt((b.tier || "T1").slice(1), 10) || 1;
          if (ta !== tb) return tb - ta;
          return (a.name || "").localeCompare(b.name || "", "ja");
        } else if (sortKey === "team") {
          return (a.team || "").localeCompare(b.team || "", "ja");
        }
        return 0;
      });

      sorted.forEach(function(b) {
        const li = document.createElement("li");
        li.className = "base-item";
        if (b.id === selectedBaseId) {
          li.classList.add("selected");
        }
        if (!isBaseMatchFilter(b)) {
          li.classList.add("dimmed");
        }

        const alliance = allianceMap[b.allianceKey] || ALLIANCES[0];
        const baseColor = getBaseColor(b);

        const dot = document.createElement("div");
        dot.className = "base-color-dot";
        dot.style.background = baseColor;

        const info = document.createElement("div");
        info.className = "base-item-info";

        const nameRow = document.createElement("div");
        nameRow.className = "base-item-name-row";

        const nameSpan = document.createElement("span");
        nameSpan.className = "base-name";
        nameSpan.textContent = b.name;

        const allianceSpan = document.createElement("span");
        allianceSpan.className = "base-alliance";
        allianceSpan.textContent = (b.side === "ALLY" ? "味方" : "敵") + " / " + alliance.name;

        nameRow.appendChild(nameSpan);
        nameRow.appendChild(allianceSpan);

        const metaRow = document.createElement("div");
        metaRow.className = "base-item-meta-row";

        const coordSpan = document.createElement("span");
        coordSpan.className = "base-coord";
        coordSpan.textContent = "X" + b.anchor.x + " Y" + b.anchor.y;

        const tagSpan = document.createElement("span");
        tagSpan.className = "base-tagline";
        const lv = b.level != null ? "Lv." + b.level : "Lv.-";
        const teamLabel = b.team ? b.team : "チームなし";
        tagSpan.textContent = b.status + " " + b.tier + " " + lv + " / " + teamLabel;

        metaRow.appendChild(coordSpan);
        metaRow.appendChild(tagSpan);

        info.appendChild(nameRow);
        info.appendChild(metaRow);

        li.appendChild(dot);
        li.appendChild(info);

        li.addEventListener("click", function() {
          selectedBaseId = b.id;
          selectedCell = { x: b.anchor.x, y: b.anchor.y }; // ← 自動配置の基準にもなる
          focusOnBase(b);
          updateBaseListUI();
        });
        li.addEventListener("dblclick", function(e) {
          e.stopPropagation();
          selectedBaseId = b.id;
          openBaseDialogForEdit(b);
        });

        baseListEl.appendChild(li);
      });
    }

    function updateTotals() {
      const list = getFilteredBases();
      const total = list.length;
      let allyCount = 0;
      let enemyCount = 0;
      const teamCounts = { "首都": 0, "砲台": 0, "援護": 0, "": 0 };
      const statusCounts = { "参加": 0, "不参加": 0, "不明": 0 };
      const lvCounts = {};
      const tCounts = {};

      list.forEach(function(b) {
        if (b.side === "ALLY") allyCount++;
        else if (b.side === "ENEMY") enemyCount++;

        teamCounts[b.team || ""] = (teamCounts[b.team || ""] || 0) + 1;
        statusCounts[b.status || "不明"] = (statusCounts[b.status || "不明"] || 0) + 1;
        if (b.level != null) {
          lvCounts[b.level] = (lvCounts[b.level] || 0) + 1;
        }
        if (b.tier) {
          const tnum = parseInt(b.tier.slice(1), 10);
          if (!isNaN(tnum)) {
            tCounts[tnum] = (tCounts[tnum] || 0) + 1;
          }
        }
      });

      const teamParts = [];
      if (teamCounts["首都"]) teamParts.push("首都 " + teamCounts["首都"]);
      if (teamCounts["砲台"]) teamParts.push("砲台 " + teamCounts["砲台"]);
      if (teamCounts["援護"]) teamParts.push("援護 " + teamCounts["援護"]);
      if (teamCounts[""] && teamCounts[""] > 0) teamParts.push("なし " + teamCounts[""]);

      const statusParts = [];
      if (statusCounts["参加"]) statusParts.push("参加 " + statusCounts["参加"]);
      if (statusCounts["不参加"]) statusParts.push("不参加 " + statusCounts["不参加"]);
      if (statusCounts["不明"]) statusParts.push("不明 " + statusCounts["不明"]);

      const lvParts = [];
      Object.keys(lvCounts)
        .map(x => parseInt(x, 10))
        .sort((a, b) => b - a)
        .forEach(lv => {
          lvParts.push("Lv." + lv + " " + lvCounts[lv]);
        });

      const tParts = [];
      Object.keys(tCounts)
        .map(x => parseInt(x, 10))
        .sort((a, b) => b - a)
        .forEach(tn => {
          tParts.push("T" + tn + " " + tCounts[tn]);
        });

      let html = "総数 " + total + " / 味方 " + allyCount + " / 敵 " + enemyCount;
      if (teamParts.length) html += "<br>チーム " + teamParts.join(" / ");
      if (statusParts.length) html += "<br>状態 " + statusParts.join(" / ");
      if (lvParts.length) html += "<br>Lv.内訳 " + lvParts.join(" / ");
      if (tParts.length) html += "<br>T内訳 " + tParts.join(" / ");
      sidebarTotalsEl.innerHTML = html;
    }

    function drawRoundedRect(ctx2, x, y, w, h, r) {
      const radius = Math.min(r, w / 2, h / 2);
      ctx2.beginPath();
      ctx2.moveTo(x + radius, y);
      ctx2.lineTo(x + w - radius, y);
      ctx2.quadraticCurveTo(x + w, y, x + w, y + radius);
      ctx2.lineTo(x + w, y + h - radius);
      ctx2.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
      ctx2.lineTo(x + radius, y + h);
      ctx2.quadraticCurveTo(x, y + h, x, y + h - radius);
      ctx2.lineTo(x, y + radius);
      ctx2.quadraticCurveTo(x, y, x + radius, y);
      ctx2.closePath();
    }

    function hexToRgba(hex, alpha) {
      let c = hex.replace("#", "");
      if (c.length === 3) {
        c = c.split("").map(ch => ch + ch).join("");
      }
      const r = parseInt(c.slice(0, 2), 16);
      const g = parseInt(c.slice(2, 4), 16);
      const b = parseInt(c.slice(4, 6), 16);
      return "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
    }

    function drawHexCenter(wx, wy, strokeStyle, fillStyle, lineWidth) {
      const sPos = worldToScreen(wx, wy);
      const s = HEX_SIZE * scale;
      const w = Math.sqrt(3) * s;
      const h = s;

      const pts = [
        { x: sPos.x,       y: sPos.y - h },
        { x: sPos.x + w/2, y: sPos.y - h/2 },
        { x: sPos.x + w/2, y: sPos.y + h/2 },
        { x: sPos.x,       y: sPos.y + h },
        { x: sPos.x - w/2, y: sPos.y + h/2 },
        { x: sPos.x - w/2, y: sPos.y - h/2 }
      ];

      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) {
        ctx.lineTo(pts[i].x, pts[i].y);
      }
      ctx.closePath();

      if (fillStyle) {
        ctx.fillStyle = fillStyle;
        ctx.fill();
      }
      if (strokeStyle) {
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = lineWidth;
        ctx.stroke();
      }
    }

    function drawGrid() {
      const rect = canvas.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;
      const margin = 80 / scale;
      const topLeftWorld = screenToWorld(-margin, -margin);
      const bottomRightWorld = screenToWorld(w + margin, h + margin);

      let gyMin = Math.floor(topLeftWorld.y / HEX_VERT_SPACING) - 2;
      let gyMax = Math.ceil(bottomRightWorld.y / HEX_VERT_SPACING) + 2;
      gyMin = Math.max(VIEW_MIN_Y, Math.max(0, gyMin));
      gyMax = Math.min(VIEW_MAX_Y, Math.min(GRID_MAX_Y, gyMax));

      for (let gy = gyMin; gy <= gyMax; gy++) {
        const rowOffset = (gy & 1) ? HEX_HORIZ_SPACING * 0.5 : 0;

        let gxMin = Math.floor((topLeftWorld.x - rowOffset) / HEX_HORIZ_SPACING) - 2;
        let gxMax = Math.ceil((bottomRightWorld.x - rowOffset) / HEX_HORIZ_SPACING) + 2;
        gxMin = Math.max(VIEW_MIN_X, Math.max(0, gxMin));
        gxMax = Math.min(VIEW_MAX_X, Math.min(GRID_MAX_X, gxMax));

        for (let gx = gxMin; gx <= gxMax; gx++) {
          const world = gridToWorld(gx, gy);
          const center = world;

          const isSelected =
            selectedCell && selectedCell.x === gx && selectedCell.y === gy;

          const desertIn = pointInPolygon(center, desertPolygonWorld);
          const desertDist = distanceToPolygonEdges(center, desertPolygonWorld);
          const inDesert = desertIn || desertDist <= EDGE_THICKNESS_WORLD;

          const blkIn = pointInPolygon(center, blockedPolygonWorld);
          const blkDist = distanceToPolygonEdges(center, blockedPolygonWorld);
          const inBlockedPolygon = blkIn || blkDist <= EDGE_THICKNESS_WORLD;

          let inExtraBlocked = false;
          for (let i = 0; i < extraBlockedCells.length; i++) {
            const c = extraBlockedCells[i];
            if (gx === c.x && gy === c.y) { inExtraBlocked = true; break; }
          }
          const inBlocked = inBlockedPolygon || inExtraBlocked;

          const baseAt = findBaseAtCell(gx, gy);
          const match = baseAt ? isBaseMatchFilter(baseAt) : false;

          let stroke, fill, lw;
          if (isSelected) {
            stroke = "rgba(255,221,85,0.7)";
            fill   = "rgba(255,221,85,0.15)";
            lw = 1.6;
          } else if (inBlocked) {
            stroke = "rgba(255,80,80,0.7)";
            fill   = "rgba(255,80,80,0.22)";
            lw = 1.2;
          } else if (baseAt) {
            const baseColor = getBaseColor(baseAt);
            let alphaFill = 0.25;
            if (baseAt.status === "参加") alphaFill = 0.34;
            else if (baseAt.status === "不参加") alphaFill = 0.22;

            if (match) {
              stroke = hexToRgba(baseColor, 0.95);
              fill   = hexToRgba(baseColor, alphaFill);
            } else {
              stroke = hexToRgba(baseColor, 0.3);
              fill   = hexToRgba(baseColor, alphaFill * 0.15);
            }
            lw = match ? 1.5 : 1.0;
          } else {
            stroke = inDesert
              ? "rgba(235,220,150,0.12)"
              : "rgba(210,255,210,0.10)";
            fill = null;
            lw = 0.7;
          }

          drawHexCenter(world.x, world.y, stroke, fill, lw);
        }
      }
    }

    function drawDesertOutline() {
      ctx.beginPath();
      desertPolygonWorld.forEach(function(p, i) {
        const s = worldToScreen(p.x, p.y);
        if (i === 0) ctx.moveTo(s.x, s.y);
        else ctx.lineTo(s.x, s.y);
      });
      ctx.closePath();
      ctx.strokeStyle = "rgba(230,210,120,0.8)";
      ctx.lineWidth = 1.2;
      ctx.stroke();
    }

    function drawBlockedOutline() {
      ctx.beginPath();
      blockedPolygonWorld.forEach(function(p, i) {
        const s = worldToScreen(p.x, p.y);
        if (i === 0) ctx.moveTo(s.x, s.y);
        else ctx.lineTo(s.x, s.y);
      });
      ctx.closePath();
      ctx.strokeStyle = "rgba(255,80,80,0.75)";
      ctx.lineWidth = 1.2;
      ctx.stroke();
    }

    function drawRegionLabels() {
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.textAlign = "center";

      let cx = 0;
      let cy = 0;
      desertVerticesGrid.forEach(function(v) { cx += v.x; cy += v.y; });
      cx /= desertVerticesGrid.length;
      cy /= desertVerticesGrid.length;
      const desertW = gridToWorld(cx, cy);
      const desertS = worldToScreen(desertW.x, desertW.y);

      let fontSize = Math.max(12, Math.min(24, 15 * scale * 2.5));
      ctx.font = fontSize + "px system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif";
      ctx.textBaseline = "middle";
      ctx.fillText("砂漠エリア", desertS.x, desertS.y);

      const grassW = gridToWorld(500, 550);
      const grassS = worldToScreen(grassW.x, grassW.y);
      ctx.fillStyle = "rgba(200,255,200,0.85)";
      ctx.fillText("芝生エリア", grassS.x, grassS.y);

      const fixedLabels = [
        { x: 500, y: 500, text: "配置不可エリア" },
        { x: 517, y: 500, text: "砲台3号" },
        { x: 491, y: 483, text: "砲台2号" },
        { x: 491, y: 517, text: "砲台1号" }
      ];

      fontSize = Math.max(10, Math.min(20, 13 * scale * 2));
      ctx.font = fontSize + "px system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif";
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.textBaseline = "top";

      fixedLabels.forEach(function(obj) {
        const w = gridToWorld(obj.x, obj.y);
        const s = worldToScreen(w.x, w.y);
        const offset = HEX_SIZE * scale * 1.3;
        ctx.fillText(obj.text, s.x, s.y + offset);
      });

      ctx.restore();
    }

    function drawBaseLabels() {
      if (!showBasePopups) return;
      ctx.save();

      bases.forEach(function(b) {
        const anchor = b.anchor || b.cells[0];
        const world = gridToWorld(anchor.x, anchor.y);
        const screen = worldToScreen(world.x, world.y);
        const match = isBaseMatchFilter(b);

        const alliance = allianceMap[b.allianceKey] || ALLIANCES[0];
        const nameText = b.name;
        const statusText = b.status || "不明";
        const levelText = b.level != null ? "Lv." + b.level : "Lv.-";
        const tierText = b.tier || "T1";
        const statusLine = statusText + " " + tierText + " " + levelText;
        const coordText = "X" + anchor.x + " Y" + anchor.y;

        const baseFontSize = Math.max(6, Math.min(12, 10 * scale * 2.0));
        const lineHeight = baseFontSize * 1.05;

        ctx.font = baseFontSize + "px system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif";

        const nameWidth = ctx.measureText(nameText).width;
        const statusWidth = ctx.measureText(statusLine).width;
        const coordWidth = ctx.measureText(coordText).width;
        const textWidth = Math.max(nameWidth, statusWidth, coordWidth);

        const iconSize = lineHeight * 1.8;
        const paddingX = 4 * scale * 1.5;
        const paddingY = 3 * scale * 1.5;

        const panelWidth = Math.max(textWidth, iconSize) + paddingX * 2;
        const panelHeight = paddingY * 2 + iconSize + 4 + lineHeight * 3;
        const offsetAboveHex = HEX_SIZE * scale * 1.6;

        const panelX = screen.x - panelWidth / 2;
        const panelY = screen.y - offsetAboveHex - panelHeight;

        ctx.globalAlpha = match ? 0.9 : 0.3;
        ctx.fillStyle = "rgba(0,0,0,0.75)";
        drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 6);
        ctx.fill();
        ctx.globalAlpha = match ? 1.0 : 0.5;
        ctx.strokeStyle = "rgba(255,255,255,0.12)";
        ctx.lineWidth = 1;
        drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 6);
        ctx.stroke();

        const baseColor = getBaseColor(b);

        ctx.textAlign = "center";
        ctx.textBaseline = "top";

        let cursorY = panelY + paddingY;

        const iconX = screen.x - iconSize / 2;
        const iconY = cursorY;
        ctx.fillStyle = baseColor;
        drawRoundedRect(ctx, iconX, iconY, iconSize, iconSize, 4);
        ctx.fill();

        ctx.fillStyle = "#001010";
        if (b.side === "ENEMY") ctx.fillStyle = "#330000";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = baseFontSize + "px system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif";
        ctx.fillText(alliance.name, screen.x, iconY + iconSize / 2);

        cursorY += iconSize + 4;

        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.font = baseFontSize + "px system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif";

        ctx.fillStyle = "rgba(255,255,255,0.96)";
        ctx.fillText(nameText, screen.x, cursorY);
        cursorY += lineHeight;

        ctx.fillStyle =
          statusText === "参加" ? "rgba(150,255,190,0.96)" :
          statusText === "不参加" ? "rgba(255,170,170,0.96)" :
          "rgba(255,230,170,0.96)";
        ctx.fillText(statusLine, screen.x, cursorY);
        cursorY += lineHeight;

        ctx.fillStyle = "rgba(210,230,255,0.96)";
        ctx.fillText(coordText, screen.x, cursorY);
      });

      ctx.restore();
    }

    function drawMemoLabels() {
      if (!showMemoPopups) return;
      ctx.save();

      bases.forEach(function(b) {
        if (!b.memo) return;
        const anchor = b.anchor || b.cells[0];
        const world = gridToWorld(anchor.x, anchor.y);
        const screen = worldToScreen(world.x, world.y);
        const match = isBaseMatchFilter(b);

        const memoText = b.memo;
        const fontSize = Math.max(10, Math.min(18, 14 * scale * 2.0));
        ctx.font = fontSize + "px system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif";

        const textWidth = ctx.measureText(memoText).width;
        const paddingX = 6 * scale * 1.5;
        const paddingY = 4 * scale * 1.5;

        const panelWidth = textWidth + paddingX * 2;
        const panelHeight = fontSize + paddingY * 2;

        const offsetBelow = HEX_SIZE * scale * 1.6;
        const panelX = screen.x - panelWidth / 2;
        const panelY = screen.y + offsetBelow;

        ctx.globalAlpha = match ? 0.95 : 0.4;
        ctx.fillStyle = "rgba(20,20,20,0.9)";
        drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 6);
        ctx.fill();
        ctx.globalAlpha = match ? 1.0 : 0.5;
        ctx.strokeStyle = "rgba(255,255,255,0.25)";
        ctx.lineWidth = 1;
        drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 6);
        ctx.stroke();

        ctx.fillStyle = "rgba(255,255,255,0.98)";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(memoText, screen.x, panelY + panelHeight / 2);
      });

      ctx.restore();
    }

    function draw() {
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0, 0, rect.width, rect.height);

      drawGrid();
      drawDesertOutline();
      drawBlockedOutline();
      drawRegionLabels();
      drawBaseLabels();
      drawMemoLabels();

      zoomDisplay.textContent = Math.round(scale * 100) + "%";
      cellDisplay.textContent = selectedCell
        ? "X" + selectedCell.x + " Y" + selectedCell.y
        : "—";
    }

    function handleCellDoubleAction(cell) {
      const base = findBaseAtCell(cell.x, cell.y);
      if (base) {
        selectedBaseId = base.id;
        openBaseDialogForEdit(base);
      } else {
        openBaseDialogForCreate(cell);
      }
    }

    function zoomAt(mx, my, zoomDelta) {
      let newScale = scale + zoomDelta * scale;
      newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
      if (newScale === scale) return;
      const worldBefore = screenToWorld(mx, my);
      scale = newScale;
      const worldAfter = screenToWorld(mx, my);
      offsetX += (worldAfter.x - worldBefore.x) * scale;
      offsetY += (worldAfter.y - worldBefore.y) * scale;
      draw();
    }

    // 六角距離（自動配置の中心からの距離）
    function hexDistance(cellA, cellB) {
      const a = oddrToAxial(cellA.x, cellA.y);
      const b = oddrToAxial(cellB.x, cellB.y);
      const dq = a.q - b.q;
      const dr = a.r - b.r;
      const ds = -dq - dr;
      return Math.max(Math.abs(dq), Math.abs(dr), Math.abs(ds));
    }

    // イベント類
    canvas.addEventListener("mousedown", function(e) {
      if (e.button !== 0) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;

      const base = findBaseAtCell(cell.x, cell.y);
      if (base) {
        draggingBaseId = base.id;
        lastDragCell = cell;
      } else {
        isPanning = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      }
      canvas.classList.add("dragging");
      draw();
    });

    window.addEventListener("mousemove", function(e) {
      if (draggingBaseId) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const cell = screenToGrid(mx, my);
        if (!lastDragCell || cell.x !== lastDragCell.x || cell.y !== lastDragCell.y) {
          moveBaseToGrid(draggingBaseId, cell.x, cell.y);
          lastDragCell = cell;
        }
        return;
      }
      if (!isPanning) return;
      const dx = e.clientX - lastMouseX;
      const dy = e.clientY - lastMouseY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      offsetX += dx;
      offsetY += dy;
      draw();
    });

    window.addEventListener("mouseup", function() {
      isPanning = false;
      draggingBaseId = null;
      lastDragCell = null;
      canvas.classList.remove("dragging");
    });

    canvas.addEventListener("wheel", function(e) {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      zoomAt(mx, my, delta);
    }, { passive: false });

    canvas.addEventListener("click", function(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;
      draw();
    });

    canvas.addEventListener("dblclick", function(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;
      handleCellDoubleAction(cell);
    });

    // スマホ：ズームボタンでのダブルタップ拡大を抑制（touchstartで処理）
    zoomInBtn.addEventListener("touchstart", function(e) {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      zoomAt(rect.width / 2, rect.height / 2, 0.2);
    }, { passive: false });
    zoomOutBtn.addEventListener("touchstart", function(e) {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      zoomAt(rect.width / 2, rect.height / 2, -0.2);
    }, { passive: false });

    // PCは普通にclick
    zoomInBtn.addEventListener("click", function(e) {
      const rect = canvas.getBoundingClientRect();
      zoomAt(rect.width / 2, rect.height / 2, 0.2);
    });
    zoomOutBtn.addEventListener("click", function(e) {
      const rect = canvas.getBoundingClientRect();
      zoomAt(rect.width / 2, rect.height / 2, -0.2);
    });

    canvas.addEventListener("touchstart", function(e) {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mx = t.clientX - rect.left;
      const my = t.clientY - rect.top;

      touchStartX = t.clientX;
      touchStartY = t.clientY;

      const cell = screenToGrid(mx, my);
      selectedCell = cell;

      const base = findBaseAtCell(cell.x, cell.y);
      if (base) {
        draggingBaseId = base.id;
        lastDragCell = cell;
      } else {
        isPanning = true;
        lastMouseX = t.clientX;
        lastMouseY = t.clientY;
      }
      canvas.classList.add("dragging");
      draw();
    }, { passive: true });

    canvas.addEventListener("touchmove", function(e) {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];

      if (draggingBaseId) {
        const rect = canvas.getBoundingClientRect();
        const mx = t.clientX - rect.left;
        const my = t.clientY - rect.top;
        const cell = screenToGrid(mx, my);
        if (!lastDragCell || cell.x !== lastDragCell.x || cell.y !== lastDragCell.y) {
          moveBaseToGrid(draggingBaseId, cell.x, cell.y);
          lastDragCell = cell;
        }
        return;
      }

      if (!isPanning) return;
      const dx = t.clientX - lastMouseX;
      const dy = t.clientY - lastMouseY;
      lastMouseX = t.clientX;
      lastMouseY = t.clientY;
      offsetX += dx;
      offsetY += dy;
      draw();
    }, { passive: true });

    window.addEventListener("touchend", function(e) {
      const now = Date.now();
      const rect = canvas.getBoundingClientRect();

      if (e.changedTouches && e.changedTouches.length === 1) {
        const t = e.changedTouches[0];
        const moveDist = Math.hypot(t.clientX - touchStartX, t.clientY - touchStartY);
        if (moveDist < TAP_MAX_MOVE) {
          const mx = t.clientX - rect.left;
          const my = t.clientY - rect.top;
          const cell = screenToGrid(mx, my);

          if (
            lastTapCell &&
            now - lastTapTime < TAP_MAX_DELAY &&
            lastTapCell.x === cell.x &&
            lastTapCell.y === cell.y
          ) {
            // ダブルタップ → 基地追加/編集（ページ拡大にはさせない）
            handleCellDoubleAction(cell);
            lastTapTime = 0;
            lastTapCell = null;
          } else {
            lastTapTime = now;
            lastTapCell = cell;
          }
        }
      }

      isPanning = false;
      draggingBaseId = null;
      lastDragCell = null;
      canvas.classList.remove("dragging");
    });

    toggleSidebarBtn.addEventListener("click", function(e) {
      e.stopPropagation();
      if (window.innerWidth > 768) {
        // PC: サイドバー全体を折りたたみ
        sidebarEl.classList.toggle("collapsed");
        toggleSidebarBtn.textContent = sidebarEl.classList.contains("collapsed") ? "＋" : "－";
      } else {
        // スマホ: リスト・合計・説明を表示/非表示
        sidebarEl.classList.toggle("info-hidden");
        toggleSidebarBtn.textContent = sidebarEl.classList.contains("info-hidden") ? "＋" : "－";
      }
    });

    copyBtn.addEventListener("click", async function() {
      const list = getFilteredBases();
      if (list.length === 0) {
        alert("コピーする基地がありません。");
        return;
      }
      const lines = list.map(function(b) {
        const alliance = allianceMap[b.allianceKey] || ALLIANCES[0];
        return alliance.name + "\t" + b.name + "\tX" + b.anchor.x + " Y" + b.anchor.y;
      });
      const text = lines.join("\n");
      try {
        await navigator.clipboard.writeText(text);
        alert("同盟・基地名・座標をコピーしました。");
      } catch (e) {
        console.warn(e);
        alert("クリップボードへのコピーに失敗しました。");
      }
    });

    clearBtn.addEventListener("click", function() {
      if (!bases.length) {
        alert("削除する基地がありません。");
        return;
      }
      if (!confirm("全ての基地を一括削除しますか？")) return;
      bases.length = 0;
      saveBases();
      updateBaseListUI();
      updateTotals();
      draw();
    });

    function moveBaseToGrid(baseId, gx, gy) {
      const base = bases.find(b => b.id === baseId);
      if (!base) return;
      const cells = createBaseCellsForAnchor(gx, gy, baseId);
      if (!cells) return;
      base.cells = cells;
      base.anchor = { x: gx, y: gy };
      saveBases();
      updateBaseListUI();
      updateTotals();
      draw();
    }

    // 自動配置（フォーカス中セルの周辺を優先・同盟メンバーを上から順番に使用）
    autoBtn.addEventListener("click", function() {
      if (!ALLIANCES.length) return;
      const keyInput = prompt(
        "自動配置する同盟キーを入力してください。\n例: B777 / EclA / ALLY / ENEMY",
        "B777"
      );
      if (!keyInput) return;
      const allianceKey = String(keyInput).trim();
      const alliance = allianceMap[allianceKey];
      if (!alliance) {
        alert("その同盟キーは存在しません。");
        return;
      }
      const countStr = prompt("何個自動配置しますか？（最大50 推奨）", "10");
      if (!countStr) return;
      let count = parseInt(countStr, 10);
      if (isNaN(count) || count <= 0) return;
      if (count > 50) count = 50;

      const teamChoice = prompt("チームを指定してください。（首都 / 砲台 / 援護 / 空欄でなし）", "援護") || "";
      const normTeam =
        teamChoice === "首都" || teamChoice === "砲台" || teamChoice === "援護"
          ? teamChoice
          : "";

      // この同盟で既に使われている名前を除外し、members の上から順に使用
      const usedNames = new Set(
        bases.filter(b => b.allianceKey === alliance.key).map(b => b.name)
      );
      const freeNames = alliance.members.filter(n => !usedNames.has(n));
      if (!freeNames.length) {
        alert("この同盟で新しく配置できる名前がありません。");
        return;
      }

      // フォーカス基準セル（selectedCell があればそれ、無ければ首都）
      const centerCell = selectedCell
        ? { x: selectedCell.x, y: selectedCell.y }
        : { x: CAPITAL_CENTER_X, y: CAPITAL_CENTER_Y };

      // 中心からの六角距離順に候補アンカーを作成
      const candidates = [];
      const MAX_RADIUS = 30; // 自動配置の探索半径
      for (let gy = VIEW_MIN_Y; gy <= VIEW_MAX_Y; gy++) {
        for (let gx = VIEW_MIN_X; gx <= VIEW_MAX_X; gx++) {
          const d = hexDistance({ x: gx, y: gy }, centerCell);
          if (d <= MAX_RADIUS) {
            candidates.push({ x: gx, y: gy, d });
          }
        }
      }
      candidates.sort((a, b) => {
        if (a.d !== b.d) return a.d - b.d;
        if (a.y !== b.y) return a.y - b.y;
        return a.x - b.x;
      });

      let placed = 0;
      let nameIndex = 0;

      outer:
      for (let i = 0; i < candidates.length && placed < count && nameIndex < freeNames.length; i++) {
        const cell = candidates[i];
        const cells = createBaseCellsForAnchor(cell.x, cell.y, null);
        if (!cells) continue;

        const name = freeNames[nameIndex++];
        const id = Date.now().toString(36) + Math.random().toString(36).slice(2,7);
        bases.push({
          id: id,
          side: alliance.side,
          allianceKey: alliance.key,
          name: name,
          team: normTeam,
          status: "参加",
          level: 27,
          tier: "T9",
          memo: "",
          cells: cells,
          anchor: { x: cell.x, y: cell.y }
        });
        placed++;
      }

      if (!placed) {
        alert("自動配置できる空きスペースがありませんでした。");
      } else {
        saveBases();
        updateBaseListUI();
        updateTotals();
        draw();
      }
    });

    // 高DPI対応＆初期化
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

if (!resizeCanvas.initialized) {
  resizeCanvas.initialized = true;

  const midWorld = gridToWorld(CAPITAL_CENTER_X, CAPITAL_CENTER_Y);
  offsetX = rect.width / 2 - midWorld.x * scale;
  offsetY = rect.height / 2 - midWorld.y * scale;

  desertPolygonWorld = desertVerticesGrid.map(v => gridToWorld(v.x, v.y));
  blockedPolygonWorld = blockedVerticesGrid.map(v => gridToWorld(v.x, v.y));

  initDialogSelectors();
  loadBases();
  updateBaseListUI();
  updateTotals();

  if (window.innerWidth <= 768) {
    // ★ スマホ：最初は「説明＆合計を非表示」にしてリストを広く使う
    sidebarEl.classList.add("info-hidden");
    sidebarEl.classList.remove("collapsed");
    toggleSidebarBtn.textContent = "＋";
  } else {
    // ★ PC：従来どおり、最初はフル表示
    sidebarEl.classList.remove("info-hidden");
    sidebarEl.classList.remove("collapsed");
    toggleSidebarBtn.textContent = "－";
  }
}

      draw();
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
  </script>
</body>
</html>
