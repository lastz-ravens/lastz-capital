<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>284 Capital</title>

  <!-- ▼ favicon（PNG） -->
  <link rel="icon" type="image/png" href="favicon.png">

  <!-- ▼ iPhone / iPad ホーム画面追加用（PNG推奨：180×180） -->
  <link rel="apple-touch-icon" href="apple-touch-icon.png">

  <!-- ▼ iOS Safari 設定 -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- スマホで強制的に1倍＆ユーザー拡大禁止（ダブルタップ拡大対策） -->
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      height: 100%;
      overflow: hidden;
      background: #050608;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5f5;
      font-size: 15px;
    }
    #map-canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: radial-gradient(circle at top, #1d2838 0, #050608 50%);
      cursor: grab;
      touch-action: none; /* ダブルタップ拡大などブラウザ側ジェスチャー無効化 */
    }
    #map-canvas.dragging { cursor: grabbing; }

    .hud {
      position: fixed;
      right: 10px;
      top: 8px;
      padding: 7px 11px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .65);
      backdrop-filter: blur(10px);
      font-size: 13px;
      display: flex;
      gap: 8px;
      align-items: center;
      pointer-events: none;
      z-index: 10;
    }
    .hud span.label { opacity: .6; }
    .hud span.value { font-variant-numeric: tabular-nums; }

    /* サイドバー（基地リスト＋説明） */
    .sidebar {
      position: fixed;
      left: 10px;
      top: 10px;
      width: 320px;
      padding: 12px;
      border-radius: 16px;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(14px);
      font-size: 14px;
      z-index: 20;
      pointer-events: auto;
      max-height: calc(100% - 20px);
      display: flex;
      flex-direction: column;
    }
    .sidebar.collapsed {
      height: auto;
      max-height: none;
      padding: 8px 12px;
    }

    .sidebar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      margin-bottom: 6px;
    }
    .sidebar-title {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      opacity: 0.8;
    }
    .sidebar-actions {
      display: flex;
      gap: 4px;
      flex-shrink: 0;
      align-items: center;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .sidebar-actions button {
      border: none;
      border-radius: 999px;
      padding: 3px 7px;
      font-size: 12px;
      cursor: pointer;
      background: rgba(255,255,255,0.1);
      color: #f5f5f5;
      white-space: nowrap;
      min-width: 32px;
    }
    .sidebar-actions button:hover {
      background: rgba(255,255,255,0.2);
    }
    #toggle-sidebar {
      font-size: 14px;
      padding: 3px 9px;
      min-width: 28px;
    }

    #base-list-wrapper {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
      margin-top: 4px;
    }

    .list-toolbar {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
      font-size: 12px;
    }
    .list-toolbar span {
      opacity: 0.8;
    }
    .list-toolbar select {
      font-size: 12px;
      padding: 2px 4px;
    }

    #base-list {
      list-style: none;
      margin: 0;
      padding: 0;
      overflow-y: auto;
      flex: 1;
    }

    .stats {
      margin-top: 4px;
      font-size: 11px;
      opacity: 0.85;
      line-height: 1.4;
    }

    .sidebar-note {
      margin-top: 6px;
      font-size: 11px;
      opacity: 0.7;
      border-top: 1px solid rgba(255,255,255,0.08);
      padding-top: 4px;
    }
    .note-pc { display: block; }
    .note-sp { display: none; margin-top: 2px; }

    #base-list li.base-item {
      display: flex;
      gap: 7px;
      padding: 7px 8px;
      border-radius: 10px;
      background: rgba(255,255,255,0.04);
      margin-bottom: 4px;
      border: 1px solid transparent;
      align-items: center;
      cursor: pointer;
    }
    #base-list li.base-item:hover {
      background: rgba(255,255,255,0.08);
    }

    .base-color-dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      flex-shrink: 0;
      border: 1px solid rgba(0,0,0,0.5);
    }

    .base-item-info {
      flex: 1;
      min-width: 0;
    }
    .base-item-name-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 4px;
    }
    .base-name {
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .base-alliance {
      font-size: 13px;
      opacity: 0.8;
      white-space: nowrap;
    }
    .base-item-meta-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 2px;
      gap: 4px;
      font-size: 13px;
    }
    .base-coord {
      opacity: 0.8;
      white-space: nowrap;
    }
    .base-tagline {
      opacity: 0.85;
      white-space: nowrap;
    }

    .sidebar.collapsed #base-list-wrapper,
    .sidebar.collapsed .sidebar-note {
      display: none;
    }

    /* ズームボタン */
    .zoom-buttons {
      position: fixed;
      right: 10px;
      bottom: 80px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 10;
    }
    .zoom-buttons button {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      border: none;
      background: rgba(0,0,0,0.75);
      color: #fff;
      font-size: 22px;
      cursor: pointer;
    }

    /* select の文字色が背景と被らないように */
    select, option {
      color: #000;
      background: #fff;
    }

    @media (max-width: 768px) {
      .hud {
        right: 8px;
        top: 8px;
        font-size: 12px;
      }
      .zoom-buttons {
        right: 8px;
        bottom: 50%;              /* リストと被らないように中段に移動 */
        transform: translateY(50%);
      }
      .zoom-buttons button {
        width: 44px;
        height: 44px;
        font-size: 24px;
      }
      .sidebar {
        width: 100%;
        left: 0;
        right: 0;
        top: auto;
        bottom: 0;
        border-radius: 16px 16px 0 0;
        max-height: 45%;
        font-size: 14px;
      }
      .sidebar-title {
        font-size: 13px;
      }
      .sidebar-actions button {
        font-size: 12px;
        padding: 4px 7px;
      }
      #base-list li.base-item {
        padding: 8px 9px;
      }
      .note-pc { display: none; }
      .note-sp { display: block; }
    }
  </style>
</head>
<body>
  <canvas id="map-canvas"></canvas>

  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title">284 Capital - 基地一覧</div>
      <div class="sidebar-actions">
        <button id="copy-btn">Copy</button>
        <button id="export-btn">Exp</button>
        <button id="import-btn">Imp</button>
        <button id="toggle-popups-label-btn">Pop</button>
        <button id="toggle-memo-pop-btn">Memo</button>
        <button id="toggle-sidebar">－</button>
        <input type="file" id="import-file" accept="application/json" style="display:none" />
      </div>
    </div>

    <div id="base-list-wrapper">
      <div class="list-toolbar">
        <span>Sort:</span>
        <select id="sort-select">
          <option value="alliance">同盟</option>
          <option value="name">名前</option>
          <option value="level">Lv.</option>
          <option value="tier">T</option>
        </select>
      </div>
      <ul id="base-list"></ul>
      <div class="stats">
        <div>基地数: <span id="stat-base-count">0</span></div>
        <div>Lv合計: <span id="stat-lv"></span></div>
        <div>T合計: <span id="stat-tier"></span></div>
      </div>
    </div>

    <div class="sidebar-note">
      <div class="note-pc">
        【PC】空きマス：ダブルクリックで基地追加 / 基地マス：ダブルクリックで編集・削除 / 左ドラッグで移動 / ホイールや＋－ボタンでズーム<br>
        ・Copy: 同盟名・基地名・座標をクリップボードへ<br>
        ・Exp/Imp: JSONファイルでエクスポート／インポート<br>
        ・Pop: マップ上の基地ポップON/OFF / Memo: メモだけのポップON/OFF
      </div>
      <div class="note-sp">
        【スマホ】空きマス：同じマスを素早く2回タップで基地追加 / 基地マス：2回タップで編集・削除 / 1本指ドラッグで移動 / ピンチまたは＋－ボタンでズーム<br>
        ・Copy: 同盟名・基地名・座標をコピー<br>
        ・Exp/Imp: JSONファイルで保存／読み込み<br>
        ・Pop: マップ上の基地ポップON/OFF / Memo: メモだけポップON/OFF
      </div>
    </div>
  </div>

  <div class="zoom-buttons">
    <button id="zoom-in">＋</button>
    <button id="zoom-out">－</button>
  </div>

  <div class="hud">
    <span class="label">Zoom</span>
    <span class="value" id="zoom-display">100%</span>
    <span class="label">Cell</span>
    <span class="value" id="cell-display">—</span>
  </div>

  <!-- 基地追加・編集ダイアログ -->
  <div id="base-dialog"
       style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:30; background:rgba(0,0,0,0.6);">
    <div style="background:#101317; padding:14px 16px; border-radius:12px; width:320px; max-width:90%; font-size:14px;">
      <div style="font-size:15px; font-weight:600; margin-bottom:8px;">基地の追加 / 編集</div>
      <div style="display:flex; flex-direction:column; gap:8px;">
        <label>
          <span>所属同盟</span><br/>
          <select id="dlg-alliance" style="width:100%; margin-top:2px; font-size:14px;"></select>
        </label>
        <label>
          <span>基地名</span><br/>
          <select id="dlg-name" style="width:100%; margin-top:2px; font-size:14px;"></select>
        </label>
        <label>
          <span>参加状態</span><br/>
          <select id="dlg-status" style="width:100%; margin-top:2px; font-size:14px;">
            <option value="参加">参加</option>
            <option value="不参加">不参加</option>
            <option value="不明" selected>不明</option>
          </select>
        </label>
        <label>
          <span>レベル</span><br/>
          <select id="dlg-level" style="width:100%; margin-top:2px; font-size:14px;"></select>
        </label>
        <label>
          <span>Tランク</span><br/>
          <select id="dlg-tier" style="width:100%; margin-top:2px; font-size:14px;"></select>
        </label>
        <label>
          <span>メモ</span><br/>
          <textarea id="dlg-memo"
                    style="width:100%; margin-top:2px; font-size:14px; min-height:40px; resize:vertical;"></textarea>
        </label>
        <div style="font-size:12px; opacity:0.7;" id="dlg-coord-text"></div>
      </div>
      <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:12px;">
        <button id="dlg-cancel"
                style="border:none; border-radius:999px; padding:5px 12px; font-size:14px; background:#444; color:#f5f5f5;">
          キャンセル
        </button>
        <button id="dlg-delete"
                style="border:none; border-radius:999px; padding:5px 12px; font-size:14px; background:#aa3333; color:#fff; display:none;">
          削除
        </button>
        <button id="dlg-ok"
                style="border:none; border-radius:999px; padding:5px 12px; font-size:14px; background:#2c7be5; color:#fff;">
          決定
        </button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("map-canvas");
    const ctx = canvas.getContext("2d");
    const zoomDisplay = document.getElementById("zoom-display");
    const cellDisplay = document.getElementById("cell-display");
    const baseListEl = document.getElementById("base-list");
    const sidebarEl = document.getElementById("sidebar");
    const copyBtn = document.getElementById("copy-btn");
    const toggleSidebarBtn = document.getElementById("toggle-sidebar");
    const zoomInBtn = document.getElementById("zoom-in");
    const zoomOutBtn = document.getElementById("zoom-out");
    const sortSelect = document.getElementById("sort-select");
    const statBaseCountEl = document.getElementById("stat-base-count");
    const statLvEl = document.getElementById("stat-lv");
    const statTierEl = document.getElementById("stat-tier");

    const exportBtn = document.getElementById("export-btn");
    const importBtn = document.getElementById("import-btn");
    const importFileInput = document.getElementById("import-file");

    const togglePopupsLabelBtn = document.getElementById("toggle-popups-label-btn");
    const toggleMemoPopBtn = document.getElementById("toggle-memo-pop-btn");

    const baseDialog = document.getElementById("base-dialog");
    const dlgAlliance = document.getElementById("dlg-alliance");
    const dlgName = document.getElementById("dlg-name");
    const dlgStatus = document.getElementById("dlg-status");
    const dlgLevel = document.getElementById("dlg-level");
    const dlgTier = document.getElementById("dlg-tier");
    const dlgMemo = document.getElementById("dlg-memo");
    const dlgCoordText = document.getElementById("dlg-coord-text");
    const dlgCancel = document.getElementById("dlg-cancel");
    const dlgOk = document.getElementById("dlg-ok");
    const dlgDelete = document.getElementById("dlg-delete");

    const HEX_SIZE = 20;
    const GRID_MAX_X = 999;
    const GRID_MAX_Y = 999;
    const HEX_HEIGHT = 2 * HEX_SIZE;
    const HEX_WIDTH  = Math.sqrt(3) * HEX_SIZE;
    const HEX_VERT_SPACING  = 1.5 * HEX_SIZE;
    const HEX_HORIZ_SPACING = HEX_WIDTH;
    const EDGE_THICKNESS_WORLD = HEX_SIZE * 0.8;
    const STORAGE_KEY = "hexmap_bases_v8";

    let scale = 0.35;
    let offsetX = 0;
    let offsetY = 0;
    const MIN_SCALE = 0.08;
    const MAX_SCALE = 3.0;

    let isPanning = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let selectedCell = null;

    let touchStartX = 0;
    let touchStartY = 0;
    let lastTapTime = 0;
    let lastTapCell = null;
    const TAP_MAX_DELAY = 320;
    const TAP_MAX_MOVE  = 12;

    let draggingBaseId = null;
    let lastDragCell = null;

    const bases = [];
    let baseCount = 0;

    let currentSort = "alliance";
    let showBasePopups = true;
    let showMemoPopups = true;

    const CAPITAL_CENTER_X = 500;
    const CAPITAL_CENTER_Y = 500;
    const VIEW_RADIUS = 50;
    const VIEW_MIN_X = Math.max(0, CAPITAL_CENTER_X - VIEW_RADIUS);
    const VIEW_MAX_X = Math.min(GRID_MAX_X, CAPITAL_CENTER_X + VIEW_RADIUS);
    const VIEW_MIN_Y = Math.max(0, CAPITAL_CENTER_Y - VIEW_RADIUS);
    const VIEW_MAX_Y = Math.min(GRID_MAX_Y, CAPITAL_CENTER_Y + VIEW_RADIUS);

    // 不特定多数用：敵・味方 1000人
    const ENEMY_MEMBERS = Array.from({ length: 1000 }, (_, i) =>
      `敵${String(i + 1).padStart(3, "0")}`
    );
    const ALLY_MEMBERS = Array.from({ length: 1000 }, (_, i) =>
      `味方${String(i + 1).padStart(3, "0")}`
    );

    const ALLIANCES = [
      {
        key: "B777",
        name: "B777",
        color: "#ffcc00",
        textColor: "#201500",
        members: [
          "SuperZeus","Ram","ponsu","すぎっしー","NEXUS21","neku-ra","Crazy楊Frog",
          "GENLuckyTrigger","マナ","Ramen-X","やちこ","ヨホホホホ","Lamawa","Carna the God","jun33",
          "オーシマン","るんず","WDギャン","Hans 23","アカサ","えび","ステカセ王","ケイー","Yanoyano",
          "赤ヘル","タカちゃん","RUKA0806","ポル","yanchaaan","zerozerozero","アルアル","M731","Vikara",
          "RUSK222","JoJo11","フランメ","Happyぼっち","keioka","みにこり","キャノン","靈魂拷問者","迷子",
          "simon-nu","まむし","OneTop","しまんちゅ","Vivihana","PIPECUT","ロッシー","Ra-Men-Man","yusukerion",
          "onaka","xJISOOx","れみす","ヴォーグ","mr344","浮亂苦","Nescop","irohoma","くまみーん","亞丘?斯",
          "岡ティー","アイアイ","サムエル","もえご","QQ27","elchaaaan","Coffee jelly","ぺけたん","SEELE",
          "mamimumemo","あこまき","ジャン","1m2","ユウディ","ウニいくら","いろはす","Tnation","バイソン",
          "たけむー","CraZyLiOn","アジング","lupiX","nyu-ha-to","＊MISERY＊","もーー","Sakura0207","ピザコーラ",
          "ronrico","余韻","GSX1300R"
        ]
      },
      {
        key: "EclA",
        name: "EclA",
        color: "#66ccff",
        textColor: "#002233",
        members: [
          "伏黒 恵","冨岡 義勇","RENOVATIO","reaper777","Lucien Dodsa","はるちゃん","D0NKI호테",
          "ダンテ　G","Jabol86","DV 디뷔","온새결","c-137","SimpleDude","まるる","以蔵 -IZO-",
          "はだて","岳仔","バトウアン","RaineForest","Nishi7","hajime77777","Nobodymeow",
          "CORONELNEMO","조다슬남편","v끝판대장v","めいちゃん","NAT-","현대제철","Squidward jr",
          "AINS","RAVI10","Kori77","SeoulGirl","User2abcd","makonosuke","Wolfdog Walker",
          "Kiki777","nelipot","StoyanS","VIadimir Fido","Suokki","Jesterko","t imo",
          "Machang Bubok","plwro","CーPON","RastaRob","CRAZY H","SoupySuperStar","Dentrival",
          "Z‌‌","KANASAl","godjji","cubelee","DoMToDd","Craigクレグ","Aiaaahhh","fun die ?",
          "PaladinFriend","omjmj","日出打金","duberman","アビー","White Paladin",
          "•BadKitty18","MegaDragonite","にぃ","R0KAN","香ばしい","Sky18","Tiara333",
          "Taro12","masa1121","simply red","Mirellle","Diegomv","・LUZ","SurvivorREM",
          "AlexNesty","Idealize","Decade 2","Mos M Zer Lor","Jeyci","DiegoX","anhcatim",
          "Emmanuel Wick","야찰퀸","poem0320","Crimson-Sky","Noval Yoko","Lariatte",
          "Maelle SZ","조다슬남편"
        ]
      },
      {
        key: "ENEMY",
        name: "敵",
        color: "#ff6666",
        textColor: "#2a0000",
        members: ENEMY_MEMBERS
      },
      {
        key: "ALLY",
        name: "味方",
        color: "#66ff99",
        textColor: "#002011",
        members: ALLY_MEMBERS
      }
    ];

    const allianceMap = {};
    ALLIANCES.forEach(a => { allianceMap[a.key] = a; });

    const desertVerticesGrid = [
      { x: 482, y: 465 },
      { x: 465, y: 500 },
      { x: 482, y: 535 },
      { x: 517, y: 535 },
      { x: 535, y: 500 },
      { x: 517, y: 465 }
    ];
    const blockedVerticesGrid = [
      { x: 483, y: 500 },
      { x: 491, y: 517 },
      { x: 508, y: 517 },
      { x: 517, y: 500 },
      { x: 508, y: 483 },
      { x: 491, y: 483 }
    ];
    const extraBlockedCells = [
      { x: 489, y: 515 },{ x: 490, y: 516 },{ x: 490, y: 517 },{ x: 491, y: 518 },
      { x: 491, y: 585 },{ x: 492, y: 518 },{ x: 493, y: 518 },{ x: 494, y: 518 },
      { x: 489, y: 516 },{ x: 489, y: 517 },{ x: 490, y: 518 },{ x: 490, y: 519 },
      { x: 491, y: 519 },{ x: 492, y: 519 },{ x: 493, y: 519 },
      { x: 517, y: 502 },{ x: 517, y: 501 },{ x: 517, y: 502 },{ x: 518, y: 500 },
      { x: 518, y: 499 },{ x: 518, y: 498 },{ x: 517, y: 497 },{ x: 517, y: 496 },
      { x: 517, y: 499 },{ x: 517, y: 498 },{ x: 516, y: 497 },{ x: 516, y: 496 },
      { x: 489, y: 485 },{ x: 489, y: 484 },{ x: 489, y: 483 },{ x: 490, y: 482 },
      { x: 490, y: 484 },{ x: 490, y: 483 },{ x: 491, y: 482 },{ x: 491, y: 481 },
      { x: 492, y: 482 },{ x: 492, y: 481 },{ x: 493, y: 482 },{ x: 494, y: 482 },
      { x: 490, y: 481 },{ x: 493, y: 481 },{ x: 494, y: 482 }
    ];

    let desertPolygonWorld = [];
    let blockedPolygonWorld = [];

    const basePatternAxial = [
      { dq: 0, dr: 0 },
      { dq: 1, dr: 0 },
      { dq: 0, dr: 1 },
      { dq: -1, dr: 1 },
      { dq: -1, dr: 0 },
      { dq: 0, dr: -1 },
      { dq: 1, dr: -1 }
    ];

    function oddrToAxial(col, row) {
      const q = col - (row - (row & 1)) / 2;
      const r = row;
      return { q, r };
    }
    function axialToOddr(q, r) {
      const row = r;
      const col = q + (r - (r & 1)) / 2;
      return { x: col, y: row };
    }

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      canvas.style.width = rect.width + "px";
      canvas.style.height = rect.height + "px";

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      if (!resizeCanvas.initialized) {
        resizeCanvas.initialized = true;
        const midWorld = gridToWorld(CAPITAL_CENTER_X, CAPITAL_CENTER_Y);
        offsetX = rect.width / 2 - midWorld.x * scale;
        offsetY = rect.height / 2 - midWorld.y * scale;

        desertPolygonWorld = desertVerticesGrid.map(v => gridToWorld(v.x, v.y));
        blockedPolygonWorld = blockedVerticesGrid.map(v => gridToWorld(v.x, v.y));

        initDialogSelectors();
        loadBases();
        updateBaseListUI();

        if (window.innerWidth <= 768) {
          sidebarEl.classList.add("collapsed");
          toggleSidebarBtn.textContent = "＋";
        }
      }
      draw();
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function gridToWorld(gx, gy) {
      const wx = HEX_HORIZ_SPACING * (gx + (gy & 1) * 0.5);
      const wy = HEX_VERT_SPACING * gy;
      return { x: wx, y: wy };
    }
    function worldToScreen(wx, wy) {
      return { x: wx * scale + offsetX, y: wy * scale + offsetY };
    }
    function screenToWorld(sx, sy) {
      return { x: (sx - offsetX) / scale, y: (sy - offsetY) / scale };
    }
    function screenToGrid(sx, sy) {
      const w = screenToWorld(sx, sy);
      let gy = Math.round(w.y / HEX_VERT_SPACING);
      gy = Math.max(0, Math.min(GRID_MAX_Y, gy));
      const rowOffset = (gy & 1) ? HEX_HORIZ_SPACING * 0.5 : 0;
      let gx = Math.round((w.x - rowOffset) / HEX_HORIZ_SPACING);
      gx = Math.max(0, Math.min(GRID_MAX_X, gx));
      return { x: gx, y: gy };
    }

    function pointInPolygon(point, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect =
          ((yi > point.y) !== (yj > point.y)) &&
          (point.x < (xj - xi) * (point.y - yi) / (yj - yi + 1e-9) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    function pointToSegmentDistance(p, a, b) {
      const vx = b.x - a.x;
      const vy = b.y - a.y;
      const wx = p.x - a.x;
      const wy = p.y - a.y;
      const c1 = vx * wx + vy * wy;
      if (c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y);
      const c2 = vx * vx + vy * vy;
      if (c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y);
      const t = c1 / c2;
      const projx = a.x + t * vx;
      const projy = a.y + t * vy;
      return Math.hypot(p.x - projx, p.y - projy);
    }
    function distanceToPolygonEdges(p, polygon) {
      let minD = Infinity;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const d = pointToSegmentDistance(p, polygon[j], polygon[i]);
        if (d < minD) minD = d;
      }
      return minD;
    }

    function isBlockedCell(gx, gy) {
      for (const c of extraBlockedCells) {
        if (c.x === gx && c.y === gy) return true;
      }
      const w = gridToWorld(gx, gy);
      const inside = pointInPolygon(w, blockedPolygonWorld);
      const dist = distanceToPolygonEdges(w, blockedPolygonWorld);
      return inside || dist <= EDGE_THICKNESS_WORLD;
    }

    function findBaseAtCell(gx, gy) {
      return bases.find(b => b.cells.some(c => c.x === gx && c.y === gy)) || null;
    }
    function createBaseCellsForAnchor(gx, gy, ignoreBaseId = null) {
      const { q, r } = oddrToAxial(gx, gy);
      const cells = basePatternAxial.map(off => {
        const oq = q + off.dq;
        const or = r + off.dr;
        return axialToOddr(oq, or);
      });
      for (const c of cells) {
        if (c.x < 0 || c.x > GRID_MAX_X || c.y < 0 || c.y > GRID_MAX_Y) return null;
        if (isBlockedCell(c.x, c.y)) return null;
        for (const b of bases) {
          if (ignoreBaseId && b.id === ignoreBaseId) continue;
          if (b.cells.some(d => d.x === c.x && d.y === c.y)) return null;
        }
      }
      return cells;
    }
    function deleteBaseById(id) {
      const idx = bases.findIndex(b => b.id === id);
      if (idx !== -1) {
        bases.splice(idx, 1);
        saveBases();
        updateBaseListUI();
        draw();
      }
    }

    function makeSerializableData() {
      return {
        bases: bases.map(b => ({
          id: b.id,
          allianceKey: b.allianceKey,
          name: b.name,
          status: b.status,
          level: b.level,
          tier: b.tier,
          memo: b.memo || "",
          anchor: b.anchor
        }))
      };
    }
    function saveBases() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(makeSerializableData()));
      } catch (e) {
        console.warn("saveBases error:", e);
      }
    }
    function loadBases() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      try {
        const data = JSON.parse(raw);
        if (!data || !Array.isArray(data.bases)) return;
        data.bases.forEach(rec => {
          if (!rec.anchor) return;
          const cells = createBaseCellsForAnchor(rec.anchor.x, rec.anchor.y, null);
          if (!cells) return;
          bases.push({
            id: rec.id || (Date.now().toString(36) + Math.random().toString(36).slice(2,7)),
            allianceKey: rec.allianceKey || "B777",
            name: rec.name || "基地",
            status: rec.status || "不明",
            level: rec.level ?? null,
            tier: rec.tier || "T1",
            memo: rec.memo || "",
            cells,
            anchor: rec.anchor
          });
        });
        baseCount = bases.length;
      } catch (e) {
        console.warn("loadBases error:", e);
      }
    }

    function importBasesFromData(data) {
      if (!data || !Array.isArray(data.bases)) {
        alert("インポートするJSONの形式が不正です。");
        return;
      }
      if (!confirm("現在の基地データを全て置き換えますか？")) return;

      bases.length = 0;
      data.bases.forEach(rec => {
        if (!rec.anchor) return;
        const cells = createBaseCellsForAnchor(rec.anchor.x, rec.anchor.y, null);
        if (!cells) return;
        bases.push({
          id: rec.id || (Date.now().toString(36) + Math.random().toString(36).slice(2,7)),
          allianceKey: rec.allianceKey || "B777",
          name: rec.name || "基地",
          status: rec.status || "不明",
          level: rec.level ?? null,
          tier: rec.tier || "T1",
          memo: rec.memo || "",
          cells,
          anchor: rec.anchor
        });
      });
      baseCount = bases.length;
      saveBases();
      updateBaseListUI();
      draw();
    }
    function exportBasesToFile() {
      const data = makeSerializableData();
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "bases.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    function handleImportFile(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        try {
          const data = JSON.parse(ev.target.result);
          importBasesFromData(data);
        } catch (err) {
          console.error(err);
          alert("JSONの読み込みに失敗しました。");
        } finally {
          importFileInput.value = "";
        }
      };
      reader.readAsText(file, "utf-8");
    }

    exportBtn.addEventListener("click", exportBasesToFile);
    importBtn.addEventListener("click", () => importFileInput.click());
    importFileInput.addEventListener("change", handleImportFile);

    let dialogMode = "create";
    let dialogCell = null;
    let dialogEditingBase = null;

    function initDialogSelectors() {
      dlgAlliance.innerHTML = "";
      ALLIANCES.forEach(a => {
        const opt = document.createElement("option");
        opt.value = a.key;
        opt.textContent = a.name;
        dlgAlliance.appendChild(opt);
      });

      dlgLevel.innerHTML = "";
      for (let lv = 30; lv >= 1; lv--) {
        const opt = document.createElement("option");
        opt.value = String(lv);
        opt.textContent = `Lv.${lv}`;
        dlgLevel.appendChild(opt);
      }

      dlgTier.innerHTML = "";
      for (let t = 10; t >= 1; t--) {
        const opt = document.createElement("option");
        opt.value = `T${t}`;
        opt.textContent = `T${t}`;
        dlgTier.appendChild(opt);
      }
    }

    function updateNameOptionsForAlliance(allianceKey, currentName = null) {
      const alliance = allianceMap[allianceKey];
      dlgName.innerHTML = "";
      if (!alliance) return;
      const usedNames = new Set(bases.map(b => b.name));
      alliance.members.forEach(name => {
        if (dialogMode === "edit" && name === currentName) {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          dlgName.appendChild(opt);
        } else if (!usedNames.has(name)) {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          dlgName.appendChild(opt);
        }
      });
      if (dlgName.options.length === 0) {
        const opt = document.createElement("option");
        opt.value = currentName || "";
        opt.textContent = currentName || "(空き基地名なし)";
        dlgName.appendChild(opt);
      }
    }

    function openBaseDialogForCreate(cell) {
      dialogMode = "create";
      dialogCell = cell;
      dialogEditingBase = null;
      dlgDelete.style.display = "none";
      dlgStatus.value = "不明";

      const defaultAllianceKey = ALLIANCES[0]?.key || "B777";
      dlgAlliance.value = defaultAllianceKey;
      updateNameOptionsForAlliance(defaultAllianceKey, null);
      dlgLevel.value = "30";
      dlgTier.value = "T10";
      dlgMemo.value = "";

      dlgCoordText.textContent = `配置セル: X${cell.x} Y${cell.y}`;
      baseDialog.style.display = "flex";
    }

    function openBaseDialogForEdit(base) {
      dialogMode = "edit";
      dialogEditingBase = base;
      dialogCell = base.anchor;
      dlgDelete.style.display = "inline-block";

      dlgAlliance.value = base.allianceKey || "B777";
      updateNameOptionsForAlliance(base.allianceKey || "B777", base.name);
      dlgName.value = base.name;
      dlgStatus.value = base.status || "不明";
      if (base.level != null) dlgLevel.value = String(base.level);
      dlgTier.value = base.tier || "T1";
      dlgMemo.value = base.memo || "";

      dlgCoordText.textContent = `配置セル: X${base.anchor.x} Y${base.anchor.y}`;
      baseDialog.style.display = "flex";
    }

    function closeBaseDialog() {
      baseDialog.style.display = "none";
      dialogCell = null;
      dialogEditingBase = null;
    }

    dlgAlliance.addEventListener("change", () => {
      const key = dlgAlliance.value;
      const currentName = dialogEditingBase ? dialogEditingBase.name : null;
      updateNameOptionsForAlliance(key, currentName);
    });

    dlgCancel.addEventListener("click", closeBaseDialog);

    dlgDelete.addEventListener("click", () => {
      if (!dialogEditingBase) return;
      if (confirm(`基地「${dialogEditingBase.name}」を削除しますか？`)) {
        deleteBaseById(dialogEditingBase.id);
        closeBaseDialog();
      }
    });

    dlgOk.addEventListener("click", () => {
      const allianceKey = dlgAlliance.value;
      const alliance = allianceMap[allianceKey] || ALLIANCES[0];
      const name = dlgName.value || "基地";
      const status = dlgStatus.value || "不明";
      const level = Number(dlgLevel.value || "0");
      const tier = dlgTier.value || "T1";
      const memo = dlgMemo.value || "";

      if (!dialogCell) { closeBaseDialog(); return; }
      const gx = dialogCell.x;
      const gy = dialogCell.y;

      if (dialogMode === "create") {
        const cells = createBaseCellsForAnchor(gx, gy, null);
        if (!cells) {
          alert("この位置には基地を配置できません。");
          return;
        }
        const id = Date.now().toString(36) + Math.random().toString(36).slice(2, 7);
        bases.push({
          id,
          allianceKey: alliance.key,
          name,
          status,
          level: isNaN(level) ? null : level,
          tier,
          memo,
          cells,
          anchor: { x: gx, y: gy }
        });
        baseCount++;
      } else if (dialogMode === "edit" && dialogEditingBase) {
        const cells = createBaseCellsForAnchor(gx, gy, dialogEditingBase.id);
        if (!cells) {
          alert("この位置には基地を配置できません。");
          return;
        }
        dialogEditingBase.allianceKey = alliance.key;
        dialogEditingBase.name = name;
        dialogEditingBase.status = status;
        dialogEditingBase.level = isNaN(level) ? null : level;
        dialogEditingBase.tier = tier;
        dialogEditingBase.memo = memo;
        dialogEditingBase.cells = cells;
        dialogEditingBase.anchor = { x: gx, y: gy };
      }

      saveBases();
      updateBaseListUI();
      draw();
      closeBaseDialog();
    });

    sortSelect.addEventListener("change", () => {
      currentSort = sortSelect.value;
      updateBaseListUI();
    });

    function sortBasesArray(arr) {
      const sortKey = currentSort;
      return [...arr].sort((a, b) => {
        const allianceA = allianceMap[a.allianceKey]?.name || a.allianceKey;
        const allianceB = allianceMap[b.allianceKey]?.name || b.allianceKey;
        const la = a.level || 0;
        const lb = b.level || 0;
        const ta = parseInt(String(a.tier || "T1").replace("T", ""), 10) || 1;
        const tb = parseInt(String(b.tier || "T1").replace("T", ""), 10) || 1;

        switch (sortKey) {
          case "name":
            if (a.name !== b.name) return a.name.localeCompare(b.name);
            if (allianceA !== allianceB) return allianceA.localeCompare(allianceB);
            return lb - la;
          case "level":
            if (la !== lb) return lb - la; // Lv高い順
            if (ta !== tb) return tb - ta;
            return a.name.localeCompare(b.name);
          case "tier":
            if (ta !== tb) return tb - ta; // T高い順
            if (la !== lb) return lb - la;
            return a.name.localeCompare(b.name);
          case "alliance":
          default:
            if (allianceA !== allianceB) return allianceA.localeCompare(allianceB);
            if (a.name !== b.name) return a.name.localeCompare(b.name);
            return lb - la;
        }
      });
    }

    function updateStats() {
      statBaseCountEl.textContent = bases.length;

      const lvCounts = Array(31).fill(0); // index 1..30
      const tierCounts = Array(11).fill(0); // index 1..10

      bases.forEach(b => {
        if (b.level != null && b.level >= 1 && b.level <= 30) {
          lvCounts[b.level]++;
        }
        const t = parseInt(String(b.tier || "T1").replace("T", ""), 10);
        if (!isNaN(t) && t >= 1 && t <= 10) {
          tierCounts[t]++;
        }
      });

      const lvParts = [];
      for (let lv = 30; lv >= 1; lv--) {
        if (lvCounts[lv] > 0) {
          lvParts.push(`Lv.${lv}:${lvCounts[lv]}`);
        }
      }
      statLvEl.textContent = lvParts.join(" / ");

      const tParts = [];
      for (let t = 10; t >= 1; t--) {
        if (tierCounts[t] > 0) {
          tParts.push(`T${t}:${tierCounts[t]}`);
        }
      }
      statTierEl.textContent = tParts.join(" / ");
    }

    function focusOnBase(b) {
      const anchor = b.anchor || b.cells[0];
      const world = gridToWorld(anchor.x, anchor.y);
      const rect = canvas.getBoundingClientRect();
      offsetX = rect.width / 2 - world.x * scale;
      offsetY = rect.height / 2 - world.y * scale;
      selectedCell = { x: anchor.x, y: anchor.y };
      draw();
    }

    function updateBaseListUI() {
      baseListEl.innerHTML = "";
      const sorted = sortBasesArray(bases);

      sorted.forEach(b => {
        const li = document.createElement("li");
        li.className = "base-item";

        const alliance = allianceMap[b.allianceKey] || ALLIANCES[0];
        const dot = document.createElement("div");
        dot.className = "base-color-dot";
        dot.style.background = alliance.color;

        const info = document.createElement("div");
        info.className = "base-item-info";

        const nameRow = document.createElement("div");
        nameRow.className = "base-item-name-row";

        const nameSpan = document.createElement("span");
        nameSpan.className = "base-name";
        nameSpan.textContent = b.name;

        const allianceSpan = document.createElement("span");
        allianceSpan.className = "base-alliance";
        allianceSpan.textContent = alliance.name;

        nameRow.appendChild(nameSpan);
        nameRow.appendChild(allianceSpan);

        const metaRow = document.createElement("div");
        metaRow.className = "base-item-meta-row";

        const coordSpan = document.createElement("span");
        coordSpan.className = "base-coord";
        coordSpan.textContent = `X${b.anchor.x} Y${b.anchor.y}`;

        const tagSpan = document.createElement("span");
        tagSpan.className = "base-tagline";
        const lv = b.level != null ? `Lv.${b.level}` : "Lv.-";
        tagSpan.textContent = `${b.status} ${b.tier} ${lv}`;

        metaRow.appendChild(coordSpan);
        metaRow.appendChild(tagSpan);

        info.appendChild(nameRow);
        info.appendChild(metaRow);

        li.appendChild(dot);
        li.appendChild(info);

        // クリックでその基地にフォーカス移動
        li.addEventListener("click", (e) => {
          e.stopPropagation();
          focusOnBase(b);
        });

        // ダブルクリックで編集
        li.addEventListener("dblclick", (e) => {
          e.stopPropagation();
          openBaseDialogForEdit(b);
        });

        baseListEl.appendChild(li);
      });

      updateStats();
    }

    function drawHexCenter(wx, wy, strokeStyle, fillStyle, lineWidth = 1) {
      const { x: sx, y: sy } = worldToScreen(wx, wy);
      const s = HEX_SIZE * scale;
      const w = Math.sqrt(3) * s;
      const h = s;

      const pts = [
        { x: sx,        y: sy - h },
        { x: sx + w/2,  y: sy - h/2 },
        { x: sx + w/2,  y: sy + h/2 },
        { x: sx,        y: sy + h },
        { x: sx - w/2,  y: sy + h/2 },
        { x: sx - w/2,  y: sy - h/2 }
      ];

      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.closePath();

      if (fillStyle) {
        ctx.fillStyle = fillStyle;
        ctx.fill();
      }
      if (strokeStyle) {
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = lineWidth;
        ctx.stroke();
      }
    }

    function drawGrid() {
      const rect = canvas.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;
      const margin = 80 / scale;
      const topLeftWorld = screenToWorld(-margin, -margin);
      const bottomRightWorld = screenToWorld(w + margin, h + margin);

      let gyMin = Math.floor(topLeftWorld.y / HEX_VERT_SPACING) - 2;
      let gyMax = Math.ceil(bottomRightWorld.y / HEX_VERT_SPACING) + 2;
      gyMin = Math.max(0, gyMin);
      gyMax = Math.min(GRID_MAX_Y, gyMax);
      gyMin = Math.max(gyMin, VIEW_MIN_Y);
      gyMax = Math.min(gyMax, VIEW_MAX_Y);

      for (let gy = gyMin; gy <= gyMax; gy++) {
        const rowOffset = (gy & 1) ? HEX_HORIZ_SPACING * 0.5 : 0;

        let gxMin = Math.floor((topLeftWorld.x - rowOffset) / HEX_HORIZ_SPACING) - 2;
        let gxMax = Math.ceil((bottomRightWorld.x - rowOffset) / HEX_HORIZ_SPACING) + 2;
        gxMin = Math.max(0, gxMin);
        gxMax = Math.min(GRID_MAX_X, gxMax);
        gxMin = Math.max(gxMin, VIEW_MIN_X);
        gxMax = Math.min(gxMax, VIEW_MAX_X);

        for (let gx = gxMin; gx <= gxMax; gx++) {
          const { x: wx, y: wy } = gridToWorld(gx, gy);
          const center = { x: wx, y: wy };

          const isSelectedCell =
            selectedCell && selectedCell.x === gx && selectedCell.y === gy;

          const desertIn = pointInPolygon(center, desertPolygonWorld);
          const desertDist = distanceToPolygonEdges(center, desertPolygonWorld);
          const inDesert = desertIn || desertDist <= EDGE_THICKNESS_WORLD;

          const blkIn = pointInPolygon(center, blockedPolygonWorld);
          const blkDist = distanceToPolygonEdges(center, blockedPolygonWorld);
          const inBlockedPolygon = blkIn || blkDist <= EDGE_THICKNESS_WORLD;

          let inExtraBlocked = false;
          for (const c of extraBlockedCells) {
            if (gx === c.x && gy === c.y) { inExtraBlocked = true; break; }
          }
          const inBlocked = inBlockedPolygon || inExtraBlocked;
          const baseAt = findBaseAtCell(gx, gy);

          let stroke, fill, lw;
          if (isSelectedCell) {
            stroke = "rgba(255,221,85,0.7)";
            fill   = "rgba(255,221,85,0.15)";
            lw = 1.6;
          } else if (inBlocked) {
            stroke = "rgba(255,80,80,0.7)";
            fill   = "rgba(255,80,80,0.22)";
            lw = 1.2;
          } else if (baseAt) {
            const alliance = allianceMap[baseAt.allianceKey] || ALLIANCES[0];
            let alphaFill = 0.25;
            if (baseAt.status === "参加") alphaFill = 0.34;
            else if (baseAt.status === "不参加") alphaFill = 0.22;
            stroke = hexToRgba(alliance.color, 0.95);
            fill   = hexToRgba(alliance.color, alphaFill);
            lw = 1.5;
          } else {
            stroke = inDesert
              ? "rgba(235,220,150,0.12)"
              : "rgba(210,255,210,0.10)";
            fill = null;
            lw = 0.7;
          }

          drawHexCenter(wx, wy, stroke, fill, lw);
        }
      }
    }

    function drawDesertOutline() {
      ctx.beginPath();
      desertPolygonWorld.forEach((p, i) => {
        const s = worldToScreen(p.x, p.y);
        if (i === 0) ctx.moveTo(s.x, s.y);
        else ctx.lineTo(s.x, s.y);
      });
      ctx.closePath();
      ctx.strokeStyle = "rgba(230,210,120,0.8)";
      ctx.lineWidth = 1.2;
      ctx.stroke();
    }

    function drawBlockedOutline() {
      ctx.beginPath();
      blockedPolygonWorld.forEach((p, i) => {
        const s = worldToScreen(p.x, p.y);
        if (i === 0) ctx.moveTo(s.x, s.y);
        else ctx.lineTo(s.x, s.y);
      });
      ctx.closePath();
      ctx.strokeStyle = "rgba(255,80,80,0.75)";
      ctx.lineWidth = 1.2;
      ctx.stroke();
    }

    function drawRegionLabels() {
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.textAlign = "center";

      let cx = 0, cy = 0;
      desertVerticesGrid.forEach(v => { cx += v.x; cy += v.y; });
      cx /= desertVerticesGrid.length;
      cy /= desertVerticesGrid.length;
      const desertWorld = gridToWorld(cx, cy);
      const desertScreen = worldToScreen(desertWorld.x, desertWorld.y);

      let fontSize = Math.max(12, Math.min(24, 15 * scale * 2.5));
      ctx.font = `${fontSize}px system-ui,"-apple-system","BlinkMacSystemFont","Segoe UI",sans-serif`;
      ctx.textBaseline = "middle";
      ctx.fillText("砂漠エリア", desertScreen.x, desertScreen.y);

      const grassWorld = gridToWorld(500, 550);
      const grassScreen = worldToScreen(grassWorld.x, grassWorld.y);
      ctx.fillStyle = "rgba(200,255,200,0.85)";
      ctx.fillText("芝生エリア", grassScreen.x, grassScreen.y);

      const fixedLabels = [
        { x: 500, y: 500, text: "配置不可エリア" },
        { x: 517, y: 500, text: "砲台3号" },
        { x: 491, y: 483, text: "砲台2号" },
        { x: 491, y: 517, text: "砲台1号" }
      ];

      fontSize = Math.max(10, Math.min(20, 13 * scale * 2));
      ctx.font = `${fontSize}px system-ui,"-apple-system","BlinkMacSystemFont","Segoe UI",sans-serif`;
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.textBaseline = "top";

      fixedLabels.forEach(obj => {
        const w = gridToWorld(obj.x, obj.y);
        const s = worldToScreen(w.x, w.y);
        const offset = HEX_SIZE * scale * 1.3;
        ctx.fillText(obj.text, s.x, s.y + offset);
      });

      ctx.restore();
    }

    function drawRoundedRect(ctx, x, y, w, h, r) {
      const radius = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + w - radius, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
      ctx.lineTo(x + w, y + h - radius);
      ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
      ctx.lineTo(x + radius, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    function drawBaseLabels() {
      if (!showBasePopups && !showMemoPopups) return;

      ctx.save();
      bases.forEach(b => {
        const anchor = b.anchor || b.cells[0];
        const world = gridToWorld(anchor.x, anchor.y);
        const screen = worldToScreen(world.x, world.y);

        const alliance = allianceMap[b.allianceKey] || ALLIANCES[0];
        const nameText   = b.name;
        const statusText = b.status || "不明";
        const levelText  = b.level != null ? `Lv.${b.level}` : "Lv.-";
        const tierText   = b.tier || "T1";
        const statusLine = `${statusText} ${tierText} ${levelText}`;
        const coordText  = `X${anchor.x} Y${anchor.y}`;
        const memoText   = b.memo ? String(b.memo).slice(0, 60) : "";

        const baseFontSize = Math.max(6, Math.min(12, 10 * scale * 2.0));
        const lineHeight   = baseFontSize * 1.05;

        ctx.font = `${baseFontSize}px system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif`;

        const nameWidth   = ctx.measureText(nameText).width;
        const statusWidth = ctx.measureText(statusLine).width;
        const coordWidth  = ctx.measureText(coordText).width;
        const textWidth   = Math.max(nameWidth, statusWidth, coordWidth);

        const iconSize   = lineHeight * 1.8;
        const paddingX   = 4 * scale * 1.5;
        const paddingY   = 3 * scale * 1.5;
        const baseLines  = 3;
        const panelWidth = Math.max(textWidth, iconSize) + paddingX * 2;
        const panelHeight = paddingY * 2 + iconSize + 4 + lineHeight * baseLines;
        const offsetAboveHex = HEX_SIZE * scale * 1.6;

        let basePanelTopY = screen.y - offsetAboveHex - panelHeight;

        // 基地ポップ
        if (showBasePopups) {
          const panelX = screen.x - panelWidth / 2;
          const panelY = basePanelTopY;

          ctx.globalAlpha = 0.9;
          ctx.fillStyle = "rgba(0,0,0,0.75)";
          drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 6);
          ctx.fill();
          ctx.globalAlpha = 1.0;
          ctx.strokeStyle = "rgba(255,255,255,0.12)";
          ctx.lineWidth = 1;
          drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 6);
          ctx.stroke();

          ctx.textAlign = "center";
          ctx.textBaseline = "top";

          let cursorY = panelY + paddingY;

          const iconX = screen.x - iconSize / 2;
          const iconY = cursorY;
          ctx.fillStyle = alliance.color;
          drawRoundedRect(ctx, iconX, iconY, iconSize, iconSize, 4);
          ctx.fill();

          ctx.fillStyle = alliance.textColor || "#000";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `${baseFontSize}px system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif`;
          ctx.fillText(alliance.name, screen.x, iconY + iconSize / 2);

          cursorY += iconSize + 4;

          ctx.textAlign = "center";
          ctx.textBaseline = "top";
          ctx.font = `${baseFontSize}px system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif`;

          ctx.fillStyle = "rgba(255,255,255,0.96)";
          ctx.fillText(nameText, screen.x, cursorY);
          cursorY += lineHeight;

          ctx.fillStyle =
            statusText === "参加" ? "rgba(150,255,190,0.96)"
            : statusText === "不参加" ? "rgba(255,170,170,0.96)"
            : "rgba(255,230,170,0.96)";
          ctx.fillText(statusLine, screen.x, cursorY);
          cursorY += lineHeight;

          ctx.fillStyle = "rgba(210,230,255,0.96)";
          ctx.fillText(coordText, screen.x, cursorY);
        } else {
          basePanelTopY = screen.y - HEX_SIZE * scale * 1.2;
        }

        // メモポップ（別パネル、文字大きめ）
        if (showMemoPopups && memoText) {
          const memoFontSize = baseFontSize * 1.6;
          ctx.font = `${memoFontSize}px system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif`;
          const memoWidth    = ctx.measureText(memoText).width;
          const memoPaddingX = paddingX * 1.4;
          const memoPaddingY = paddingY * 1.2;
          const memoPanelWidth  = memoWidth + memoPaddingX * 2;
          const memoPanelHeight = memoFontSize + memoPaddingY * 2;

          const memoX = screen.x - memoPanelWidth / 2;
          const memoY = basePanelTopY - memoPanelHeight - 6;

          ctx.globalAlpha = 0.95;
          ctx.fillStyle = "rgba(0,0,40,0.9)";
          drawRoundedRect(ctx, memoX, memoY, memoPanelWidth, memoPanelHeight, 8);
          ctx.fill();
          ctx.globalAlpha = 1.0;
          ctx.strokeStyle = "rgba(160,190,255,0.8)";
          ctx.lineWidth = 1;
          drawRoundedRect(ctx, memoX, memoY, memoPanelWidth, memoPanelHeight, 8);
          ctx.stroke();

          ctx.fillStyle = "rgba(210,230,255,0.98)";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `${memoFontSize}px system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif`;
          ctx.fillText(memoText, screen.x, memoY + memoPanelHeight / 2);
        }
      });

      ctx.restore();
    }

    function draw() {
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0, 0, rect.width, rect.height);
      drawGrid();
      drawDesertOutline();
      drawBlockedOutline();
      drawRegionLabels();
      drawBaseLabels();

      zoomDisplay.textContent = Math.round(scale * 100) + "%";
      cellDisplay.textContent = selectedCell
        ? `X${selectedCell.x} Y${selectedCell.y}`
        : "—";
    }

    function handleCellDoubleAction(cell) {
      const base = findBaseAtCell(cell.x, cell.y);
      if (base) openBaseDialogForEdit(base);
      else openBaseDialogForCreate(cell);
    }

    canvas.addEventListener("mousedown", (e) => {
      if (e.button !== 0) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;

      const base = findBaseAtCell(cell.x, cell.y);
      if (base) {
        draggingBaseId = base.id;
        lastDragCell = cell;
      } else {
        isPanning = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      }
      canvas.classList.add("dragging");
      draw();
    });

    window.addEventListener("mousemove", (e) => {
      if (draggingBaseId) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const cell = screenToGrid(mx, my);
        if (!lastDragCell || cell.x !== lastDragCell.x || cell.y !== lastDragCell.y) {
          moveBaseToGrid(draggingBaseId, cell.x, cell.y);
          lastDragCell = cell;
        }
        return;
      }
      if (!isPanning) return;
      const dx = e.clientX - lastMouseX;
      const dy = e.clientY - lastMouseY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      offsetX += dx;
      offsetY += dy;
      draw();
    });

    window.addEventListener("mouseup", () => {
      isPanning = false;
      draggingBaseId = null;
      lastDragCell = null;
      canvas.classList.remove("dragging");
    });

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      zoomAt(mx, my, delta);
    }, { passive: false });

    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;
      draw();
    });

    canvas.addEventListener("dblclick", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;
      handleCellDoubleAction(cell);
    });

    // タッチ：二回タップでダイアログ、ドラッグで移動／ドラッグ基地
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault(); // ブラウザのダブルタップ拡大をできるだけ抑制
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mx = t.clientX - rect.left;
      const my = t.clientY - rect.top;

      touchStartX = t.clientX;
      touchStartY = t.clientY;

      const cell = screenToGrid(mx, my);
      selectedCell = cell;

      const base = findBaseAtCell(cell.x, cell.y);
      if (base) {
        draggingBaseId = base.id;
        lastDragCell = cell;
      } else {
        isPanning = true;
        lastMouseX = t.clientX;
        lastMouseY = t.clientY;
      }
      canvas.classList.add("dragging");
      draw();
    }, { passive: false });

    canvas.addEventListener("touchmove", (e) => {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mx = t.clientX - rect.left;
      const my = t.clientY - rect.top;

      if (draggingBaseId) {
        const cell = screenToGrid(mx, my);
        if (!lastDragCell || cell.x !== lastDragCell.x || cell.y !== lastDragCell.y) {
          moveBaseToGrid(draggingBaseId, cell.x, cell.y);
          lastDragCell = cell;
        }
        return;
      }

      if (!isPanning) return;
      const dx = t.clientX - lastMouseX;
      const dy = t.clientY - lastMouseY;
      lastMouseX = t.clientX;
      lastMouseY = t.clientY;
      offsetX += dx;
      offsetY += dy;
      draw();
    }, { passive: true });

    window.addEventListener("touchend", (e) => {
      const now = Date.now();
      const rect = canvas.getBoundingClientRect();

      if (e.changedTouches && e.changedTouches.length === 1) {
        const t = e.changedTouches[0];
        const moveDist = Math.hypot(t.clientX - touchStartX, t.clientY - touchStartY);
        if (moveDist < TAP_MAX_MOVE) {
          const mx = t.clientX - rect.left;
          const my = t.clientY - rect.top;
          const cell = screenToGrid(mx, my);

          if (
            lastTapCell &&
            now - lastTapTime < TAP_MAX_DELAY &&
            lastTapCell.x === cell.x &&
            lastTapCell.y === cell.y
          ) {
            handleCellDoubleAction(cell);
            lastTapTime = 0;
            lastTapCell = null;
          } else {
            lastTapTime = now;
            lastTapCell = cell;
          }
        }
      }

      isPanning = false;
      draggingBaseId = null;
      lastDragCell = null;
      canvas.classList.remove("dragging");
    });

    function zoomAt(mx, my, zoomDelta) {
      let newScale = scale + zoomDelta * scale;
      newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
      if (newScale === scale) return;
      const worldBefore = screenToWorld(mx, my);
      scale = newScale;
      const worldAfter = screenToWorld(mx, my);
      offsetX += (worldAfter.x - worldBefore.x) * scale;
      offsetY += (worldAfter.y - worldBefore.y) * scale;
      draw();
    }

    zoomInBtn.addEventListener("click", () => {
      const rect = canvas.getBoundingClientRect();
      zoomAt(rect.width / 2, rect.height / 2, 0.2);
    });
    zoomOutBtn.addEventListener("click", () => {
      const rect = canvas.getBoundingClientRect();
      zoomAt(rect.width / 2, rect.height / 2, -0.2);
    });

    toggleSidebarBtn.addEventListener("click", () => {
      sidebarEl.classList.toggle("collapsed");
      toggleSidebarBtn.textContent = sidebarEl.classList.contains("collapsed") ? "＋" : "－";
    });

    // Pop：基地ポップ ON/OFF
    togglePopupsLabelBtn.addEventListener("click", () => {
      showBasePopups = !showBasePopups;
      draw();
    });

    // Memo：メモポップ ON/OFF
    toggleMemoPopBtn.addEventListener("click", () => {
      showMemoPopups = !showMemoPopups;
      draw();
    });

    copyBtn.addEventListener("click", async () => {
      if (bases.length === 0) {
        alert("コピーする基地がありません。");
        return;
      }
      const sorted = sortBasesArray(bases);

      const rows = sorted.map(b => {
        const alliance = allianceMap[b.allianceKey] || ALLIANCES[0];
        const allianceName = alliance.name;
        const baseName = b.name;
        const coord = `X${b.anchor.x} Y${b.anchor.y}`;
        return { allianceName, baseName, coord };
      });

      const maxAllianceLen = Math.max(...rows.map(r => r.allianceName.length));
      const maxBaseLen     = Math.max(...rows.map(r => r.baseName.length));

      const lines = rows.map(r => {
        const padAlliance = r.allianceName.padEnd(maxAllianceLen, " ");
        const padBase     = r.baseName.padEnd(maxBaseLen, " ");
        return `${padAlliance}  ${padBase}  ${r.coord}`;
      });

      const text = lines.join("\n");
      try {
        await navigator.clipboard.writeText(text);
        alert("同盟・基地名・座標をコピーしました。");
      } catch (e) {
        console.warn(e);
        alert("クリップボードへのコピーに失敗しました。");
      }
    });

    function moveBaseToGrid(baseId, gx, gy) {
      const base = bases.find(b => b.id === baseId);
      if (!base) return;
      const cells = createBaseCellsForAnchor(gx, gy, baseId);
      if (!cells) return;
      base.cells = cells;
      base.anchor = { x: gx, y: gy };
      saveBases();
      updateBaseListUI();
      draw();
    }

    function hexToRgba(hex, alpha) {
      let c = hex.replace("#", "");
      if (c.length === 3) {
        c = c.split("").map(ch => ch + ch).join("");
      }
      const r = parseInt(c.slice(0,2), 16);
      const g = parseInt(c.slice(2,4), 16);
      const b = parseInt(c.slice(4,6), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }
  </script>
</body>
</html>
