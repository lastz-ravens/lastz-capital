<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>284 Capital</title>

  <!-- favicon -->
  <link rel="icon" type="image/png" href="favicon.png" />
  <!-- iPhone ホーム画面用 -->
  <link rel="apple-touch-icon" href="apple-touch-icon.png" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-moあbile-web-app-status-bar-style" content="black-translucent" />

  <!-- スマホのページ拡大を極力禁止 -->
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
  />

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      height: 100%;
      overflow: hidden;
      background: #050608;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5f5;
      font-size: 15px;
      touch-action: none; /* ページ自体のダブルタップ拡大抑制 */
    }
    #map-canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: radial-gradient(circle at top, #1d2838 0, #050608 50%);
      cursor: grab;
      touch-action: none;
    }
    #map-canvas.dragging { cursor: grabbing; }

    /* HUD */
    .hud {
      position: fixed;
      right: 10px;
      bottom: 10px;
      padding: 7px 11px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.65);
      backdrop-filter: blur(10px);
      font-size: 13px;
      display: flex;
      gap: 8px;
      align-items: center;
      pointer-events: none;
      z-index: 10;
    }
    .hud span.label { opacity: 0.6; }
    .hud span.value { font-variant-numeric: tabular-nums; }

    /* サイドバー */
    .sidebar {
      position: fixed;
      left: 10px;
      top: 10px;
      width: 340px;
      padding: 12px;
      border-radius: 16px;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(14px);
      font-size: 14px;
      z-index: 20;
      pointer-events: auto;
      max-height: calc(100% - 20px);
      display: flex;
      flex-direction: column;
    }
    .sidebar.collapsed {
      height: auto;
      max-height: none;
      padding: 8px 12px;
    }
    /* PCでサイドバーを畳んだときはリスト＆合計＆説明を隠す */
    .sidebar.collapsed #base-list-wrapper,
    .sidebar.collapsed #sidebar-totals,
    .sidebar.collapsed .sidebar-note {
      display: none;
    }

    /* スマホで情報だけ隠す用（ヘッダー＋ツールバーだけ残す） */
    .sidebar.info-hidden .sidebar-note,
    .sidebar.info-hidden #sidebar-totals {
      display: none;
    }

    /* Info ON/OFF 用：合計と説明だけ消す */
    .sidebar.extras-hidden #sidebar-totals,
    .sidebar.extras-hidden .sidebar-note {
      display: none;
    }

    .sidebar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      margin-bottom: 6px;
    }
    .sidebar-title {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      opacity: 0.85;
    }
    #toggle-sidebar {
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      padding: 3px 9px;
      background: rgba(0,0,0,0.9);
      color: #f5f5f5;
      cursor: pointer;
      font-size: 12px;
      pointer-events: auto;
      z-index: 1;
    }

    .sidebar-actions {
      display: flex;
      flex-direction: column;
      gap: 4px;
      flex-shrink: 0;
      align-items: flex-end;
    }
    .toolbar-row {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      justify-content: flex-end;
    }
    .sidebar-actions button,
    .sidebar-actions select {
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.15);
      padding: 3px 8px;
      font-size: 12px;
      background: rgba(10,10,10,0.9);
      color: #f5f5f5;
      cursor: pointer;
      white-space: nowrap;
    }
    .sidebar-actions button:hover {
      background: rgba(255,255,255,0.15);
    }
    .sidebar-actions select {
      appearance: none;
    }

    #base-list-wrapper {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
      margin-top: 6px;
    }
    #base-list {
      list-style: none;
      margin: 0;
      padding: 0;
      overflow-y: auto;
      flex: 1;
    }

    .sidebar-totals {
      margin-top: 4px;
      font-size: 12px;
      opacity: 0.9;
      line-height: 1.4;
      border-top: 1px solid rgba(255,255,255,0.08);
      padding-top: 4px;
    }

    .sidebar-note {
      margin-top: 6px;
      font-size: 11px;
      opacity: 0.7;
      border-top: 1px solid rgba(255,255,255,0.08);
      padding-top: 4px;
    }
    .note-pc { display: block; }
    .note-sp { display: none; margin-top: 2px; }

    #base-list li.base-item {
      display: flex;
      gap: 7px;
      padding: 7px 8px;
      border-radius: 10px;
      background: rgba(255,255,255,0.04);
      margin-bottom: 4px;
      border: 1px solid transparent;
      align-items: center;
      cursor: pointer;
      transition: opacity 0.15s;
    }
    #base-list li.base-item:hover {
      background: rgba(255,255,255,0.08);
    }
    #base-list li.base-item.selected {
      border-color: rgba(255,221,85,0.8);
      box-shadow: 0 0 0 1px rgba(255,221,85,0.4);
    }
    /* フィルターで薄表示 */
    #base-list li.base-item.dimmed {
      opacity: 0.3;
    }

    .base-color-dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      flex-shrink: 0;
      border: 1px solid rgba(0,0,0,0.7);
    }
    .base-item-info {
      flex: 1;
      min-width: 0;
    }
    .base-item-name-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 4px;
    }
    .base-name {
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .base-alliance {
      font-size: 13px;
      opacity: 0.85;
      white-space: nowrap;
    }
    .base-item-meta-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 2px;
      gap: 4px;
      font-size: 13px;
    }
    .base-coord {
      opacity: 0.8;
      white-space: nowrap;
    }
    .base-tagline {
      opacity: 0.9;
      white-space: nowrap;
    }

    /* ズームボタン */
    .zoom-buttons {
      position: fixed;
      right: 10px;
      bottom: 72px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 10;
    }
    .zoom-buttons button {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      border: none;
      background: rgba(0,0,0,0.75);
      color: #fff;
      font-size: 22px;
      cursor: pointer;
      touch-action: manipulation; /* 二度押し拡大を抑える */
    }

    /* ダイアログ用共通 */
    select, input, textarea {
      background: #111;
      color: #f5f5f5;
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 8px;
      padding: 3px 6px;
      font-size: 14px;
    }

    /* 基地追加・編集ダイアログ */
    #base-dialog {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 30;
      background: rgba(0,0,0,0.6);
    }

    /* Auto配置ダイアログ */
    #auto-dialog {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 30;
      background: rgba(0,0,0,0.6);
    }

    /* Tile 追加・編集ダイアログ */
    #tile-dialog {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 30;
      background: rgba(0,0,0,0.6);
    }

    @media (max-width: 768px) {
      .hud {
        right: 8px;
        top: 8px;
        bottom: auto;
        font-size: 12px;
      }
      .zoom-buttons {
        right: 8px;
        top: 60px;
        bottom: auto;
      }
      .zoom-buttons button {
        width: 44px;
        height: 44px;
        font-size: 24px;
      }
      .sidebar {
        width: 100%;
        left: 0;
        right: 0;
        top: auto;
        bottom: 0;
        border-radius: 16px 16px 0 0;
        max-height: 50vh; /* スマホでは画面の半分まで */
        font-size: 14px;
      }
      .sidebar-actions {
        align-items: flex-start;
      }
      .sidebar-actions button,
      .sidebar-actions select {
        font-size: 12px;
        padding: 4px 7px;
      }
      #base-list li.base-item {
        padding: 8px 9px;
      }
      .note-pc { display: none; }
      .note-sp { display: block; }

      /* スマホで info-hidden のときはリストも畳む */
      .sidebar.info-hidden #base-list-wrapper,
      .sidebar.info-hidden #sidebar-totals,
      .sidebar.info-hidden .sidebar-note {
        display: none;
      }
    }
  </style>
</head>
<body>
  <canvas id="map-canvas"></canvas>

  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title">284 Capital - 基地一覧</div>
      <button id="toggle-sidebar">－</button>
    </div>

    <div class="sidebar-actions">
      <!-- 上段：ボタン -->
      <div class="toolbar-row">
        <button id="copy-btn">Copy</button>
        <button id="export-btn">Exp</button>
        <button id="import-btn">Imp</button>
        <button id="auto-btn">Auto</button>
        <button id="clear-btn">Clear</button>
        <button id="pop-toggle-btn">Pop</button>
        <button id="memo-toggle-btn">Memo</button>
        <button id="info-toggle-btn">Info</button>
        <input type="file" id="import-file" accept="application/json" style="display:none" />
      </div>
      <!-- 下段：フィルター＆ソート -->
      <div class="toolbar-row">
        <label style="font-size:11px;">
          陣営
          <select id="filter-side">
            <option value="ALL">全て</option>
            <option value="ALLY">味方</option>
            <option value="ENEMY">敵</option>
          </select>
        </label>
        <label style="font-size:11px;">
          チーム
          <select id="filter-team">
            <option value="ALL">全て</option>
            <option value="首都">首都</option>
            <option value="砲台">砲台</option>
            <option value="援護">援護</option>
          </select>
        </label>
        <label style="font-size:11px;">
          ソート
          <select id="sort-key">
            <option value="alliance">同盟</option>
            <option value="name">基地名</option>
            <option value="level">Lv.</option>
            <option value="tier">T</option>
            <option value="team">チーム</option>
          </select>
        </label>
      </div>
    </div>

    <div id="base-list-wrapper">
      <ul id="base-list"></ul>
    </div>

    <div class="sidebar-totals" id="sidebar-totals"></div>

    <div class="sidebar-note">
      <div class="note-pc">
        【PC 操作】<br>
        ・空きマス：ダブルクリックで基地 or タイル追加（確認で選択）<br>
        ・基地マス：ダブルクリックで編集・削除、ドラッグで移動<br>
        ・タイルマス：ダブルクリックでタイル編集・削除<br>
        ・マップ移動：左ドラッグ / ホイールでズーム / ＋－ボタンでズーム<br>
        ・Auto：選んだ同盟の「空き基地名」を、現在フォーカスしている座標周辺に自動配置<br>
        ・陣営 / チーム：リスト＆マップをフィルター（対象外は薄表示）<br>
        ・ソート：同盟 / 基地名 / Lv. / T / チームで並べ替え<br>
        ・Pop：基地情報ポップ表示 ON/OFF<br>
        ・Memo：メモポップだけ ON/OFF<br>
        ・Clear：全基地/タイルを一括削除（確認ダイアログあり）<br>
        ・Copy：同盟名・基地名・座標をコピー（タイルは含めない）<br>
        ・Exp/Imp：JSONでエクスポート／インポート（タイルも含む）
      </div>
      <div class="note-sp">
        【スマホ 操作】<br>
        ・空きマス：同じマスを素早く2回タップで基地 or タイル追加（確認で選択）<br>
        ・基地マス：2回タップで編集・削除、ドラッグで移動<br>
        ・タイルマス：2回タップでタイル編集・削除<br>
        ・マップ移動：1本指ドラッグ / ＋－ボタンでズーム<br>
        ・Auto：フォーカス中の座標周辺に、選んだ同盟の空き基地名を自動配置<br>
        ・陣営 / チーム：対象以外はリスト＆マップ上で薄表示<br>
        ・ソート：同盟 / 基地名 / Lv. / T / チームで並べ替え<br>
        ・Pop：基地ポップ表示 ON/OFF / Memo：メモのみポップ表示 ON/OFF<br>
        ・Clear：全基地/タイルを一括削除（確認あり）<br>
        ・Copy：同盟名・基地名・座標をコピー（タイルは含めない）<br>
        ・Exp/Imp：JSONファイルで保存／読み込み（タイルも含む）
      </div>
    </div>
  </div>

  <div class="zoom-buttons">
    <button id="zoom-in">＋</button>
    <button id="zoom-out">－</button>
  </div>

  <div class="hud">
    <span class="label">Zoom</span>
    <span class="value" id="zoom-display">100%</span>
    <span class="label">Cell</span>
    <span class="value" id="cell-display">—</span>
  </div>

  <!-- 基地追加・編集ダイアログ -->
  <div id="base-dialog">
    <div style="background:#101317; padding:14px 16px; border-radius:12px; width:320px; max-width:90%; font-size:14px;">
      <div style="font-size:15px; font-weight:600; margin-bottom:8px;">基地の追加 / 編集</div>
      <div style="display:flex; flex-direction:column; gap:8px;">
        <label>
          <span>陣営（味方 / 敵）</span><br />
          <select id="dlg-side" style="width:100%; margin-top:2px;">
            <option value="ALLY">味方</option>
            <option value="ENEMY">敵</option>
          </select>
        </label>
        <label>
          <span>所属同盟</span><br />
          <select id="dlg-alliance" style="width:100%; margin-top:2px;"></select>
        </label>
        <label>
          <span>基地名</span><br />
          <select id="dlg-name" style="width:100%; margin-top:2px;"></select>
        </label>
        <label>
          <span>チーム</span><br />
          <select id="dlg-team" style="width:100%; margin-top:2px;">
            <option value="">なし</option>
            <option value="首都">首都</option>
            <option value="砲台">砲台</option>
            <option value="援護">援護</option>
          </select>
        </label>
        <label>
          <span>参加状態</span><br />
          <select id="dlg-status" style="width:100%; margin-top:2px;">
            <option value="参加">参加</option>
            <option value="不参加">不参加</option>
            <option value="不明">不明</option>
          </select>
        </label>
        <label>
          <span>レベル</span><br />
          <select id="dlg-level" style="width:100%; margin-top:2px;"></select>
        </label>
        <label>
          <span>Tランク</span><br />
          <select id="dlg-tier" style="width:100%; margin-top:2px;"></select>
        </label>
        <label>
          <span>メモ</span><br />
          <textarea id="dlg-memo" rows="2" style="width:100%; margin-top:2px; resize:vertical;"></textarea>
        </label>
        <div style="font-size:12px; opacity:0.7;" id="dlg-coord-text"></div>
      </div>
      <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:12px;">
        <button id="dlg-cancel"
          style="border:none; border-radius:999px; padding:5px 12px; font-size:14px; background:#444; color:#f5f5f5;">
          キャンセル
        </button>
        <button id="dlg-delete"
          style="border:none; border-radius:999px; padding:5px 12px; font-size:14px; background:#aa3333; color:#fff; display:none;">
          削除
        </button>
        <button id="dlg-ok"
          style="border:none; border-radius:999px; padding:5px 12px; font-size:14px; background:#2c7be5; color:#fff;">
          決定
        </button>
      </div>
    </div>
  </div>

  <!-- Auto 自動配置ダイアログ -->
  <div id="auto-dialog">
    <div style="background:#101317; padding:14px 16px; border-radius:12px; width:320px; max-width:90%; font-size:14px;">
      <div style="font-size:15px; font-weight:600; margin-bottom:8px;">Auto 自動配置</div>
      <div style="display:flex; flex-direction:column; gap:8px;">
        <label>
          <span>陣営</span><br />
          <select id="auto-side" style="width:100%; margin-top:2px;">
            <option value="ALLY">味方</option>
            <option value="ENEMY">敵</option>
          </select>
        </label>
        <label>
          <span>所属同盟（リストから選択）</span><br />
          <select id="auto-alliance" style="width:100%; margin-top:2px;"></select>
        </label>
        <label>
          <span>チーム</span><br />
          <select id="auto-team" style="width:100%; margin-top:2px;">
            <option value="">なし</option>
            <option value="首都">首都</option>
            <option value="砲台">砲台</option>
            <option value="援護">援護</option>
          </select>
        </label>
        <label>
          <span>配置数（最大 50）</span><br />
          <input id="auto-count" type="number" min="1" max="50" value="50" style="width:100%; margin-top:2px;" />
        </label>
        <div style="font-size:12px; opacity:0.75;">
          ※ 現在フォーカスしているセル（黄色枠）を中心に、近いマスから順に自動配置します。<br>
          ※ 同盟内で未使用の基地名だけを上から順に使用します。
        </div>
      </div>
      <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:12px;">
        <button id="auto-cancel"
          style="border:none; border-radius:999px; padding:5px 12px; font-size:14px; background:#444; color:#f5f5f5;">
          キャンセル
        </button>
        <button id="auto-ok"
          style="border:none; border-radius:999px; padding:5px 12px; font-size:14px; background:#2c7be5; color:#fff;">
          実行
        </button>
      </div>
    </div>
  </div>

  <!-- Tile 追加・編集ダイアログ -->
  <div id="tile-dialog">
    <div style="background:#101317; padding:14px 16px; border-radius:12px; width:320px; max-width:90%; font-size:14px;">
      <div style="font-size:15px; font-weight:600; margin-bottom:8px;">タイル（資源）の追加 / 編集</div>
      <div style="display:flex; flex-direction:column; gap:10px;">
        <label>
          <span>タイル名</span><br />
          <input id="tile-name" type="text" value="資源" style="width:100%; margin-top:2px;" />
        </label>
        <div style="font-size:12px; opacity:0.7;" id="tile-coord-text"></div>
        <div style="font-size:12px; opacity:0.75;">
          ※ タイルは1マスだけ占有し、基地はそのマスに配置できません。<br>
          ※ タイルは基地一覧には表示しません。
        </div>
      </div>
      <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:12px;">
        <button id="tile-cancel"
          style="border:none; border-radius:999px; padding:5px 12px; font-size:14px; background:#444; color:#f5f5f5;">
          キャンセル
        </button>
        <button id="tile-delete"
          style="border:none; border-radius:999px; padding:5px 12px; font-size:14px; background:#aa3333; color:#fff; display:none;">
          削除
        </button>
        <button id="tile-ok"
          style="border:none; border-radius:999px; padding:5px 12px; font-size:14px; background:#2c7be5; color:#fff;">
          決定
        </button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("map-canvas");
    const ctx = canvas.getContext("2d");
    const zoomDisplay = document.getElementById("zoom-display");
    const cellDisplay = document.getElementById("cell-display");
    const baseListEl = document.getElementById("base-list");
    const sidebarEl = document.getElementById("sidebar");
    const sidebarTotalsEl = document.getElementById("sidebar-totals");

    const copyBtn = document.getElementById("copy-btn");
    const toggleSidebarBtn = document.getElementById("toggle-sidebar");
    const zoomInBtn = document.getElementById("zoom-in");
    const zoomOutBtn = document.getElementById("zoom-out");
    const exportBtn = document.getElementById("export-btn");
    const importBtn = document.getElementById("import-btn");
    const autoBtn = document.getElementById("auto-btn");
    const clearBtn = document.getElementById("clear-btn");
    const importFileInput = document.getElementById("import-file");

    const filterSideSel = document.getElementById("filter-side");
    const filterTeamSel = document.getElementById("filter-team");
    const sortKeySel = document.getElementById("sort-key");
    const popToggleBtn = document.getElementById("pop-toggle-btn");
    const memoToggleBtn = document.getElementById("memo-toggle-btn");
    const infoToggleBtn = document.getElementById("info-toggle-btn");

    const baseDialog = document.getElementById("base-dialog");
    const dlgSide = document.getElementById("dlg-side");
    const dlgAlliance = document.getElementById("dlg-alliance");
    const dlgName = document.getElementById("dlg-name");
    const dlgTeam = document.getElementById("dlg-team");
    const dlgStatus = document.getElementById("dlg-status");
    const dlgLevel = document.getElementById("dlg-level");
    const dlgTier = document.getElementById("dlg-tier");
    const dlgMemo = document.getElementById("dlg-memo");
    const dlgCoordText = document.getElementById("dlg-coord-text");
    const dlgCancel = document.getElementById("dlg-cancel");
    const dlgOk = document.getElementById("dlg-ok");
    const dlgDelete = document.getElementById("dlg-delete");

    const autoDialog = document.getElementById("auto-dialog");
    const autoSide = document.getElementById("auto-side");
    const autoAlliance = document.getElementById("auto-alliance");
    const autoTeam = document.getElementById("auto-team");
    const autoCount = document.getElementById("auto-count");
    const autoCancel = document.getElementById("auto-cancel");
    const autoOk = document.getElementById("auto-ok");

    // Tile dialog
    const tileDialog = document.getElementById("tile-dialog");
    const tileNameInput = document.getElementById("tile-name");
    const tileCoordText = document.getElementById("tile-coord-text");
    const tileCancel = document.getElementById("tile-cancel");
    const tileDelete = document.getElementById("tile-delete");
    const tileOk = document.getElementById("tile-ok");

    const HEX_SIZE = 20;
    const GRID_MAX_X = 999;
    const GRID_MAX_Y = 999;
    const HEX_VERT_SPACING = 1.5 * HEX_SIZE;
    const HEX_HORIZ_SPACING = Math.sqrt(3) * HEX_SIZE;
    const EDGE_THICKNESS_WORLD = HEX_SIZE * 0.8;
    const STORAGE_KEY = "hexmap_bases_v12";

    let scale = 0.35;
    let offsetX = 0;
    let offsetY = 0;
    const MIN_SCALE = 0.08;
    const MAX_SCALE = 3.0;

    let isPanning = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let selectedCell = null;
    let selectedBaseId = null;

    let touchStartX = 0;
    let touchStartY = 0;
    let lastTapTime = 0;
    let lastTapCell = null;
    const TAP_MAX_DELAY = 320;
    const TAP_MAX_MOVE = 12;

    let draggingBaseId = null;
    let lastDragCell = null;

    const bases = [];
    const tiles = []; // タイル（資源）: 1マスだけ占有、基地一覧には出さない

    const CAPITAL_CENTER_X = 500;
    const CAPITAL_CENTER_Y = 500;
    const VIEW_RADIUS = 50;
    const VIEW_MIN_X = Math.max(0, CAPITAL_CENTER_X - VIEW_RADIUS);
    const VIEW_MAX_X = Math.min(GRID_MAX_X, CAPITAL_CENTER_X + VIEW_RADIUS);
    const VIEW_MIN_Y = Math.max(0, CAPITAL_CENTER_Y - VIEW_RADIUS);
    const VIEW_MAX_Y = Math.min(GRID_MAX_Y, CAPITAL_CENTER_Y + VIEW_RADIUS);

    // 敵/味方 1000人
    const ENEMY_MEMBERS = Array.from({ length: 1000 }, (_, i) => "敵" + String(i + 1).padStart(3, "0"));
    const ALLY_MEMBERS = Array.from({ length: 1000 }, (_, i) => "味方" + String(i + 1).padStart(3, "0"));

    // 味方/敵 基本色＋チーム色
    function getBaseColor(b) {
      const side = b.side || "ALLY";
      const team = b.team || "";
      if (side === "ALLY") {
        if (team === "首都") return "#99ffcc";
        if (team === "砲台") return "#55dd88";
        if (team === "援護") return "#44bb77";
        return "#66ff99"; // デフォルト味方
      } else {
        if (team === "首都") return "#ff9999";
        if (team === "砲台") return "#ff4444";
        if (team === "援護") return "#dd5555";
        return "#ff6666"; // デフォルト敵
      }
    }

const ALLIANCES = [
  {
    key: "B777",
    name: "B777",
    side: "ALLY",
    color: "#ffcc00",
    textColor: "#201500",
    members: [
      "SuperZeus","NEXUS21","ɌAM","neku-ra","Frog Seal","simon-nu","すぎっしー","ponsu",
      "GENLuckyTrigger","OneTop","るんず","靈魂拷問者","Hans 23","ステカセ王","オーシマン",
      "ロッシー","Ramen-X","503DI","Sindy Lin","LakiLuky","Vikara","yanchaaan","AINS","QQ27",
      "ヨホホホホ","Pesona Baja","Baron","サバス","zero","えび","亞丘卡斯","RastaRob","アルアル",
      "Happyぼっち","Yanoyano","RUSK222","グリングリ","赤ヘル","もえご","CraZyLiOn","やちこ",
      "WDギャン","D Chopper","ポル","ケイー","まむし","keioka","みにこり","アカサ","JDM Killers",
      "yusukerion","nyu-ha-to","PIPECUT","1m2","xJISOOx","onaka","Coffee jelly","れみす","くまみーん",
      "ヴォーグ","ユウディ","あこまき","ジャン","岡ティー","alex0814","ぺけたん","Dante ダンテ",
      "アイアイ","mamimumemo","NEXUS21-farm2","浮亂苦","jurasinee","もーー","SEELE","サムエル","mr344",
      "TnaTion","irohoma","2kkhpqe","Retaka","Vivihana","RUKA0806","M731","JoJo11","アジング","PUSAT",
      "タカちゃん","NEXUS21-farm3","Ra-Men-Man","フランメ","Sakura0207","ピザコーラ"
    ]
  },

  {
    key: "EclA",
    name: "EclA",
    side: "ALLY",
    color: "#66ccff",
    textColor: "#002233",
    members: [
      "伏黒 恵","冨岡 義勇","Lucien Dodsa","Kori77","はるちゃん","RENOVATIO","reaper777","D0NKI호테",
      "t imo","Nishi7","SimpleDude","Squidward jr","godjji","Machang Bubok","hajime77777","岳仔","NAT-",
      "User2abcd","makonosuke","CーPON","Jesterko","Redslayer","현대제철","v끝판대장v","めいちゃん",
      "Manorama","SoupySuperStar","c-137","CORONELNEMO","RAVI10","Z","BakA","DV 디뷔","KANASAl","Dentrival",
      "nelipot","VIadimir Fido","糧草徵收員","truth-","Simon1118","Suokki","SurvivorREM","Nobodymeow",
      "plwro","MegaDragonite","Razvan22","CR2025","にぃ","F RHS","以蔵 -IZO-","SeoulGirl","duberman",
      "ReD EyEs","simply red","Wolfdog Walker","Mirellle","•HappyKitty","Tiara333","Jeyci","Diegomv",
      "White Paladin","Jabol86","Acing D⁵","Sky18","Taro12","RedKadek","TURAN TM","masa1121","香ばしい",
      "야찰퀸","ワル兄","にゃん五郎","tasso","ハルク","Crimson-Sky","MOCHI110","winter0101","X茶太郎X",
      "온새결","곧망할게임","우엉이","开aitosmith","まるる","DiegoX","Emmanuel Wick","ブレラ","Fhie chenz",
      "アジ丸","ritoru","JoeLin","Lsh93","Craigクレグ","CapnJack","Momonyan","CRAZY H","・LUZ","あぶら","ジャイアN"
    ]
  },

  {
    key: "TWJP",
    name: "TWJP",
    side: "ALLY",
    color: "#ffd966",
    textColor: "#4a3b00",
    members: [
      "每天乾一杯","躺著打電動","KADMIEL","丹霓danni","Strawberry18","FC3S13B","ice77","Zmaj Zmaj",
      "denkochan","Lun511","cccwhatever","농구화","騎兵","Force65","pablo97","HY Chou","Stipep","cheers",
      "Reimei","可以喔","蛋丁","クソゲー２","Frank0714","dody905","CR319","ミヤビ","琥珀色月犽","風飄搖",
      "jurtu","暴花戶","UnderPalace","Rogon8689","El Nino 666","Benas E9","Call me Duncan","Tetorspower",
      "XzBit12","マモン","kdkdkrkr","騎豬撞飛機","f4nnaa","ragan0808","黑皮25","３３０","miramoon",
      "Decade 2","Antoblonde2610","M제이","qudals","迪思科","SYNAPSE","啊ken","APA yo","Lyraea","打鼓香檳",
      "HiHiJets","末日戰警","j3aom","海贼娜美","khong-ten","miles04","小虎鯨","roy00","SUNNY12","喜仔","k82",
      "Askium","Hot-Ice","殘楓飛櫻","ribsbbq","みにぶぅ","過關斬將","CrazyAnnabelle","shelbssss",
      "ThailandofSmile","Black851","JLJ ATHLETIC","Lady GGG","jumberi","XIBRID","dimplekitty","mjg0352",
      "スマイル","達磨一家","Nukesaku Sensei","WILLIAMLIM","Pippopero","Tom37","weirdZorro","水火村",
      "abelard74","Dewei","BLADE93","User Jim6957","ダン 男前","sparrowroc","너래쳐","Noval Yoko","楊家女"
    ]
  },

  {
    key: "YZKR",
    name: "YZKR",
    side: "ALLY",
    color: "#ffb6c1",
    textColor: "#4a0015",
    members: [
      "えな ena","かなた♪","こげっち","こうる","sho27","Kuroラベル","鬼神避之","momacco","秋桜","tktktk","D-51",
      "ks0717","Naru ZC33S","破れ傘","ぱるるん","ゆきだるま","YOU2525","はらみ","ロウザ","でん乃","Misaki3397",
      "くろくろ","とうとう","kazchan","ゆな　zeno","倉さん","きっぺい","ケイ050","リート","かか","ポカリ",
      "mosnid","KEI RHU","timitan12","fox9","おちゅみ","げんぞう","TAKA TAKA","ぴーぽ君","ぴょ","天使＆悪魔",
      "男前","にーまる","nobu7265","シーザー","Kciel","タチモス","あんな","とっち","へたっぴ","Ajisai Kirei",
      "ぺぺぺぺ","Shooota","わたあお","ココちゃん","みたらし","戰舞之歌","黒猫爺","門ちゃん","drugmorimori",
      "徒然草","miracle moon","ジス","teruocurry","Ma-me-Shi-ba","マクロナ","まさぽん","さくらさく","シドユー",
      "さとう","ュシッロブ","オニマリオ","Miruki","ゴンです","コウサン","rosuke","Michael3","バイソン","maru0821",
      "たけみち","天領うどん","やたやち","ゆんける","?旭日?","Ranb","はやてつ","マリオット","rina1980","ゆずぴ",
      "taka8","も  も  か","徐 傾人","ふりーざ","尚7766","チャゲ","吉田スパナ"
    ]
  },

  {
    key: "HNJR",
    name: "HNJR",
    side: "ALLY",
    color: "#c3f0ff",
    textColor: "#002b36",
    members: [
      "unkooo","ゅう","さぁ","やまいぶ","shuu-4","きんさん","ミーム","ももたろう","あゆしょ","むさしなお",
      "rrrrrin","たぴまる","ゆんぞん","まるぺろ","ライオンズ","みさ","BlackThunder14","yuki☆","スモジ",
      "＊MISERY＊","tathuya","taka3701","Bamboo User","hisachi589","tgjpgata","桜散る","マンダハン","どーしよ",
      "Vectさん","マーボー☆","やすくん","Fuu25","ブーサン","ちゃば","ちづるん","WaterDAM","しおさんま","オリビエ",
      "よしぞう","かぜだま","imodas","ひろぴん","tac3","マ?くん","SOSHIZI","Gattu08","long2","よっシー","ぺんちゃん",
      "OKAPI","WindTemplar","みるみる","MaRkOoO","イルカ","kxk0310","磯野まぐろ","Sira15","ポール","umanomix",
      "GH4N1","afroafroafro","ive6aespa4","ピンキリ","ブドウ","lafka","Asukachan","DIOカーズ","Nifeng Lee",
      "JEDDA1","yaho1230","Ariel sanjuan","sin 121","hiroisi","Ｏyakata","Hi Ben","Jaccs","ミン","たけむー","chii0301",
      "任天堂","Muuchan","忍者裏蛮蛮","OxxYKriY","ん～ご","a-zyu-mi","BoLeK","なゃーさん","やび","User2kki40kps",
      "ハムカツ","User2kki2ss1","User2kki1v","Calum sands","User2kkh0t8","User2kkgvhb","majiめがね"
    ]
  },

  {
    key: "CrR",
    name: "CrR",
    side: "ALLY",
    color: "#ff8a8a",
    textColor: "#330000",
    members: [
      "smoked tongue","ゼロ","ジジ","cocomi","Reiちぇる","mokaもか","raddekV","ma-mogu","肩幅 good day","???",
      "Kknnt00","タカナさん","か〜ず","ss nanamai","Swedish wolf","hanabi★","ちゃまま","パパン","m-chocolate",
      "SHAH77","かぎしっぽ","クロス","Luv sic","ysyk","wanchan12","Tracy Tomato","ピノ","syunemo","Saaaaaaa",
      "yutayuta","yasu613","ジェネラル","ぽた","へいぽー","Lord Geit","tribalwish","よよよよ","マチコ＊",
      "chemi-sxx","KEN WORLD","MASA06","やま06","dog paradise","Katherine2008","旦那さん","Azier","KirschNacht",
      "ルーク0537","lies darknes98","Rokin","atobi","クルーズ","Masuo honmono","冰皇","WS3","MIYAVI","Salyyy",
      "Idealize","jisooジス","C28 SERENA","WayneWu","palumi","raonwooju","User Awe","ゼブライカ","yuuuuv",
      "悠愛佳","Donmexxxxx","victtoy","Amxrxn65"
    ]
  },

  {
    key: "SYM1",
    name: "SYM1",
    side: "ALLY",
    color: "#d5b3ff",
    textColor: "#2a003d",
    members: [
      "ソンア","ぶっこりー","つば侍ペン","れいか","aous","ｼエロ SIERO","GAGA","フランキ一","COYG-14",
      "Natalie926","Andy7239","Inoyasa","トムサップ","ちくワン","oppe","King Azka","ぶりとりす","CHIPORG",
      "vlados","萌?","bekdi","powpow600","rcontra","CrazyCrows","Mcloven bruv","newb the roses","PlaYer","イイネコ",
      "muratamo","짜장먼","kazuuu","StraightTea","るっきー","Cat Garong","ソウタン","ワンダマン","Hanaハナ",
      "Spawn007","jimannz","wally93","daffaputrabugis","ゴルゴ31","ペラ坊","elchaaaan","Q Frince","alya adillah",
      "成田山","sentia20","20251218","renkon","Tyaraa22","sergeiiiiiii","JC Mex","ralf18","Brent8","giants61555",
      "lesserafim19","stivenk","雲野銃座","Luis Alvaro","Maharani12","Bumperman","ヤッァハー","moto jam","VimaVima",
      "ikan tenggiri","白虎隊長","阿阿阿奇","anak bekdi","Edlor","VEGASs","happy everyday","incridibles °",
      "Yod1981","velnias666","madromi02","Armeni jan","Stigmatized","PhoeNixTomm","のっすん","わいくん","サイクロン",
      "Devanney","須賀太郎","Takdir","00000000T","いろはす","EX-FAN","User2kkh8q8","User2kkh5s5","Maxim","lukeraiz",
      "なかやら","User2kkhd1q"
    ]
  },

  {
    key: "anne",
    name: "anne",
    side: "ALLY",
    color: "#a0e7a0",
    textColor: "#003300",
    members: [
      "杏眠","JuluP","xHarukax","ほしかなた","みち","Zi--","シャクレ","Zexal","miichan","尾張の玄","シバ神",
      "FC ALMOND","りぃ","ひまひか","nolika","amato","tak-e","じょかい","YO5","StoneSour0622","manmos","tomyori",
      "marcloud","millz10","サカッシ-","kenkenkeeen","ぜんたん","破壊魔定光","User2にこ","toritoto","ういんなー",
      "lumpieeeeeee","kinking","ぺぺちん","T－Virus","norikazu","maasan","ハタ坊","bombass","MmMmnNn","鍛寅",
      "Ham0226","バリイチ","mihi mihi","ひろすえの","こつぴー","じゅらさぶ","ハヤーノ","levorg","xu yang",
      "ペペペロウ","ボルト","さいちゃだ","Jill2323","りお","ぽちかなた","燕市最高","Wannafly","TAROMARU","ごえん",
      "Ichi2","ガララ","とっとみぃ","新宿精肉店","EngelHolz","ビレッジ","Hana hana","ブルーブ","Mmaverick",
      "ぞんびい","ごり","queen ares","User2kkhケン","新里123","パワタス","大丈夫だよ","JuluP FARM 1",
      "Ham育成中","멋지다","JuluP FARM 2","Ham増援用1","watazo"
    ]
  },

  {
    key: "KSKS",
    name: "KSKS",
    side: "ALLY",
    color: "#9ecbff",
    textColor: "#001a33",
    members: [
      "FENIXFIRE","Danger Rous2075","Madrid 15","htennek","€clips€","Ligth Yagamii","Kokoman","Jorsa","MMACL","F1J1679",
      "Nowogrdzki","segero","JJRC1290","User2kkh2h6","NIETO1989","jk005","SolomonMouya","Telangana","saaaya","yyyyyyyyyu",
      "Belph","User2kkhvi7","Sanggorok","Miya mimo","It ME","BIG33","Scorpion80","User2kkhq3m","MtercValEsp","60haiz",
      "KZS Kali","godam","Frank NaJa","abrahamcito","Deire","cocoa-","DOOMTRA","Plantik","Janus Rain","User2kki28a",
      "Mrafgnihc","Andrzej 1243","JC HOUSE96","Pepen64","Katsuro86","真島マコト","ArYsa","lbs002","bbbbbin","Hook11",
      "JEVG123","User2kkh0n0","Kiyotaka1978","User2kkhlnk","Rockandrol","Kampan69","joeekjir","BBKEMX","User2kkh8jl",
      "Jamking","User2kkhdtk","Marinot","RZ-W40","Adiola","User2kkher2","patjohnson","Corralejo","N1dhogg","BarlottiR",
      "Nong 8888","IvanDem","暇なら働け","ChinoxIrvin","Luque del py","Miyagido","Surpriseb","RedBarras","red89",
      "さっつん","Juancho13","La Funebre","Edwin hawk","User2kkh5uu","User2kkhv3i","BEARS DOWN","User2kki47d","Spyk3r",
      "tsopaeng","YOJIMBO","Zombie barrier","User2kkhida","SIGxi","DaniixD","User2kkh0mh","User2kkhjic","User2kkhpfi",
      "matano","Baakie13","Zo0000oommmingg","Anan kub"
    ]
  },

  // 汎用（残しておくと便利：既存コード互換）
  {
    key: "ALLY",
    name: "味方",
    side: "ALLY",
    color: "#99ffcc",
    textColor: "#002010",
    members: ALLY_MEMBERS
  },
  {
    key: "ENEMY",
    name: "敵",
    side: "ENEMY",
    color: "#ff6666",
    textColor: "#2a0000",
    members: ENEMY_MEMBERS
  }
];

    const allianceMap = {};
    ALLIANCES.forEach(a => { allianceMap[a.key] = a; });

    const desertVerticesGrid = [
      { x: 482, y: 465 },
      { x: 465, y: 500 },
      { x: 482, y: 535 },
      { x: 517, y: 535 },
      { x: 535, y: 500 },
      { x: 517, y: 465 }
    ];
    const blockedVerticesGrid = [
      { x: 483, y: 500 },
      { x: 491, y: 517 },
      { x: 508, y: 517 },
      { x: 517, y: 500 },
      { x: 508, y: 483 },
      { x: 491, y: 483 }
    ];
    const extraBlockedCells = [
      { x: 489, y: 515 },{ x: 490, y: 516 },{ x: 490, y: 517 },{ x: 491, y: 518 },
      { x: 491, y: 585 },{ x: 492, y: 518 },{ x: 493, y: 518 },{ x: 494, y: 518 },
      { x: 489, y: 516 },{ x: 489, y: 517 },{ x: 490, y: 518 },{ x: 490, y: 519 },
      { x: 491, y: 519 },{ x: 492, y: 519 },{ x: 493, y: 519 },
      { x: 517, y: 502 },{ x: 517, y: 501 },{ x: 517, y: 502 },{ x: 518, y: 500 },
      { x: 518, y: 499 },{ x: 518, y: 498 },{ x: 517, y: 497 },{ x: 517, y: 496 },
      { x: 517, y: 499 },{ x: 517, y: 498 },{ x: 516, y: 497 },{ x: 516, y: 496 },
      { x: 489, y: 485 },{ x: 489, y: 484 },{ x: 489, y: 483 },{ x: 490, y: 482 },
      { x: 490, y: 484 },{ x: 490, y: 483 },{ x: 491, y: 482 },{ x: 491, y: 481 },
      { x: 492, y: 482 },{ x: 492, y: 481 },{ x: 493, y: 482 },{ x: 494, y: 482 },
      { x: 490, y: 481 },{ x: 493, y: 481 },{ x: 494, y: 482 }
    ];

    let desertPolygonWorld = [];
    let blockedPolygonWorld = [];

    const basePatternAxial = [
      { dq: 0, dr: 0 },
      { dq: 1, dr: 0 },
      { dq: 0, dr: 1 },
      { dq: -1, dr: 1 },
      { dq: -1, dr: 0 },
      { dq: 0, dr: -1 },
      { dq: 1, dr: -1 }
    ];

    function oddrToAxial(col, row) {
      const q = col - (row - (row & 1)) / 2;
      const r = row;
      return { q, r };
    }
    function axialToOddr(q, r) {
      const row = r;
      const col = q + (r - (r & 1)) / 2;
      return { x: col, y: row };
    }

    function gridToWorld(gx, gy) {
      const wx = HEX_HORIZ_SPACING * (gx + (gy & 1) * 0.5);
      const wy = HEX_VERT_SPACING * gy;
      return { x: wx, y: wy };
    }
    function worldToScreen(wx, wy) {
      return { x: wx * scale + offsetX, y: wy * scale + offsetY };
    }
    function screenToWorld(sx, sy) {
      return { x: (sx - offsetX) / scale, y: (sy - offsetY) / scale };
    }
    function screenToGrid(sx, sy) {
      const w = screenToWorld(sx, sy);
      let gy = Math.round(w.y / HEX_VERT_SPACING);
      gy = Math.max(0, Math.min(GRID_MAX_Y, gy));
      const rowOffset = (gy & 1) ? HEX_HORIZ_SPACING * 0.5 : 0;
      let gx = Math.round((w.x - rowOffset) / HEX_HORIZ_SPACING);
      gx = Math.max(0, Math.min(GRID_MAX_X, gx));
      return { x: gx, y: gy };
    }

    function pointInPolygon(point, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect =
          ((yi > point.y) !== (yj > point.y)) &&
          (point.x < (xj - xi) * (point.y - yi) / (yj - yi + 1e-9) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    function pointToSegmentDistance(p, a, b) {
      const vx = b.x - a.x;
      const vy = b.y - a.y;
      const wx = p.x - a.x;
      const wy = p.y - a.y;
      const c1 = vx * wx + vy * wy;
      if (c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y);
      const c2 = vx * vx + vy * vy;
      if (c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y);
      const t = c1 / c2;
      const projx = a.x + t * vx;
      const projy = a.y + t * vy;
      return Math.hypot(p.x - projx, p.y - projy);
    }
    function distanceToPolygonEdges(p, polygon) {
      let minD = Infinity;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const d = pointToSegmentDistance(p, polygon[j], polygon[i]);
        if (d < minD) minD = d;
      }
      return minD;
    }

    function isBlockedCell(gx, gy) {
      for (let i = 0; i < extraBlockedCells.length; i++) {
        const c = extraBlockedCells[i];
        if (c.x === gx && c.y === gy) return true;
      }
      const w = gridToWorld(gx, gy);
      const inside = pointInPolygon(w, blockedPolygonWorld);
      const dist = distanceToPolygonEdges(w, blockedPolygonWorld);
      return inside || dist <= EDGE_THICKNESS_WORLD;
    }

    function findTileAtCell(gx, gy) {
      for (let i = 0; i < tiles.length; i++) {
        const t = tiles[i];
        if (t.x === gx && t.y === gy) return t;
      }
      return null;
    }

    function findBaseAtCell(gx, gy) {
      for (let i = 0; i < bases.length; i++) {
        const b = bases[i];
        for (let j = 0; j < b.cells.length; j++) {
          const c = b.cells[j];
          if (c.x === gx && c.y === gy) {
            return b;
          }
        }
      }
      return null;
    }

    function createBaseCellsForAnchor(gx, gy, ignoreBaseId) {
      const ar = oddrToAxial(gx, gy);
      const cells = [];
      for (let i = 0; i < basePatternAxial.length; i++) {
        const off = basePatternAxial[i];
        const oq = ar.q + off.dq;
        const or = ar.r + off.dr;
        const o = axialToOddr(oq, or);
        cells.push(o);
      }
      for (let i = 0; i < cells.length; i++) {
        const c = cells[i];
        if (c.x < 0 || c.x > GRID_MAX_X || c.y < 0 || c.y > GRID_MAX_Y) return null;
        if (isBlockedCell(c.x, c.y)) return null;
        if (findTileAtCell(c.x, c.y)) return null; // タイルがあるマスには基地を置けない
        for (let bi = 0; bi < bases.length; bi++) {
          const b = bases[bi];
          if (ignoreBaseId && b.id === ignoreBaseId) continue;
          for (let cj = 0; cj < b.cells.length; cj++) {
            const bc = b.cells[cj];
            if (bc.x === c.x && bc.y === c.y) return null;
          }
        }
      }
      return cells;
    }

    function deleteBaseById(id) {
      const idx = bases.findIndex(b => b.id === id);
      if (idx !== -1) {
        bases.splice(idx, 1);
        saveBases();
        updateBaseListUI();
        updateTotals();
        draw();
      }
    }

    function makeSerializableData() {
      return {
        bases: bases.map(b => ({
          id: b.id,
          side: b.side,
          allianceKey: b.allianceKey,
          name: b.name,
          team: b.team,
          status: b.status,
          level: b.level,
          tier: b.tier,
          memo: b.memo || "",
          anchor: b.anchor
        })),
        tiles: tiles.map(t => ({
          id: t.id,
          x: t.x,
          y: t.y,
          name: t.name || "資源"
        }))
      };
    }

    function saveBases() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(makeSerializableData()));
      } catch (e) {
        console.warn("saveBases error:", e);
      }
    }

    function loadBases() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      try {
        const data = JSON.parse(raw);
        if (!data) return;

        // bases
        if (Array.isArray(data.bases)) {
          data.bases.forEach(rec => {
            if (!rec.anchor) return;
            const cells = createBaseCellsForAnchor(rec.anchor.x, rec.anchor.y, null);
            if (!cells) return;
            const alliance = allianceMap[rec.allianceKey] || ALLIANCES[0];
            bases.push({
              id: rec.id || (Date.now().toString(36) + Math.random().toString(36).slice(2,7)),
              side: rec.side || alliance.side || "ALLY",
              allianceKey: rec.allianceKey || "B777",
              name: rec.name || "基地",
              team: rec.team || "",
              status: rec.status || "不明",
              level: rec.level ?? null,
              tier: rec.tier || "T1",
              memo: rec.memo || "",
              cells,
              anchor: rec.anchor
            });
          });
        }

        // tiles
        if (Array.isArray(data.tiles)) {
          data.tiles.forEach(rec => {
            if (typeof rec.x !== "number" || typeof rec.y !== "number") return;
            if (findTileAtCell(rec.x, rec.y)) return;
            tiles.push({
              id: rec.id || (Date.now().toString(36) + Math.random().toString(36).slice(2,7)),
              x: rec.x,
              y: rec.y,
              name: rec.name || "資源"
            });
          });
        }
      } catch (e) {
        console.warn("loadBases error:", e);
      }
    }

    function importBasesFromData(data) {
      if (!data || !Array.isArray(data.bases)) {
        alert("インポートするJSONの形式が不正です。");
        return;
      }
      if (!confirm("現在の基地データを全て置き換えますか？")) return;

      bases.length = 0;
      tiles.length = 0;

      // bases
      data.bases.forEach(rec => {
        if (!rec.anchor) return;
        const cells = createBaseCellsForAnchor(rec.anchor.x, rec.anchor.y, null);
        if (!cells) return;
        const alliance = allianceMap[rec.allianceKey] || ALLIANCES[0];
        bases.push({
          id: rec.id || (Date.now().toString(36) + Math.random().toString(36).slice(2,7)),
          side: rec.side || alliance.side || "ALLY",
          allianceKey: rec.allianceKey || "B777",
          name: rec.name || "基地",
          team: rec.team || "",
          status: rec.status || "不明",
          level: rec.level ?? null,
          tier: rec.tier || "T1",
          memo: rec.memo || "",
          cells,
          anchor: rec.anchor
        });
      });

      // tiles（任意）
      if (Array.isArray(data.tiles)) {
        data.tiles.forEach(rec => {
          if (typeof rec.x !== "number" || typeof rec.y !== "number") return;
          // 基地セル/タイルと重なるものはスキップ
          if (findBaseAtCell(rec.x, rec.y)) return;
          if (findTileAtCell(rec.x, rec.y)) return;
          // 配置不可（blocked）もスキップ
          if (isBlockedCell(rec.x, rec.y)) return;

          tiles.push({
            id: rec.id || (Date.now().toString(36) + Math.random().toString(36).slice(2,7)),
            x: rec.x,
            y: rec.y,
            name: rec.name || "資源"
          });
        });
      }

      saveBases();
      updateBaseListUI();
      updateTotals();
      draw();
    }

    function exportBasesToFile() {
      const data = makeSerializableData();
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "bases.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function handleImportFile(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(ev) {
        try {
          const data = JSON.parse(ev.target.result);
          importBasesFromData(data);
        } catch (err) {
          console.error(err);
          alert("JSONの読み込みに失敗しました。");
        } finally {
          importFileInput.value = "";
        }
      };
      reader.readAsText(file, "utf-8");
    }

    exportBtn.addEventListener("click", exportBasesToFile);
    importBtn.addEventListener("click", function() {
      importFileInput.click();
    });
    importFileInput.addEventListener("change", handleImportFile);

    // フィルター状態
    let filterSide = "ALL";
    let filterTeam = "ALL";

    function isBaseMatchFilter(b) {
      if (filterSide !== "ALL" && b.side !== filterSide) return false;
      if (filterTeam !== "ALL" && b.team !== filterTeam) return false;
      return true;
    }

    function getFilteredBases() {
      return bases.filter(isBaseMatchFilter);
    }

    filterSideSel.addEventListener("change", function() {
      filterSide = filterSideSel.value;
      updateBaseListUI();
      updateTotals();
      draw();
    });
    filterTeamSel.addEventListener("change", function() {
      filterTeam = filterTeamSel.value;
      updateBaseListUI();
      updateTotals();
      draw();
    });
    sortKeySel.addEventListener("change", function() {
      updateBaseListUI();
    });

    // Pop / Memo ON/OFF
    let showBasePopups = true;
    let showMemoPopups = true;
    popToggleBtn.textContent = "Pop ON";
    memoToggleBtn.textContent = "Memo ON";

    popToggleBtn.addEventListener("click", function() {
      showBasePopups = !showBasePopups;
      popToggleBtn.textContent = showBasePopups ? "Pop ON" : "Pop OFF";
      draw();
    });
    memoToggleBtn.addEventListener("click", function() {
      showMemoPopups = !showMemoPopups;
      memoToggleBtn.textContent = showMemoPopups ? "Memo ON" : "Memo OFF";
      draw();
    });

    // Info（合計＋説明）ON/OFF
    let infoVisible = true;
    infoToggleBtn.textContent = "Info ON";
    infoToggleBtn.addEventListener("click", function() {
      infoVisible = !infoVisible;
      if (infoVisible) {
        sidebarEl.classList.remove("extras-hidden");
        infoToggleBtn.textContent = "Info ON";
      } else {
        sidebarEl.classList.add("extras-hidden");
        infoToggleBtn.textContent = "Info OFF";
      }
    });

    // 基地ダイアログ状態
    let dialogMode = "create";
    let dialogCell = null;
    let dialogEditingBase = null;

    // タイルダイアログ状態
    let tileDialogMode = "create"; // create/edit
    let tileDialogCell = null;
    let tileEditing = null;

    function initDialogSelectors() {
      dlgLevel.innerHTML = "";
      for (let lv = 30; lv >= 1; lv--) {
        const opt = document.createElement("option");
        opt.value = String(lv);
        opt.textContent = "Lv." + lv;
        dlgLevel.appendChild(opt);
      }
      dlgTier.innerHTML = "";
      for (let t = 10; t >= 1; t--) {
        const opt = document.createElement("option");
        opt.value = "T" + t;
        opt.textContent = "T" + t;
        dlgTier.appendChild(opt);
      }
      fillAllianceSelect(dlgAlliance, "ALLY");
    }

    // 共通：陣営ごとの同盟リストをセレクトに詰める
    function fillAllianceSelect(selectEl, side) {
      const list = ALLIANCES.filter(a => a.side === side);
      list.sort((a, b) => {
        const aGen = (a.key === side);
        const bGen = (b.key === side);
        if (aGen && !bGen) return -1;
        if (!aGen && bGen) return 1;
        return a.name.localeCompare(b.name, "ja");
      });
      selectEl.innerHTML = "";
      list.forEach(a => {
        const opt = document.createElement("option");
        opt.value = a.key;
        opt.textContent = a.name;
        selectEl.appendChild(opt);
      });
    }

    function updateNameOptionsForAlliance(allianceKey, currentName) {
      const alliance = allianceMap[allianceKey];
      dlgName.innerHTML = "";
      if (!alliance) return;
      // 同盟ごとの使用済み基地名だけをチェック
      const used = new Set(
        bases.filter(b => b.allianceKey === allianceKey).map(b => b.name)
      );
      alliance.members.forEach(function(name) {
        if (dialogMode === "edit" && name === currentName) {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          dlgName.appendChild(opt);
        } else if (!used.has(name)) {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          dlgName.appendChild(opt);
        }
      });
      if (dlgName.options.length === 0) {
        const opt = document.createElement("option");
        opt.value = currentName || "";
        opt.textContent = currentName || "(空き基地名なし)";
        dlgName.appendChild(opt);
      }
    }

    dlgSide.addEventListener("change", function() {
      const side = dlgSide.value;
      fillAllianceSelect(dlgAlliance, side);
      // デフォルトは side と同じキー（ALLY/ENEMY）を優先
      let defKey = side;
      let found = false;
      for (let i = 0; i < dlgAlliance.options.length; i++) {
        if (dlgAlliance.options[i].value === defKey) {
          dlgAlliance.value = defKey;
          found = true;
          break;
        }
      }
      if (!found && dlgAlliance.options.length) {
        dlgAlliance.value = dlgAlliance.options[0].value;
      }
      const currentName = dialogEditingBase ? dialogEditingBase.name : null;
      updateNameOptionsForAlliance(dlgAlliance.value, currentName);
    });

    dlgAlliance.addEventListener("change", function() {
      const key = dlgAlliance.value;
      const currentName = dialogEditingBase ? dialogEditingBase.name : null;
      updateNameOptionsForAlliance(key, currentName);
    });

    function openBaseDialogForCreate(cell) {
      dialogMode = "create";
      dialogCell = cell;
      dialogEditingBase = null;
      dlgDelete.style.display = "none";

      dlgSide.value = "ALLY";
      fillAllianceSelect(dlgAlliance, "ALLY");
      // 所属同盟デフォルトは「味方」
      if ([...dlgAlliance.options].some(o => o.value === "ALLY")) {
        dlgAlliance.value = "ALLY";
      } else if (dlgAlliance.options.length) {
        dlgAlliance.value = dlgAlliance.options[0].value;
      }
      updateNameOptionsForAlliance(dlgAlliance.value, null);

      dlgTeam.value = "";          // デフォルト「なし」
      dlgStatus.value = "参加";    // デフォルト参加
      dlgLevel.value = "27";       // デフォルトLv.27
      dlgTier.value = "T9";        // デフォルトT9
      dlgMemo.value = "";

      dlgCoordText.textContent = "配置セル: X" + cell.x + " Y" + cell.y;
      baseDialog.style.display = "flex";
    }

    function openBaseDialogForEdit(base) {
      dialogMode = "edit";
      dialogEditingBase = base;
      dialogCell = base.anchor;
      dlgDelete.style.display = "inline-block";

      dlgSide.value = base.side || "ALLY";
      fillAllianceSelect(dlgAlliance, dlgSide.value);
      dlgAlliance.value = base.allianceKey || "B777";
      updateNameOptionsForAlliance(base.allianceKey || "B777", base.name);
      dlgName.value = base.name;
      dlgTeam.value = base.team || "";
      dlgStatus.value = base.status || "不明";
      if (base.level != null) dlgLevel.value = String(base.level);
      dlgTier.value = base.tier || "T1";
      dlgMemo.value = base.memo || "";

      dlgCoordText.textContent = "配置セル: X" + base.anchor.x + " Y" + base.anchor.y;
      baseDialog.style.display = "flex";
    }

    function closeBaseDialog() {
      baseDialog.style.display = "none";
      dialogCell = null;
      dialogEditingBase = null;
    }

    dlgCancel.addEventListener("click", function() {
      closeBaseDialog();
    });

    dlgDelete.addEventListener("click", function() {
      if (!dialogEditingBase) return;
      if (confirm("基地「" + dialogEditingBase.name + "」を削除しますか？")) {
        deleteBaseById(dialogEditingBase.id);
        closeBaseDialog();
      }
    });

    dlgOk.addEventListener("click", function() {
      const side = dlgSide.value;
      const allianceKey = dlgAlliance.value;
      const alliance = allianceMap[allianceKey] || ALLIANCES[0];
      const name = dlgName.value || "基地";
      const team = dlgTeam.value || "";
      const status = dlgStatus.value || "不明";
      const level = Number(dlgLevel.value || "0");
      const tier = dlgTier.value || "T1";
      const memo = dlgMemo.value || "";

      if (!dialogCell) {
        closeBaseDialog();
        return;
      }
      const gx = dialogCell.x;
      const gy = dialogCell.y;

      if (dialogMode === "create") {
        const cells = createBaseCellsForAnchor(gx, gy, null);
        if (!cells) {
          alert("この位置には基地を配置できません。");
          return;
        }
        const id = Date.now().toString(36) + Math.random().toString(36).slice(2,7);
        bases.push({
          id: id,
          side: side,
          allianceKey: alliance.key,
          name: name,
          team: team,
          status: status,
          level: isNaN(level) ? null : level,
          tier: tier,
          memo: memo,
          cells: cells,
          anchor: { x: gx, y: gy }
        });
      } else if (dialogMode === "edit" && dialogEditingBase) {
        const cells = createBaseCellsForAnchor(gx, gy, dialogEditingBase.id);
        if (!cells) {
          alert("この位置には基地を配置できません。");
          return;
        }
        dialogEditingBase.side = side;
        dialogEditingBase.allianceKey = alliance.key;
        dialogEditingBase.name = name;
        dialogEditingBase.team = team;
        dialogEditingBase.status = status;
        dialogEditingBase.level = isNaN(level) ? null : level;
        dialogEditingBase.tier = tier;
        dialogEditingBase.memo = memo;
        dialogEditingBase.cells = cells;
        dialogEditingBase.anchor = { x: gx, y: gy };
      }

      saveBases();
      updateBaseListUI();
      updateTotals();
      draw();
      closeBaseDialog();
    });

    // --- Tile dialog handlers ---
    function openTileDialogForCreate(cell) {
      tileDialogMode = "create";
      tileDialogCell = cell;
      tileEditing = null;
      tileDelete.style.display = "none";
      tileNameInput.value = "資源";
      tileCoordText.textContent = "配置セル: X" + cell.x + " Y" + cell.y;
      tileDialog.style.display = "flex";
    }

    function openTileDialogForEdit(tile) {
      tileDialogMode = "edit";
      tileEditing = tile;
      tileDialogCell = { x: tile.x, y: tile.y };
      tileDelete.style.display = "inline-block";
      tileNameInput.value = tile.name || "資源";
      tileCoordText.textContent = "配置セル: X" + tile.x + " Y" + tile.y;
      tileDialog.style.display = "flex";
    }

    function closeTileDialog() {
      tileDialog.style.display = "none";
      tileDialogCell = null;
      tileEditing = null;
    }

    tileCancel.addEventListener("click", closeTileDialog);

    tileDelete.addEventListener("click", function() {
      if (!tileEditing) return;
      if (!confirm("タイル「" + (tileEditing.name || "資源") + "」を削除しますか？")) return;
      const idx = tiles.findIndex(t => t.id === tileEditing.id);
      if (idx !== -1) tiles.splice(idx, 1);
      saveBases();
      draw();
      closeTileDialog();
    });

    tileOk.addEventListener("click", function() {
      if (!tileDialogCell) return;

      const gx = tileDialogCell.x;
      const gy = tileDialogCell.y;

      // blocked は不可
      if (isBlockedCell(gx, gy)) {
        alert("この位置にはタイルを配置できません。");
        return;
      }
      // 基地セルと重なるのは不可
      if (findBaseAtCell(gx, gy)) {
        alert("この位置には基地があるため、タイルを配置できません。");
        return;
      }

      const name = (tileNameInput.value || "資源").trim() || "資源";

      if (tileDialogMode === "create") {
        if (findTileAtCell(gx, gy)) {
          alert("この位置には既にタイルがあります。");
          return;
        }
        tiles.push({
          id: Date.now().toString(36) + Math.random().toString(36).slice(2,7),
          x: gx, y: gy,
          name
        });
      } else if (tileDialogMode === "edit" && tileEditing) {
        tileEditing.name = name;
      }

      saveBases();
      draw();
      closeTileDialog();
    });

    function focusOnBase(b) {
      const rect = canvas.getBoundingClientRect();
      const world = gridToWorld(b.anchor.x, b.anchor.y);
      offsetX = rect.width / 2 - world.x * scale;
      offsetY = rect.height / 2 - world.y * scale;
      draw();
    }

    function updateBaseListUI() {
      baseListEl.innerHTML = "";
      const sortKey = sortKeySel.value;

      const sorted = bases.slice().sort(function(a, b) {
        if (sortKey === "alliance") {
          const aa = (allianceMap[a.allianceKey] && allianceMap[a.allianceKey].name) || a.allianceKey;
          const bb = (allianceMap[b.allianceKey] && allianceMap[b.allianceKey].name) || b.allianceKey;
          return aa.localeCompare(bb, "ja");
        } else if (sortKey === "name") {
          return (a.name || "").localeCompare(b.name || "", "ja");
        } else if (sortKey === "level") {
          const la = a.level || 0;
          const lb = b.level || 0;
          if (la !== lb) return lb - la;
          return (a.name || "").localeCompare(b.name || "", "ja");
        } else if (sortKey === "tier") {
          const ta = parseInt((a.tier || "T1").slice(1), 10) || 1;
          const tb = parseInt((b.tier || "T1").slice(1), 10) || 1;
          if (ta !== tb) return tb - ta;
          return (a.name || "").localeCompare(b.name || "", "ja");
        } else if (sortKey === "team") {
          return (a.team || "").localeCompare(b.team || "", "ja");
        }
        return 0;
      });

      sorted.forEach(function(b) {
        const li = document.createElement("li");
        li.className = "base-item";
        if (b.id === selectedBaseId) {
          li.classList.add("selected");
        }
        if (!isBaseMatchFilter(b)) {
          li.classList.add("dimmed");
        }

        const alliance = allianceMap[b.allianceKey] || ALLIANCES[0];
        const baseColor = getBaseColor(b);

        const dot = document.createElement("div");
        dot.className = "base-color-dot";
        dot.style.background = baseColor;

        const info = document.createElement("div");
        info.className = "base-item-info";

        const nameRow = document.createElement("div");
        nameRow.className = "base-item-name-row";

        const nameSpan = document.createElement("span");
        nameSpan.className = "base-name";
        nameSpan.textContent = b.name;

        const allianceSpan = document.createElement("span");
        allianceSpan.className = "base-alliance";
        allianceSpan.textContent = (b.side === "ALLY" ? "味方" : "敵") + " / " + alliance.name;

        nameRow.appendChild(nameSpan);
        nameRow.appendChild(allianceSpan);

        const metaRow = document.createElement("div");
        metaRow.className = "base-item-meta-row";

        const coordSpan = document.createElement("span");
        coordSpan.className = "base-coord";
        coordSpan.textContent = "X" + b.anchor.x + " Y" + b.anchor.y;

        const tagSpan = document.createElement("span");
        tagSpan.className = "base-tagline";
        const lv = b.level != null ? "Lv." + b.level : "Lv.-";
        const teamLabel = b.team ? b.team : "チームなし";
        tagSpan.textContent = b.status + " " + b.tier + " " + lv + " / " + teamLabel;

        metaRow.appendChild(coordSpan);
        metaRow.appendChild(tagSpan);

        info.appendChild(nameRow);
        info.appendChild(metaRow);

        li.appendChild(dot);
        li.appendChild(info);

        li.addEventListener("click", function() {
          selectedBaseId = b.id;
          selectedCell = { x: b.anchor.x, y: b.anchor.y }; // 自動配置の基準にもなる
          focusOnBase(b);
          updateBaseListUI();
        });
        li.addEventListener("dblclick", function(e) {
          e.stopPropagation();
          selectedBaseId = b.id;
          openBaseDialogForEdit(b);
        });

        baseListEl.appendChild(li);
      });
    }

    function updateTotals() {
      const list = getFilteredBases();
      const total = list.length;
      let allyCount = 0;
      let enemyCount = 0;
      const teamCounts = { "首都": 0, "砲台": 0, "援護": 0, "": 0 };
      const statusCounts = { "参加": 0, "不参加": 0, "不明": 0 };
      const lvCounts = {};
      const tCounts = {};

      list.forEach(function(b) {
        if (b.side === "ALLY") allyCount++;
        else if (b.side === "ENEMY") enemyCount++;

        teamCounts[b.team || ""] = (teamCounts[b.team || ""] || 0) + 1;
        statusCounts[b.status || "不明"] = (statusCounts[b.status || "不明"] || 0) + 1;
        if (b.level != null) {
          lvCounts[b.level] = (lvCounts[b.level] || 0) + 1;
        }
        if (b.tier) {
          const tnum = parseInt(b.tier.slice(1), 10);
          if (!isNaN(tnum)) {
            tCounts[tnum] = (tCounts[tnum] || 0) + 1;
          }
        }
      });

      const teamParts = [];
      if (teamCounts["首都"]) teamParts.push("首都 " + teamCounts["首都"]);
      if (teamCounts["砲台"]) teamParts.push("砲台 " + teamCounts["砲台"]);
      if (teamCounts["援護"]) teamParts.push("援護 " + teamCounts["援護"]);
      if (teamCounts[""] && teamCounts[""] > 0) teamParts.push("なし " + teamCounts[""]);

      const statusParts = [];
      if (statusCounts["参加"]) statusParts.push("参加 " + statusCounts["参加"]);
      if (statusCounts["不参加"]) statusParts.push("不参加 " + statusCounts["不参加"]);
      if (statusCounts["不明"]) statusParts.push("不明 " + statusCounts["不明"]);

      const lvParts = [];
      Object.keys(lvCounts)
        .map(x => parseInt(x, 10))
        .sort((a, b) => b - a)
        .forEach(lv => {
          lvParts.push("Lv." + lv + " " + lvCounts[lv]);
        });

      const tParts = [];
      Object.keys(tCounts)
        .map(x => parseInt(x, 10))
        .sort((a, b) => b - a)
        .forEach(tn => {
          tParts.push("T" + tn + " " + tCounts[tn]);
        });

      let html = "総数 " + total + " / 味方 " + allyCount + " / 敵 " + enemyCount;
      if (teamParts.length) html += "<br>チーム " + teamParts.join(" / ");
      if (statusParts.length) html += "<br>状態 " + statusParts.join(" / ");
      if (lvParts.length) html += "<br>Lv.内訳 " + lvParts.join(" / ");
      if (tParts.length) html += "<br>T内訳 " + tParts.join(" / ");
      sidebarTotalsEl.innerHTML = html;
    }

    function drawRoundedRect(ctx2, x, y, w, h, r) {
      const radius = Math.min(r, w / 2, h / 2);
      ctx2.beginPath();
      ctx2.moveTo(x + radius, y);
      ctx2.lineTo(x + w - radius, y);
      ctx2.quadraticCurveTo(x + w, y, x + w, y + radius);
      ctx2.lineTo(x + w, y + h - radius);
      ctx2.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
      ctx2.lineTo(x + radius, y + h);
      ctx2.quadraticCurveTo(x, y + h, x, y + h - radius);
      ctx2.lineTo(x, y + radius);
      ctx2.quadraticCurveTo(x, y, x + radius, y);
      ctx2.closePath();
    }

    function hexToRgba(hex, alpha) {
      let c = hex.replace("#", "");
      if (c.length === 3) {
        c = c.split("").map(ch => ch + ch).join("");
      }
      const r = parseInt(c.slice(0, 2), 16);
      const g = parseInt(c.slice(2, 4), 16);
      const b = parseInt(c.slice(4, 6), 16);
      return "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
    }

    function drawHexCenter(wx, wy, strokeStyle, fillStyle, lineWidth) {
      const sPos = worldToScreen(wx, wy);
      const s = HEX_SIZE * scale;
      const w = Math.sqrt(3) * s;
      const h = s;

      const pts = [
        { x: sPos.x,       y: sPos.y - h },
        { x: sPos.x + w/2, y: sPos.y - h/2 },
        { x: sPos.x + w/2, y: sPos.y + h/2 },
        { x: sPos.x,       y: sPos.y + h },
        { x: sPos.x - w/2, y: sPos.y + h/2 },
        { x: sPos.x - w/2, y: sPos.y - h/2 }
      ];

      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) {
        ctx.lineTo(pts[i].x, pts[i].y);
      }
      ctx.closePath();

      if (fillStyle) {
        ctx.fillStyle = fillStyle;
        ctx.fill();
      }
      if (strokeStyle) {
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = lineWidth;
        ctx.stroke();
      }
    }

    function drawGrid() {
      const rect = canvas.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;
      const margin = 80 / scale;
      const topLeftWorld = screenToWorld(-margin, -margin);
      const bottomRightWorld = screenToWorld(w + margin, h + margin);

      let gyMin = Math.floor(topLeftWorld.y / HEX_VERT_SPACING) - 2;
      let gyMax = Math.ceil(bottomRightWorld.y / HEX_VERT_SPACING) + 2;
      gyMin = Math.max(VIEW_MIN_Y, Math.max(0, gyMin));
      gyMax = Math.min(VIEW_MAX_Y, Math.min(GRID_MAX_Y, gyMax));

      for (let gy = gyMin; gy <= gyMax; gy++) {
        const rowOffset = (gy & 1) ? HEX_HORIZ_SPACING * 0.5 : 0;

        let gxMin = Math.floor((topLeftWorld.x - rowOffset) / HEX_HORIZ_SPACING) - 2;
        let gxMax = Math.ceil((bottomRightWorld.x - rowOffset) / HEX_HORIZ_SPACING) + 2;
        gxMin = Math.max(VIEW_MIN_X, Math.max(0, gxMin));
        gxMax = Math.min(VIEW_MAX_X, Math.min(GRID_MAX_X, gxMax));

        for (let gx = gxMin; gx <= gxMax; gx++) {
          const world = gridToWorld(gx, gy);
          const center = world;

          const isSelected =
            selectedCell && selectedCell.x === gx && selectedCell.y === gy;

          const desertIn = pointInPolygon(center, desertPolygonWorld);
          const desertDist = distanceToPolygonEdges(center, desertPolygonWorld);
          const inDesert = desertIn || desertDist <= EDGE_THICKNESS_WORLD;

          const blkIn = pointInPolygon(center, blockedPolygonWorld);
          const blkDist = distanceToPolygonEdges(center, blockedPolygonWorld);
          const inBlockedPolygon = blkIn || blkDist <= EDGE_THICKNESS_WORLD;

          let inExtraBlocked = false;
          for (let i = 0; i < extraBlockedCells.length; i++) {
            const c = extraBlockedCells[i];
            if (gx === c.x && gy === c.y) { inExtraBlocked = true; break; }
          }
          const inBlocked = inBlockedPolygon || inExtraBlocked;

          const tileAt = findTileAtCell(gx, gy);
          const baseAt = findBaseAtCell(gx, gy);
          const match = baseAt ? isBaseMatchFilter(baseAt) : false;

          let stroke, fill, lw;
          if (isSelected) {
            stroke = "rgba(255,221,85,0.7)";
            fill   = "rgba(255,221,85,0.15)";
            lw = 1.6;
          } else if (inBlocked) {
            stroke = "rgba(255,80,80,0.7)";
            fill   = "rgba(255,80,80,0.22)";
            lw = 1.2;
          } else if (tileAt) {
            // タイル：1マス資源（基地一覧には出さない）
            stroke = "rgba(120,200,255,0.85)";
            fill   = "rgba(120,200,255,0.22)";
            lw = 1.3;
          } else if (baseAt) {
            const baseColor = getBaseColor(baseAt);
            let alphaFill = 0.25;
            if (baseAt.status === "参加") alphaFill = 0.34;
            else if (baseAt.status === "不参加") alphaFill = 0.22;

            if (match) {
              stroke = hexToRgba(baseColor, 0.95);
              fill   = hexToRgba(baseColor, alphaFill);
            } else {
              stroke = hexToRgba(baseColor, 0.3);
              fill   = hexToRgba(baseColor, alphaFill * 0.15);
            }
            lw = match ? 1.5 : 1.0;
          } else {
            stroke = inDesert
              ? "rgba(235,220,150,0.12)"
              : "rgba(210,255,210,0.10)";
            fill = null;
            lw = 0.7;
          }

          drawHexCenter(world.x, world.y, stroke, fill, lw);
        }
      }
    }

    function drawDesertOutline() {
      ctx.beginPath();
      desertPolygonWorld.forEach(function(p, i) {
        const s = worldToScreen(p.x, p.y);
        if (i === 0) ctx.moveTo(s.x, s.y);
        else ctx.lineTo(s.x, s.y);
      });
      ctx.closePath();
      ctx.strokeStyle = "rgba(230,210,120,0.8)";
      ctx.lineWidth = 1.2;
      ctx.stroke();
    }

    function drawBlockedOutline() {
      ctx.beginPath();
      blockedPolygonWorld.forEach(function(p, i) {
        const s = worldToScreen(p.x, p.y);
        if (i === 0) ctx.moveTo(s.x, s.y);
        else ctx.lineTo(s.x, s.y);
      });
      ctx.closePath();
      ctx.strokeStyle = "rgba(255,80,80,0.75)";
      ctx.lineWidth = 1.2;
      ctx.stroke();
    }

    function drawRegionLabels() {
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.textAlign = "center";

      let cx = 0;
      let cy = 0;
      desertVerticesGrid.forEach(function(v) { cx += v.x; cy += v.y; });
      cx /= desertVerticesGrid.length;
      cy /= desertVerticesGrid.length;
      const desertW = gridToWorld(cx, cy);
      const desertS = worldToScreen(desertW.x, desertW.y);

      let fontSize = Math.max(12, Math.min(24, 15 * scale * 2.5));
      ctx.font = fontSize + "px system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif";
      ctx.textBaseline = "middle";
      ctx.fillText("砂漠エリア", desertS.x, desertS.y);

      const grassW = gridToWorld(500, 550);
      const grassS = worldToScreen(grassW.x, grassW.y);
      ctx.fillStyle = "rgba(200,255,200,0.85)";
      ctx.fillText("芝生エリア", grassS.x, grassS.y);

      const fixedLabels = [
        { x: 500, y: 500, text: "配置不可エリア" },
        { x: 517, y: 500, text: "砲台3号" },
        { x: 491, y: 483, text: "砲台2号" },
        { x: 491, y: 517, text: "砲台1号" }
      ];

      fontSize = Math.max(10, Math.min(20, 13 * scale * 2));
      ctx.font = fontSize + "px system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif";
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.textBaseline = "top";

      fixedLabels.forEach(function(obj) {
        const w = gridToWorld(obj.x, obj.y);
        const s = worldToScreen(w.x, w.y);
        const offset = HEX_SIZE * scale * 1.3;
        ctx.fillText(obj.text, s.x, s.y + offset);
      });

      ctx.restore();
    }

    function drawBaseLabels() {
      if (!showBasePopups) return;
      ctx.save();

      bases.forEach(function(b) {
        const anchor = b.anchor || b.cells[0];
        const world = gridToWorld(anchor.x, anchor.y);
        const screen = worldToScreen(world.x, world.y);
        const match = isBaseMatchFilter(b);

        const alliance = allianceMap[b.allianceKey] || ALLIANCES[0];
        const nameText = b.name;
        const statusText = b.status || "不明";
        const levelText = b.level != null ? "Lv." + b.level : "Lv.-";
        const tierText = b.tier || "T1";
        const statusLine = statusText + " " + tierText + " " + levelText;
        const coordText = "X" + anchor.x + " Y" + anchor.y;

        const baseFontSize = Math.max(6, Math.min(12, 10 * scale * 2.0));
        const lineHeight = baseFontSize * 1.05;

        ctx.font = baseFontSize + "px system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif";

        const nameWidth = ctx.measureText(nameText).width;
        const statusWidth = ctx.measureText(statusLine).width;
        const coordWidth = ctx.measureText(coordText).width;
        const textWidth = Math.max(nameWidth, statusWidth, coordWidth);

        const iconSize = lineHeight * 1.8;
        const paddingX = 4 * scale * 1.5;
        const paddingY = 3 * scale * 1.5;

        const panelWidth = Math.max(textWidth, iconSize) + paddingX * 2;
        const panelHeight = paddingY * 2 + iconSize + 4 + lineHeight * 3;
        const offsetAboveHex = HEX_SIZE * scale * 1.6;

        const panelX = screen.x - panelWidth / 2;
        const panelY = screen.y - offsetAboveHex - panelHeight;

        ctx.globalAlpha = match ? 0.9 : 0.3;
        ctx.fillStyle = "rgba(0,0,0,0.75)";
        drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 6);
        ctx.fill();
        ctx.globalAlpha = match ? 1.0 : 0.5;
        ctx.strokeStyle = "rgba(255,255,255,0.12)";
        ctx.lineWidth = 1;
        drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 6);
        ctx.stroke();

        const baseColor = getBaseColor(b);

        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        let cursorY = panelY + paddingY;

        const iconX = screen.x - iconSize / 2;
        const iconY = cursorY;
        ctx.fillStyle = baseColor;
        drawRoundedRect(ctx, iconX, iconY, iconSize, iconSize, 4);
        ctx.fill();

        ctx.fillStyle = "#001010";
        if (b.side === "ENEMY") ctx.fillStyle = "#330000";
        ctx.font = baseFontSize + "px system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif";
        ctx.fillText(alliance.name, screen.x, iconY + iconSize / 2);

        cursorY += iconSize + 4;

        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.font = baseFontSize + "px system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif";

        ctx.fillStyle = "rgba(255,255,255,0.96)";
        ctx.fillText(nameText, screen.x, cursorY);
        cursorY += lineHeight;

        ctx.fillStyle =
          statusText === "参加" ? "rgba(150,255,190,0.96)" :
          statusText === "不参加" ? "rgba(255,170,170,0.96)" :
          "rgba(255,230,170,0.96)";
        ctx.fillText(statusLine, screen.x, cursorY);
        cursorY += lineHeight;

        ctx.fillStyle = "rgba(210,230,255,0.96)";
        ctx.fillText(coordText, screen.x, cursorY);
      });

      ctx.restore();
    }

    function drawMemoLabels() {
      if (!showMemoPopups) return;
      ctx.save();

      bases.forEach(function(b) {
        if (!b.memo) return;
        const anchor = b.anchor || b.cells[0];
        const world = gridToWorld(anchor.x, anchor.y);
        const screen = worldToScreen(world.x, world.y);
        const match = isBaseMatchFilter(b);

        const memoText = b.memo;
        const fontSize = Math.max(10, Math.min(18, 14 * scale * 2.0));
        ctx.font = fontSize + "px system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif";

        const textWidth = ctx.measureText(memoText).width;
        const paddingX = 6 * scale * 1.5;
        const paddingY = 4 * scale * 1.5;

        const panelWidth = textWidth + paddingX * 2;
        const panelHeight = fontSize + paddingY * 2;

        const offsetBelow = HEX_SIZE * scale * 1.6;
        const panelX = screen.x - panelWidth / 2;
        const panelY = screen.y + offsetBelow;

        ctx.globalAlpha = match ? 0.95 : 0.4;
        ctx.fillStyle = "rgba(20,20,20,0.9)";
        drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 6);
        ctx.fill();
        ctx.globalAlpha = match ? 1.0 : 0.5;
        ctx.strokeStyle = "rgba(255,255,255,0.25)";
        ctx.lineWidth = 1;
        drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 6);
        ctx.stroke();

        ctx.fillStyle = "rgba(255,255,255,0.98)";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(memoText, screen.x, panelY + panelHeight / 2);
      });

      ctx.restore();
    }

    function drawTileLabels() {
      // タイルは一覧に出さないが、マップ上で名前だけ出したい場合はここで描ける（今は控えめにオフ）
      // 必要なら true にして使ってOK
      const SHOW_TILE_NAME = false;
      if (!SHOW_TILE_NAME) return;

      ctx.save();
      tiles.forEach(t => {
        const w = gridToWorld(t.x, t.y);
        const s = worldToScreen(w.x, w.y);
        const fontSize = Math.max(10, Math.min(18, 12 * scale * 2.0));
        ctx.font = fontSize + "px system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif";
        ctx.fillStyle = "rgba(180,230,255,0.95)";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(t.name || "資源", s.x, s.y);
      });
      ctx.restore();
    }

    function draw() {
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0, 0, rect.width, rect.height);

      drawGrid();
      drawDesertOutline();
      drawBlockedOutline();
      drawRegionLabels();
      drawBaseLabels();
      drawMemoLabels();
      drawTileLabels();

      zoomDisplay.textContent = Math.round(scale * 100) + "%";
      cellDisplay.textContent = selectedCell
        ? "X" + selectedCell.x + " Y" + selectedCell.y
        : "—";
    }

    function handleCellDoubleAction(cell) {
      const base = findBaseAtCell(cell.x, cell.y);
      if (base) {
        selectedBaseId = base.id;
        openBaseDialogForEdit(base);
        return;
      }

      const tile = findTileAtCell(cell.x, cell.y);
      if (tile) {
        openTileDialogForEdit(tile);
        return;
      }

      // 空きマス：基地 or タイルを選択（OK:基地 / Cancel:タイル）
      const choice = confirm("基地を追加しますか？\nOK: 基地 / キャンセル: タイル");
      if (choice) openBaseDialogForCreate(cell);
      else openTileDialogForCreate(cell);
    }

    function zoomAt(mx, my, zoomDelta) {
      let newScale = scale + zoomDelta * scale;
      newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
      if (newScale === scale) return;
      const worldBefore = screenToWorld(mx, my);
      scale = newScale;
      const worldAfter = screenToWorld(mx, my);
      offsetX += (worldAfter.x - worldBefore.x) * scale;
      offsetY += (worldAfter.y - worldBefore.y) * scale;
      draw();
    }

    // 六角距離（自動配置の中心からの距離）
    function hexDistance(cellA, cellB) {
      const a = oddrToAxial(cellA.x, cellA.y);
      const b = oddrToAxial(cellB.x, cellB.y);
      const dq = a.q - b.q;
      const dr = a.r - b.r;
      const ds = -dq - dr;
      return Math.max(Math.abs(dq), Math.abs(dr), Math.abs(ds));
    }

    // イベント類
    canvas.addEventListener("mousedown", function(e) {
      if (e.button !== 0) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;

      const base = findBaseAtCell(cell.x, cell.y);
      if (base) {
        draggingBaseId = base.id;
        lastDragCell = cell;
      } else {
        isPanning = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      }
      canvas.classList.add("dragging");
      draw();
    });

    window.addEventListener("mousemove", function(e) {
      if (draggingBaseId) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const cell = screenToGrid(mx, my);
        if (!lastDragCell || cell.x !== lastDragCell.x || cell.y !== lastDragCell.y) {
          moveBaseToGrid(draggingBaseId, cell.x, cell.y);
          lastDragCell = cell;
        }
        return;
      }
      if (!isPanning) return;
      const dx = e.clientX - lastMouseX;
      const dy = e.clientY - lastMouseY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      offsetX += dx;
      offsetY += dy;
      draw();
    });

    window.addEventListener("mouseup", function() {
      isPanning = false;
      draggingBaseId = null;
      lastDragCell = null;
      canvas.classList.remove("dragging");
    });

    canvas.addEventListener("wheel", function(e) {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      zoomAt(mx, my, delta);
    }, { passive: false });

    canvas.addEventListener("click", function(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;
      draw();
    });

    canvas.addEventListener("dblclick", function(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;
      handleCellDoubleAction(cell);
    });

    // スマホ：ズームボタンでのダブルタップ拡大を抑制（touchstartで処理）
    zoomInBtn.addEventListener("touchstart", function(e) {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      zoomAt(rect.width / 2, rect.height / 2, 0.2);
    }, { passive: false });
    zoomOutBtn.addEventListener("touchstart", function(e) {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      zoomAt(rect.width / 2, rect.height / 2, -0.2);
    }, { passive: false });

    // PCは普通にclick
    zoomInBtn.addEventListener("click", function(e) {
      const rect = canvas.getBoundingClientRect();
      zoomAt(rect.width / 2, rect.height / 2, 0.2);
    });
    zoomOutBtn.addEventListener("click", function(e) {
      const rect = canvas.getBoundingClientRect();
      zoomAt(rect.width / 2, rect.height / 2, -0.2);
    });

    canvas.addEventListener("touchstart", function(e) {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mx = t.clientX - rect.left;
      const my = t.clientY - rect.top;

      touchStartX = t.clientX;
      touchStartY = t.clientY;

      const cell = screenToGrid(mx, my);
      selectedCell = cell;

      const base = findBaseAtCell(cell.x, cell.y);
      if (base) {
        draggingBaseId = base.id;
        lastDragCell = cell;
      } else {
        isPanning = true;
        lastMouseX = t.clientX;
        lastMouseY = t.clientY;
      }
      canvas.classList.add("dragging");
      draw();
    }, { passive: true });

    canvas.addEventListener("touchmove", function(e) {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];

      if (draggingBaseId) {
        const rect = canvas.getBoundingClientRect();
        const mx = t.clientX - rect.left;
        const my = t.clientY - rect.top;
        const cell = screenToGrid(mx, my);
        if (!lastDragCell || cell.x !== lastDragCell.x || cell.y !== lastDragCell.y) {
          moveBaseToGrid(draggingBaseId, cell.x, cell.y);
          lastDragCell = cell;
        }
        return;
      }

      if (!isPanning) return;
      const dx = t.clientX - lastMouseX;
      const dy = t.clientY - lastMouseY;
      lastMouseX = t.clientX;
      lastMouseY = t.clientY;
      offsetX += dx;
      offsetY += dy;
      draw();
    }, { passive: true });

    window.addEventListener("touchend", function(e) {
      const now = Date.now();
      const rect = canvas.getBoundingClientRect();

      if (e.changedTouches && e.changedTouches.length === 1) {
        const t = e.changedTouches[0];
        const moveDist = Math.hypot(t.clientX - touchStartX, t.clientY - touchStartY);
        if (moveDist < TAP_MAX_MOVE) {
          const mx = t.clientX - rect.left;
          const my = t.clientY - rect.top;
          const cell = screenToGrid(mx, my);

          if (
            lastTapCell &&
            now - lastTapTime < TAP_MAX_DELAY &&
            lastTapCell.x === cell.x &&
            lastTapCell.y === cell.y
          ) {
            // ダブルタップ → 基地/タイルの追加/編集（ページ拡大にはさせない）
            handleCellDoubleAction(cell);
            lastTapTime = 0;
            lastTapCell = null;
          } else {
            lastTapTime = now;
            lastTapCell = cell;
          }
        }
      }

      isPanning = false;
      draggingBaseId = null;
      lastDragCell = null;
      canvas.classList.remove("dragging");
    });

    toggleSidebarBtn.addEventListener("click", function(e) {
      e.stopPropagation();
      if (window.innerWidth > 768) {
        // PC: サイドバー全体を折りたたみ
        sidebarEl.classList.toggle("collapsed");
        toggleSidebarBtn.textContent = sidebarEl.classList.contains("collapsed") ? "＋" : "－";
      } else {
        // スマホ: リスト・合計・説明を表示/非表示
        sidebarEl.classList.toggle("info-hidden");
        toggleSidebarBtn.textContent = sidebarEl.classList.contains("info-hidden") ? "＋" : "－";
      }
    });

    copyBtn.addEventListener("click", async function() {
      const list = getFilteredBases();
      if (list.length === 0) {
        alert("コピーする基地がありません。");
        return;
      }
      const lines = list.map(function(b) {
        const alliance = allianceMap[b.allianceKey] || ALLIANCES[0];
        return alliance.name + "\t" + b.name + "\tX" + b.anchor.x + " Y" + b.anchor.y;
      });
      const text = lines.join("\n");
      try {
        await navigator.clipboard.writeText(text);
        alert("同盟・基地名・座標をコピーしました。");
      } catch (e) {
        console.warn(e);
        alert("クリップボードへのコピーに失敗しました。");
      }
    });

    clearBtn.addEventListener("click", function() {
      if (!bases.length && !tiles.length) {
        alert("削除する基地/タイルがありません。");
        return;
      }
      if (!confirm("全ての基地/タイルを一括削除しますか？")) return;
      bases.length = 0;
      tiles.length = 0;
      saveBases();
      updateBaseListUI();
      updateTotals();
      draw();
    });

    function moveBaseToGrid(baseId, gx, gy) {
      const base = bases.find(b => b.id === baseId);
      if (!base) return;
      const cells = createBaseCellsForAnchor(gx, gy, baseId);
      if (!cells) return;
      base.cells = cells;
      base.anchor = { x: gx, y: gy };
      saveBases();
      updateBaseListUI();
      updateTotals();
      draw();
    }

    // Auto 自動配置ダイアログ関連
    function openAutoDialog() {
      // デフォルト：味方 / チームなし / 配置数 50
      const side = "ALLY";
      autoSide.value = side;
      fillAllianceSelect(autoAlliance, side);
      if (autoAlliance.options.length) {
        autoAlliance.value = autoAlliance.options[0].value;
      }
      autoTeam.value = "";
      autoCount.value = "50";
      autoDialog.style.display = "flex";
    }

    function closeAutoDialog() {
      autoDialog.style.display = "none";
    }

    autoSide.addEventListener("change", function() {
      const side = autoSide.value;
      fillAllianceSelect(autoAlliance, side);
      if (autoAlliance.options.length) {
        autoAlliance.value = autoAlliance.options[0].value;
      }
    });

    autoCancel.addEventListener("click", function() {
      closeAutoDialog();
    });

    autoOk.addEventListener("click", function() {
      const side = autoSide.value;
      const allianceKey = autoAlliance.value;
      const alliance = allianceMap[allianceKey];
      if (!alliance) {
        alert("同盟の選択が不正です。");
        return;
      }

      let count = parseInt(autoCount.value, 10);
      if (isNaN(count) || count <= 0) {
        alert("配置数を正しく入力してください。");
        return;
      }
      if (count > 50) count = 50;

      const teamChoice = autoTeam.value || "";
      const normTeam =
        teamChoice === "首都" || teamChoice === "砲台" || teamChoice === "援護"
          ? teamChoice
          : "";

      // side セレクトと同盟の side が違う場合は同盟側を優先
      const finalAlliance = alliance;
      runAutoPlacement(finalAlliance, count, normTeam);
      closeAutoDialog();
    });

    autoBtn.addEventListener("click", function() {
      openAutoDialog();
    });

    // 自動配置本体（フォーカス中セルの周辺を優先・同盟メンバーを上から順番に使用）
    function runAutoPlacement(alliance, count, normTeam) {
      // この同盟で既に使われている名前を除外し、members の上から順に使用
      const usedNames = new Set(
        bases.filter(b => b.allianceKey === alliance.key).map(b => b.name)
      );
      const freeNames = alliance.members.filter(n => !usedNames.has(n));
      if (!freeNames.length) {
        alert("この同盟で新しく配置できる名前がありません。");
        return;
      }

      // フォーカス基準セル（selectedCell があればそれ、無ければ首都）
      const centerCell = selectedCell
        ? { x: selectedCell.x, y: selectedCell.y }
        : { x: CAPITAL_CENTER_X, y: CAPITAL_CENTER_Y };

      // 中心からの六角距離順に候補アンカーを作成
      const candidates = [];
      const MAX_RADIUS = 30; // 自動配置の探索半径
      for (let gy = VIEW_MIN_Y; gy <= VIEW_MAX_Y; gy++) {
        for (let gx = VIEW_MIN_X; gx <= VIEW_MAX_X; gx++) {
          const d = hexDistance({ x: gx, y: gy }, centerCell);
          if (d <= MAX_RADIUS) {
            candidates.push({ x: gx, y: gy, d });
          }
        }
      }
      candidates.sort((a, b) => {
        if (a.d !== b.d) return a.d - b.d;
        if (a.y !== b.y) return a.y - b.y;
        return a.x - b.x;
      });

      let placed = 0;
      let nameIndex = 0;

      for (let i = 0; i < candidates.length && placed < count && nameIndex < freeNames.length; i++) {
        const cell = candidates[i];
        const cells = createBaseCellsForAnchor(cell.x, cell.y, null);
        if (!cells) continue;

        const name = freeNames[nameIndex++];
        const id = Date.now().toString(36) + Math.random().toString(36).slice(2,7);
        bases.push({
          id: id,
          side: alliance.side,
          allianceKey: alliance.key,
          name: name,
          team: normTeam,
          status: "参加",
          level: 27,
          tier: "T9",
          memo: "",
          cells: cells,
          anchor: { x: cell.x, y: cell.y }
        });
        placed++;
      }

      if (!placed) {
        alert("自動配置できる空きスペースがありませんでした。");
      } else {
        saveBases();
        updateBaseListUI();
        updateTotals();
        draw();
      }
    }

    // 高DPI対応＆初期化
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      if (!resizeCanvas.initialized) {
        resizeCanvas.initialized = true;

        const midWorld = gridToWorld(CAPITAL_CENTER_X, CAPITAL_CENTER_Y);
        offsetX = rect.width / 2 - midWorld.x * scale;
        offsetY = rect.height / 2 - midWorld.y * scale;

        desertPolygonWorld = desertVerticesGrid.map(v => gridToWorld(v.x, v.y));
        blockedPolygonWorld = blockedVerticesGrid.map(v => gridToWorld(v.x, v.y));

        initDialogSelectors();
        loadBases();
        updateBaseListUI();
        updateTotals();

        if (window.innerWidth <= 768) {
          // モバイルでは最初は情報を畳んだ状態に
          sidebarEl.classList.add("info-hidden");
          toggleSidebarBtn.textContent = "＋";
        }
      }
      draw();
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
  </script>
</body>
</html>
