<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Hex Map (Desert & Grass + Bases / Firestore)</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      height: 100%;
      overflow: hidden;
      background: #050608;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5f5;
    }
    #map-canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: radial-gradient(circle at top, #1d2838 0, #050608 50%);
      cursor: grab;
    }
    #map-canvas.dragging { cursor: grabbing; }

    .hud {
      position: fixed;
      right: 10px;
      bottom: 10px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .75);
      backdrop-filter: blur(10px);
      font-size: 11px;
      display: flex;
      gap: 8px;
      align-items: center;
      pointer-events: none;
      z-index: 10;
    }
    .hud span.label { opacity: .6; }
    .hud span.value { font-variant-numeric: tabular-nums; }

    .hint {
      position: fixed;
      left: 10px;
      bottom: 10px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .75);
      backdrop-filter: blur(10px);
      font-size: 11px;
      opacity: .85;
      pointer-events: none;
      z-index: 10;
      max-width: 520px;
    }

    /* ã‚µã‚¤ãƒ‰ãƒãƒ¼ï¼ˆåŸºåœ°ãƒªã‚¹ãƒˆï¼‰ */
    .sidebar {
      position: fixed;
      left: 10px;
      top: 10px;
      width: 270px;
      padding: 10px;
      border-radius: 16px;
      background: rgba(5, 6, 8, 0.96);
      backdrop-filter: blur(16px);
      font-size: 12px;
      z-index: 20;
      pointer-events: auto;
      max-height: calc(100% - 20px);
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
      transition: max-height 0.2s ease, padding 0.2s ease;
    }
    .sidebar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      margin-bottom: 6px;
    }
    .sidebar-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      opacity: 0.85;
    }
    .sidebar-actions {
      display: flex;
      gap: 4px;
      flex-shrink: 0;
      align-items: center;
    }
    .sidebar-actions button {
      border: none;
      border-radius: 999px;
      padding: 2px 6px;
      font-size: 10px;
      cursor: pointer;
      background: rgba(255,255,255,0.14);
      color: #f5f5f5;
      white-space: nowrap;
    }
    .sidebar-actions button:hover {
      background: rgba(255,255,255,0.26);
    }

    /* æŠ˜ã‚ŠãŸãŸã¿ãƒœã‚¿ãƒ³ */
    #toggle-sidebar {
      font-weight: 700;
      padding: 2px 7px;
      min-width: 24px;
      text-align: center;
    }

    #base-list {
      list-style: none;
      margin: 0;
      padding: 0;
      overflow-y: auto;
      flex: 1;
    }
    .sidebar-note {
      margin-top: 6px;
      font-size: 10px;
      opacity: 0.75;
    }

    /* æŠ˜ã‚ŠãŸãŸã¿æ™‚ */
    .sidebar.collapsed {
      max-height: 48px;
      padding-bottom: 6px;
    }
    .sidebar.collapsed #base-list,
    .sidebar.collapsed .sidebar-note {
      display: none;
    }

    #base-list li.base-item {
      display: flex;
      gap: 6px;
      padding: 5px 6px;
      border-radius: 10px;
      background: rgba(255,255,255,0.06);
      margin-bottom: 4px;
      border: 1px solid rgba(255,255,255,0.12);
      align-items: center;
    }
    #base-list li.base-item:hover {
      background: rgba(255,255,255,0.10);
    }

    .base-item-thumb {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      background-color: rgba(255,255,255,0.08);
      background-size: cover;
      background-position: center;
      flex-shrink: 0;
      border: 1px solid rgba(255,255,255,0.3);
    }

    .base-item-info {
      flex: 1;
      min-width: 0;
    }
    .base-item-name-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 4px;
    }
    .base-name {
      font-size: 12px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .base-level {
      font-size: 11px;
      opacity: 0.9;
    }
    .base-item-meta-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 2px;
      gap: 4px;
    }
    .base-coord {
      font-size: 10px;
      opacity: 0.9;
    }
    .base-status {
      display: flex;
      gap: 2px;
    }
    .base-status button {
      border: none;
      border-radius: 999px;
      padding: 1px 5px;
      font-size: 10px;
      cursor: pointer;
      background: rgba(255,255,255,0.10);
      color: #f5f5f5;
      white-space: nowrap;
    }
    .base-status button.active[data-status="å‚åŠ "] {
      background: rgba(80, 220, 140, 0.95);
      color: #021108;
    }
    .base-status button.active[data-status="ä¸å‚åŠ "] {
      background: rgba(240, 90, 90, 0.95);
      color: #250202;
    }
    .base-status button.active[data-status="ä¸æ˜"] {
      background: rgba(255, 210, 90, 0.95);
      color: #251a02;
    }

    @media (max-width: 768px) {
      .hint {
        font-size: 10px;
        max-width: 90%;
      }
      .sidebar {
        width: calc(100% - 20px);
        left: 10px;
        right: 10px;
        top: 10px;
        max-height: 45%;
      }
      .sidebar-title {
        font-size: 10px;
      }
      .sidebar-actions button {
        font-size: 9px;
        padding: 2px 4px;
      }
    }
  </style>
</head>
<body>
  <canvas id="map-canvas"></canvas>

  <div class="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title">åŸºåœ°ä¸€è¦§ï¼ˆãƒªã‚¹ãƒˆè¡Œãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†ï¼‰</div>
      <div class="sidebar-actions">
        <button id="toggle-sidebar">ï¼</button>
        <button id="export-btn">EX</button>
        <button id="import-btn">IM</button>
        <input type="file" id="import-file" accept="application/json" style="display:none" />
      </div>
    </div>
    <ul id="base-list"></ul>
    <div class="sidebar-note">
      ãƒ»ãƒãƒƒãƒ—ï¼šç©ºããƒã‚¹ã‚’ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§åŸºåœ°è¿½åŠ  / åŸºåœ°ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹• / åŸºåœ°ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§åå‰å¤‰æ›´ or å‰Šé™¤<br>
      ãƒ»çŠ¶æ…‹ãƒ»ãƒ¬ãƒ™ãƒ«ãƒ»ã‚µãƒ ãƒã¯ Firestore ã«ä¿å­˜ã•ã‚Œã€å…¨ç«¯æœ«ã§å…±æœ‰ã•ã‚Œã¾ã™ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ã«ã‚‚ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¿å­˜ï¼‰<br>
      ãƒ»ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã§ JSON ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§èª­ã¿è¾¼ã¿
    </div>
  </div>

  <div class="hud">
    <span class="label">Zoom</span>
    <span class="value" id="zoom-display">100%</span>
    <span class="label">Cell</span>
    <span class="value" id="cell-display">â€”</span>
  </div>

  <div class="hint" id="hint-text">
    â€¦
  </div>

  <!-- Firebase + Firestore + ãƒãƒƒãƒ—å‡¦ç† -->
  <script type="module">
    // ===== Firebase SDK =====
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-analytics.js";
    import {
      getFirestore,
      doc,
      getDoc,
      setDoc,
      onSnapshot,
      serverTimestamp
    } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

    // --- Firebase è¨­å®š ---
    const firebaseConfig = {
      apiKey: "AIzaSyB_whPaNOu9Lw7i7-j14UgjFtwExB8aQvk",
      authDomain: "hex-map-project.firebaseapp.com",
      projectId: "hex-map-project",
      storageBucket: "hex-map-project.firebasestorage.app",
      messagingSenderId: "278586802948",
      appId: "1:278586802948:web:31e51f369382bb859d0651",
      measurementId: "G-NMY20PTQKM"
    };

    const firebaseApp = initializeApp(firebaseConfig);
    getAnalytics(firebaseApp);
    const db = getFirestore(firebaseApp);
    const mapDocRef = doc(db, "maps", "globalMap"); // å…±æœ‰ç”¨ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

    // ===== DOM å–å¾— =====
    const canvas = document.getElementById("map-canvas");
    const ctx = canvas.getContext("2d");
    const zoomDisplay = document.getElementById("zoom-display");
    const cellDisplay = document.getElementById("cell-display");
    const baseListEl = document.getElementById("base-list");
    const exportBtn = document.getElementById("export-btn");
    const importBtn = document.getElementById("import-btn");
    const importFileInput = document.getElementById("import-file");
    const hintTextEl = document.getElementById("hint-text");
    const sidebarEl = document.querySelector(".sidebar");
    const toggleSidebarBtn = document.getElementById("toggle-sidebar");

    // ===== åŸºæœ¬è¨­å®š =====
    const HEX_SIZE = 20;
    const GRID_MAX_X = 999;
    const GRID_MAX_Y = 999;

    const HEX_HEIGHT = 2 * HEX_SIZE;
    const HEX_WIDTH  = Math.sqrt(3) * HEX_SIZE;
    const HEX_VERT_SPACING  = 1.5 * HEX_SIZE;
    const HEX_HORIZ_SPACING = HEX_WIDTH;

    const EDGE_THICKNESS_WORLD = HEX_SIZE * 0.8;

    // ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç”¨ã‚­ãƒ¼
    const STORAGE_KEY = "hexmap_bases_firestore_backup";

    let scale = 0.35;
    let offsetX = 0;
    let offsetY = 0;
    const MIN_SCALE = 0.08;
    const MAX_SCALE = 3.0;

    let isPanning = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let selectedCell = null;

    // åŸºåœ°ãƒ‰ãƒ©ãƒƒã‚°ç”¨
    let draggingBaseId = null;
    let lastDragCell = null;

    // åŸºåœ°ä¸€è¦§ {id, name, cells:[{x,y}], anchor:{x,y}, level, status, thumb}
    const bases = [];
    let baseCount = 0;

    // Firestoreã‚¨ãƒ©ãƒ¼ã‚’ä½•åº¦ã‚‚ alert ã—ãªã„ã‚ˆã†ã«ã™ã‚‹ãƒ•ãƒ©ã‚°
    let firestoreErrorShown = false;

    // é¦–éƒ½ä¸­å¿ƒã¨è¡¨ç¤ºåŠå¾„ï¼ˆé¦–éƒ½Â±50ãƒã‚¹ï¼‰
    const CAPITAL_CENTER_X = 500;
    const CAPITAL_CENTER_Y = 500;
    const VIEW_RADIUS = 50;

    const VIEW_MIN_X = Math.max(0, CAPITAL_CENTER_X - VIEW_RADIUS);
    const VIEW_MAX_X = Math.min(GRID_MAX_X, CAPITAL_CENTER_X + VIEW_RADIUS);
    const VIEW_MIN_Y = Math.max(0, CAPITAL_CENTER_Y - VIEW_RADIUS);
    const VIEW_MAX_Y = Math.min(GRID_MAX_Y, CAPITAL_CENTER_Y + VIEW_RADIUS);

    // ===== ç ‚æ¼ ã‚¨ãƒªã‚¢ï¼ˆå¤šè§’å½¢ï¼‰=====
    const desertVerticesGrid = [
      { x: 482, y: 465 },
      { x: 465, y: 500 },
      { x: 482, y: 535 },
      { x: 517, y: 535 },
      { x: 535, y: 500 },
      { x: 517, y: 465 }
    ];

    // ===== é…ç½®ä¸å¯ï¼ˆèµ¤ï¼‰ãƒ¡ã‚¤ãƒ³å…­è§’ =====
    const blockedVerticesGrid = [
      { x: 483, y: 500 },
      { x: 491, y: 517 },
      { x: 508, y: 517 },
      { x: 517, y: 500 },
      { x: 508, y: 483 },
      { x: 491, y: 483 }
    ];

    // è¿½åŠ ã®å˜ä½“é…ç½®ä¸å¯ã‚»ãƒ«
    const extraBlockedCells = [
      { x: 489, y: 515 }, { x: 490, y: 516 }, { x: 490, y: 517 },
      { x: 491, y: 518 }, { x: 491, y: 585 }, { x: 492, y: 518 },
      { x: 493, y: 518 }, { x: 494, y: 518 }, { x: 489, y: 516 },
      { x: 489, y: 517 }, { x: 490, y: 518 }, { x: 490, y: 519 },
      { x: 491, y: 519 }, { x: 492, y: 519 }, { x: 493, y: 519 },
      { x: 517, y: 502 }, { x: 517, y: 501 }, { x: 517, y: 502 },
      { x: 518, y: 500 }, { x: 518, y: 499 }, { x: 518, y: 498 },
      { x: 517, y: 497 }, { x: 517, y: 496 }, { x: 517, y: 499 },
      { x: 517, y: 498 }, { x: 516, y: 497 }, { x: 516, y: 496 },
      { x: 489, y: 485 }, { x: 489, y: 484 }, { x: 489, y: 483 },
      { x: 490, y: 482 }, { x: 490, y: 484 }, { x: 490, y: 483 },
      { x: 491, y: 482 }, { x: 491, y: 481 }, { x: 492, y: 482 },
      { x: 492, y: 481 }, { x: 493, y: 482 }, { x: 494, y: 482 },
      { x: 490, y: 481 }, { x: 493, y: 481 }, { x: 494, y: 482 }
    ];

    let desertPolygonWorld = [];
    let blockedPolygonWorld = [];

    // åŸºåœ°ã®å½¢ï¼ˆaxialåº§æ¨™ åŠå¾„1ï¼‰
    const basePatternAxial = [
      { dq: 0, dr: 0 },
      { dq: 1, dr: 0 },
      { dq: 0, dr: 1 },
      { dq: -1, dr: 1 },
      { dq: -1, dr: 0 },
      { dq: 0, dr: -1 },
      { dq: 1, dr: -1 }
    ];

    // odd-r <-> axial
    function oddrToAxial(col, row) {
      const q = col - (row - (row & 1)) / 2;
      const r = row;
      return { q, r };
    }
    function axialToOddr(q, r) {
      const row = r;
      const col = q + (r - (r & 1)) / 2;
      return { x: col, y: row };
    }

    // ===== ã‚¹ãƒãƒ›/PC ã§èª¬æ˜æ–‡åˆ‡ã‚Šæ›¿ãˆ =====
    function updateHintText() {
      const isMobile = window.innerWidth <= 768;
      if (isMobile) {
        hintTextEl.textContent =
          "ğŸ“± 1æœ¬æŒ‡ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹• / ãƒ”ãƒ³ãƒã‚¤ãƒ³ãƒ»ã‚¢ã‚¦ãƒˆã§ã‚ºãƒ¼ãƒ  / ã‚¿ãƒƒãƒ—ã§ã‚»ãƒ«é¸æŠ / ç©ºããƒã‚¹ã‚’ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã§åŸºåœ°è¿½åŠ ï¼ˆæ©Ÿç¨®ã«ã‚ˆã£ã¦ã¯é•·æŠ¼ã—ï¼‹ã‚¿ãƒƒãƒ—ï¼‰ / åŸºåœ°ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹• / å·¦ä¸Šãƒœã‚¿ãƒ³ã§åŸºåœ°ä¸€è¦§ã‚’é–‹é–‰";
      } else {
        hintTextEl.textContent =
          "ğŸ–± ãƒ‰ãƒ©ãƒƒã‚°ç§»å‹• / ãƒ›ã‚¤ãƒ¼ãƒ«ã‚ºãƒ¼ãƒ  / ã‚¯ãƒªãƒƒã‚¯ã§ X,Y é¸æŠ / ç©ºããƒã‚¹ã‚’ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§åŸºåœ°è¿½åŠ  / åŸºåœ°ãƒã‚¹ã‚’ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§åå‰å¤‰æ›´ or å‰Šé™¤ / åŸºåœ°ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹• / å·¦ä¸Šãƒœã‚¿ãƒ³ã§åŸºåœ°ä¸€è¦§ã‚’é–‹é–‰";
      }
    }
    window.addEventListener("resize", updateHintText);
    updateHintText();

    // ===== é«˜è§£åƒåº¦å¯¾å¿œä»˜ã resizeCanvas =====
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      canvas.width  = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      if (!resizeCanvas.initialized) {
        resizeCanvas.initialized = true;

        const midX = CAPITAL_CENTER_X;
        const midY = CAPITAL_CENTER_Y;
        const midWorld = gridToWorld(midX, midY);

        offsetX = rect.width / 2 - midWorld.x * scale;
        offsetY = rect.height / 2 - midWorld.y * scale;

        desertPolygonWorld  = desertVerticesGrid.map(v => gridToWorld(v.x, v.y));
        blockedPolygonWorld = blockedVerticesGrid.map(v => gridToWorld(v.x, v.y));
      }
      draw();
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // ===== åº§æ¨™å¤‰æ› =====
    function gridToWorld(gx, gy) {
      const wx = HEX_HORIZ_SPACING * (gx + (gy & 1) * 0.5);
      const wy = HEX_VERT_SPACING * gy;
      return { x: wx, y: wy };
    }
    function worldToScreen(wx, wy) {
      return { x: wx * scale + offsetX, y: wy * scale + offsetY };
    }
    function screenToWorld(sx, sy) {
      return { x: (sx - offsetX) / scale, y: (sy - offsetY) / scale };
    }
    function screenToGrid(sx, sy) {
      const w = screenToWorld(sx, sy);
      let gy = Math.round(w.y / HEX_VERT_SPACING);
      gy = Math.max(0, Math.min(GRID_MAX_Y, gy));
      const rowOffset = (gy & 1) ? HEX_HORIZ_SPACING * 0.5 : 0;
      let gx = Math.round((w.x - rowOffset) / HEX_HORIZ_SPACING);
      gx = Math.max(0, Math.min(GRID_MAX_X, gx));
      return { x: gx, y: gy };
    }

    // ===== å¹¾ä½•ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
    function pointInPolygon(point, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect =
          ((yi > point.y) !== (yj > point.y)) &&
          (point.x < (xj - xi) * (point.y - yi) / (yj - yi + 1e-9) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    function pointToSegmentDistance(p, a, b) {
      const vx = b.x - a.x;
      const vy = b.y - a.y;
      const wx = p.x - a.x;
      const wy = p.y - a.y;
      const c1 = vx * wx + vy * wy;
      if (c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y);
      const c2 = vx * vx + vy * vy;
      if (c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y);
      const t = c1 / c2;
      const projx = a.x + t * vx;
      const projy = a.y + t * vy;
      return Math.hypot(p.x - projx, p.y - projy);
    }
    function distanceToPolygonEdges(p, polygon) {
      let minD = Infinity;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const a = polygon[j];
        const b = polygon[i];
        const d = pointToSegmentDistance(p, a, b);
        if (d < minD) minD = d;
      }
      return minD;
    }

    // é…ç½®ä¸å¯ã‚»ãƒ«åˆ¤å®š
    function isBlockedCell(gx, gy) {
      for (const c of extraBlockedCells) {
        if (c.x === gx && c.y === gy) return true;
      }
      const w = gridToWorld(gx, gy);
      const inside = pointInPolygon(w, blockedPolygonWorld);
      const dist = distanceToPolygonEdges(w, blockedPolygonWorld);
      return inside || dist <= EDGE_THICKNESS_WORLD;
    }

    // ===== åŸºåœ°ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
    function findBaseAtCell(gx, gy) {
      return bases.find(b => b.cells.some(c => c.x === gx && c.y === gy)) || null;
    }
    function createBaseCellsForAnchor(gx, gy, ignoreBaseId = null) {
      const { q, r } = oddrToAxial(gx, gy);
      const cells = basePatternAxial.map(off => {
        const oq = q + off.dq;
        const or = r + off.dr;
        return axialToOddr(oq, or);
      });

      for (const c of cells) {
        if (c.x < 0 || c.x > GRID_MAX_X || c.y < 0 || c.y > GRID_MAX_Y) return null;
        if (isBlockedCell(c.x, c.y)) return null;
        for (const b of bases) {
          if (ignoreBaseId && b.id === ignoreBaseId) continue;
          if (b.cells.some(d => d.x === c.x && d.y === c.y)) return null;
        }
      }
      return cells;
    }
    function deleteBaseById(id) {
      const idx = bases.findIndex(b => b.id === id);
      if (idx !== -1) {
        bases.splice(idx, 1);
        saveBases();
      }
    }

    // ===== ä¿å­˜ãƒ»åŒæœŸï¼ˆFirestore + ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼‰ =====
    function makeSerializableData() {
      return {
        bases: bases.map(b => ({
          id: b.id,
          name: b.name,
          anchor: b.anchor,
          level: b.level ?? null,
          status: b.status || "ä¸æ˜",
          thumb: b.thumb || null
        }))
      };
    }

    function saveLocalBackup() {
      const data = makeSerializableData();
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      } catch (e) {
        console.warn("localStorage backup error:", e);
      }
    }

    function loadLocalBackup() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      try {
        const data = JSON.parse(raw);
        applyBasesFromRemote(data);
      } catch (e) {
        console.warn("local backup parse error:", e);
      }
    }

    async function saveBases() {
      const data = makeSerializableData();
      // å…ˆã«ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
      saveLocalBackup();

      data.updatedAt = serverTimestamp();
      try {
        await setDoc(mapDocRef, data);
      } catch (e) {
        console.warn("saveBases Firestore error:", e);
        if (!firestoreErrorShown) {
          firestoreErrorShown = true;
          alert("Firebase Firestore ã¸ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\nãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã¾ãŸã¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ«ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚\nï¼ˆã“ã®ç«¯æœ«ã«ã¯ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ¸ˆã¿ï¼‰");
        }
      }
    }

    function applyBasesFromRemote(data) {
      if (!data || !Array.isArray(data.bases)) return;
      bases.length = 0;
      data.bases.forEach(rec => {
        if (!rec.anchor) return;
        const anchor = rec.anchor;
        const cells = createBaseCellsForAnchor(anchor.x, anchor.y, null);
        if (!cells) return;
        bases.push({
          id: rec.id || (Date.now().toString(36) + Math.random().toString(36).slice(2,7)),
          name: rec.name || "åŸºåœ°",
          cells,
          anchor,
          level: rec.level ?? null,
          status: rec.status || "ä¸æ˜",
          thumb: rec.thumb || null
        });
      });
      baseCount = bases.length;
      updateBaseListUI();
      draw();
    }

    // èµ·å‹•æ™‚ï¼šFirestore â†’ ãƒ€ãƒ¡ãªã‚‰ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
    (async () => {
      try {
        const snap = await getDoc(mapDocRef);
        if (snap.exists()) {
          applyBasesFromRemote(snap.data());
        } else {
          // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒç„¡ã„å ´åˆã¯ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’è©¦ã™
          loadLocalBackup();
        }
      } catch (e) {
        console.warn("initial getDoc error:", e);
        loadLocalBackup();
      }

      // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è³¼èª­ï¼ˆã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¸ï¼‰
      onSnapshot(
        mapDocRef,
        (snap) => {
          if (!snap.exists()) return;
          applyBasesFromRemote(snap.data());
        },
        (err) => {
          console.warn("onSnapshot error:", err);
          loadLocalBackup();
        }
      );
    })();

    // ===== ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ =====
    function importBasesFromData(data) {
      if (!data || !Array.isArray(data.bases)) {
        alert("ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹JSONã®å½¢å¼ãŒä¸æ­£ã§ã™ã€‚");
        return;
      }
      if (!confirm("ç¾åœ¨ã®åŸºåœ°ãƒ‡ãƒ¼ã‚¿ã‚’å…¨ã¦ç½®ãæ›ãˆã¾ã™ã‹ï¼Ÿ")) return;

      bases.length = 0;
      data.bases.forEach(rec => {
        if (!rec.anchor) return;
        const anchor = rec.anchor;
        const cells = createBaseCellsForAnchor(anchor.x, anchor.y, null);
        if (!cells) return;
        bases.push({
          id: rec.id || (Date.now().toString(36) + Math.random().toString(36).slice(2,7)),
          name: rec.name || "åŸºåœ°",
          cells,
          anchor,
          level: rec.level ?? null,
          status: rec.status || "ä¸æ˜",
          thumb: rec.thumb || null
        });
      });
      baseCount = bases.length;
      saveBases(); // Firestore + ãƒ­ãƒ¼ã‚«ãƒ«ã«åæ˜ 
    }

    function exportBasesToFile() {
      const data = makeSerializableData();
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "bases.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function handleImportFile(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        try {
          const data = JSON.parse(ev.target.result);
          importBasesFromData(data);
        } catch (err) {
          console.error(err);
          alert("JSONã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
        } finally {
          importFileInput.value = "";
        }
      };
      reader.readAsText(file, "utf-8");
    }

    exportBtn.addEventListener("click", exportBasesToFile);
    importBtn.addEventListener("click", () => importFileInput.click());
    importFileInput.addEventListener("change", handleImportFile);

    // ===== æŠ˜ã‚ŠãŸãŸã¿ãƒœã‚¿ãƒ³ =====
    toggleSidebarBtn.addEventListener("click", () => {
      const collapsed = sidebarEl.classList.toggle("collapsed");
      toggleSidebarBtn.textContent = collapsed ? "ï¼‹" : "ï¼";
    });

    // ===== åŸºåœ°ãƒ¡ã‚¿ç·¨é›† =====
    function editBaseMeta(base) {
      if (!base) return;
      let newName = prompt("åŸºåœ°åï¼ˆç©ºæ¬„ã§å¤‰æ›´ãªã—ï¼‰", base.name);
      if (newName !== null && newName.trim() !== "") {
        base.name = newName.trim();
      }

      let newLevel = prompt(
        "åŸºåœ°ãƒ¬ãƒ™ãƒ«ï¼ˆæ•°å­— / ç©ºæ¬„ã§å¤‰æ›´ãªã—ï¼‰",
        base.level != null ? String(base.level) : ""
      );
      if (newLevel !== null && newLevel.trim() !== "") {
        const num = Number(newLevel.trim());
        if (!isNaN(num)) base.level = num;
      }

      let newThumb = prompt(
        "ã‚µãƒ ãƒã‚¤ãƒ«ç”»åƒURLï¼ˆç©ºæ¬„ã§å‰Šé™¤ / å¤‰æ›´ãªã—ãªã‚‰ã‚­ãƒ£ãƒ³ã‚»ãƒ«ï¼‰",
        base.thumb || ""
      );
      if (newThumb !== null) {
        newThumb = newThumb.trim();
        base.thumb = newThumb === "" ? null : newThumb;
      }

      saveBases();
    }

    function renameOrDeleteBase(base) {
      if (!base) return;
      let newName = prompt(
        "åŸºåœ°åã‚’å¤‰æ›´ã—ã¦ãã ã•ã„ï¼ˆç©ºæ¬„ã§å‰Šé™¤ã€ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã§ä½•ã‚‚ã—ãªã„ï¼‰",
        base.name
      );
      if (newName === null) return;
      newName = newName.trim();
      if (newName === "") {
        if (confirm(`åŸºåœ°ã€Œ${base.name}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
          deleteBaseById(base.id);
        }
        return;
      }
      base.name = newName;
      saveBases();
    }

    function addBaseAtGrid(gx, gy) {
      const cells = createBaseCellsForAnchor(gx, gy, null);
      if (!cells) return;

      const defaultName = "åŸºåœ°" + String(++baseCount).padStart(3, "0");
      let name = prompt(
        "åŸºåœ°åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆã‚­ãƒ£ãƒ³ã‚»ãƒ«ã§é…ç½®ä¸­æ­¢ï¼‰",
        defaultName
      );
      if (name === null) {
        baseCount--;
        return;
      }
      if (name.trim() === "") name = defaultName;

      const id = Date.now().toString(36) + Math.random().toString(36).slice(2, 7);
      bases.push({
        id,
        name,
        cells,
        anchor: { x: gx, y: gy },
        level: null,
        status: "ä¸æ˜",
        thumb: null
      });
      saveBases();
    }

    function moveBaseToGrid(baseId, gx, gy) {
      const base = bases.find(b => b.id === baseId);
      if (!base) return;

      const cells = createBaseCellsForAnchor(gx, gy, baseId);
      if (!cells) return;

      base.cells = cells;
      base.anchor = { x: gx, y: gy };
      saveBases();
    }

    // ===== åŸºåœ°ãƒªã‚¹ãƒˆUI =====
    function updateBaseListUI() {
      baseListEl.innerHTML = "";
      bases.forEach((b) => {
        const li = document.createElement("li");
        li.className = "base-item";

        const thumbDiv = document.createElement("div");
        thumbDiv.className = "base-item-thumb";
        if (b.thumb) {
          thumbDiv.style.backgroundImage = `url(${b.thumb})`;
        }

        const infoDiv = document.createElement("div");
        infoDiv.className = "base-item-info";

        const nameRow = document.createElement("div");
        nameRow.className = "base-item-name-row";

        const nameSpan = document.createElement("span");
        nameSpan.className = "base-name";
        nameSpan.textContent = b.name;

        const levelSpan = document.createElement("span");
        levelSpan.className = "base-level";
        levelSpan.textContent = b.level != null ? `Lv.${b.level}` : "Lv.-";

        nameRow.appendChild(nameSpan);
        nameRow.appendChild(levelSpan);

        const metaRow = document.createElement("div");
        metaRow.className = "base-item-meta-row";

        const anchor = b.anchor || b.cells[0];
        const coordSpan = document.createElement("span");
        coordSpan.className = "base-coord";
        coordSpan.textContent = `X${anchor.x} Y${anchor.y}`;

        const statusDiv = document.createElement("div");
        statusDiv.className = "base-status";

        ["å‚åŠ ", "ä¸å‚åŠ ", "ä¸æ˜"].forEach(st => {
          const btn = document.createElement("button");
          btn.dataset.status = st;
          btn.textContent = st;
          if (b.status === st) {
            btn.classList.add("active");
          }
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            b.status = st;
            saveBases();
          });
          statusDiv.appendChild(btn);
        });

        metaRow.appendChild(coordSpan);
        metaRow.appendChild(statusDiv);

        infoDiv.appendChild(nameRow);
        infoDiv.appendChild(metaRow);

        li.appendChild(thumbDiv);
        li.appendChild(infoDiv);

        li.addEventListener("dblclick", (e) => {
          e.stopPropagation();
          editBaseMeta(b);
        });

        baseListEl.appendChild(li);
      });
    }

    // ===== æç”»ãƒ˜ãƒ«ãƒ‘ãƒ¼ =====
    function drawRoundedRect(ctx, x, y, w, h, r) {
      const radius = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + w - radius, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
      ctx.lineTo(x + w, y + h - radius);
      ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
      ctx.lineTo(x + radius, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    function drawHexCenter(wx, wy, strokeStyle, fillStyle, lineWidth = 1) {
      const { x: sx, y: sy } = worldToScreen(wx, wy);
      const s = HEX_SIZE * scale;
      const w = Math.sqrt(3) * s;
      const h = s;

      const pts = [
        { x: sx,        y: sy - h },
        { x: sx + w/2,  y: sy - h/2 },
        { x: sx + w/2,  y: sy + h/2 },
        { x: sx,        y: sy + h },
        { x: sx - w/2,  y: sy + h/2 },
        { x: sx - w/2,  y: sy - h/2 }
      ];

      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.closePath();

      if (fillStyle) {
        ctx.fillStyle = fillStyle;
        ctx.fill();
      }
      if (strokeStyle) {
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = lineWidth;
        ctx.stroke();
      }
    }

    function drawGrid() {
      const rect = canvas.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;

      const margin = 80 / scale;
      const topLeftWorld = screenToWorld(-margin, -margin);
      const bottomRightWorld = screenToWorld(w + margin, h + margin);

      let gyMin = Math.floor(topLeftWorld.y / HEX_VERT_SPACING) - 2;
      let gyMax = Math.ceil(bottomRightWorld.y / HEX_VERT_SPACING) + 2;

      gyMin = Math.max(0, gyMin);
      gyMax = Math.min(GRID_MAX_Y, gyMax);
      gyMin = Math.max(gyMin, VIEW_MIN_Y);
      gyMax = Math.min(gyMax, VIEW_MAX_Y);

      for (let gy = gyMin; gy <= gyMax; gy++) {
        const rowOffset = (gy & 1) ? HEX_HORIZ_SPACING * 0.5 : 0;

        let gxMin = Math.floor((topLeftWorld.x - rowOffset) / HEX_HORIZ_SPACING) - 2;
        let gxMax = Math.ceil((bottomRightWorld.x - rowOffset) / HEX_HORIZ_SPACING) + 2;

        gxMin = Math.max(0, gxMin);
        gxMax = Math.min(GRID_MAX_X, gxMax);
        gxMin = Math.max(gxMin, VIEW_MIN_X);
        gxMax = Math.min(gxMax, VIEW_MAX_X);

        for (let gx = gxMin; gx <= gxMax; gx++) {
          const { x: wx, y: wy } = gridToWorld(gx, gy);
          const center = { x: wx, y: wy };

          const isSelectedCell =
            selectedCell && selectedCell.x === gx && selectedCell.y === gy;

          const desertIn = pointInPolygon(center, desertPolygonWorld);
          const desertDist = distanceToPolygonEdges(center, desertPolygonWorld);
          const inDesert = desertIn || desertDist <= EDGE_THICKNESS_WORLD;

          const blkIn = pointInPolygon(center, blockedPolygonWorld);
          const blkDist = distanceToPolygonEdges(center, blockedPolygonWorld);
          const inBlockedPolygon = blkIn || blkDist <= EDGE_THICKNESS_WORLD;

          let inExtraBlocked = false;
          for (const c of extraBlockedCells) {
            if (gx === c.x && gy === c.y) {
              inExtraBlocked = true;
              break;
            }
          }
          const inBlocked = inBlockedPolygon || inExtraBlocked;

          const baseAt = findBaseAtCell(gx, gy);

          let stroke, fill, lw;
          if (isSelectedCell) {
            stroke = "rgba(255,221,85,0.7)";
            fill   = "rgba(255,221,85,0.18)";
            lw = 1.5;
          } else if (inBlocked) {
            stroke = "rgba(255, 80, 80, 0.75)";
            fill   = "rgba(255, 80, 80, 0.25)";
            lw = 1.2;
          } else if (baseAt) {
            if (baseAt.status === "å‚åŠ ") {
              stroke = "rgba(120, 255, 160, 0.9)";
              fill   = "rgba(90, 230, 150, 0.30)";
            } else if (baseAt.status === "ä¸å‚åŠ ") {
              stroke = "rgba(255, 140, 140, 0.9)";
              fill   = "rgba(255, 110, 110, 0.30)";
            } else {
              stroke = "rgba(255, 230, 160, 0.9)";
              fill   = "rgba(255, 220, 140, 0.28)";
            }
            lw = 1.4;
          } else {
            stroke = inDesert
              ? "rgba(230,210,120,0.18)"
              : "rgba(210, 255, 210, 0.14)";
            fill   = null;
            lw = 0.8;
          }

          drawHexCenter(wx, wy, stroke, fill, lw);
        }
      }
    }

    function drawDesertOutline() {
      ctx.beginPath();
      desertPolygonWorld.forEach((p, i) => {
        const s = worldToScreen(p.x, p.y);
        if (i === 0) ctx.moveTo(s.x, s.y);
        else ctx.lineTo(s.x, s.y);
      });
      ctx.closePath();
      ctx.strokeStyle = "rgba(230,210,120,0.85)";
      ctx.lineWidth = 1.4;
      ctx.stroke();
    }

    function drawBlockedOutline() {
      ctx.beginPath();
      blockedPolygonWorld.forEach((p, i) => {
        const s = worldToScreen(p.x, p.y);
        if (i === 0) ctx.moveTo(s.x, s.y);
        else ctx.lineTo(s.x, s.y);
      });
      ctx.closePath();
      ctx.strokeStyle = "rgba(255, 80, 80, 0.85)";
      ctx.lineWidth = 1.2;
      ctx.stroke();
    }

    function drawBaseLabels() {
      ctx.save();

      bases.forEach(b => {
        const anchor = b.anchor || b.cells[0];
        const world = gridToWorld(anchor.x, anchor.y);
        const screen = worldToScreen(world.x, world.y);

        const statusText = b.status || "ä¸æ˜";
        const levelText  = b.level != null ? `Lv.${b.level}` : "Lv.-";
        const statusLine = `${statusText} ${levelText}`;
        const coordText  = `X${anchor.x} Y${anchor.y}`;
        const nameText   = b.name;

        const baseFontSize = Math.max(8, Math.min(16, 12 * scale * 2.5));
        const lineHeight   = baseFontSize * 1.1;

        ctx.font = `${baseFontSize}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;

        const nameWidth   = ctx.measureText(nameText).width;
        const statusWidth = ctx.measureText(statusLine).width;
        const coordWidth  = ctx.measureText(coordText).width;

        const textWidth = Math.max(nameWidth, statusWidth, coordWidth);

        const thumbSize = lineHeight * 1.8;
        const paddingX  = 6 * scale * 2;
        const paddingY  = 4 * scale * 2;

        const panelWidth  = Math.max(textWidth, thumbSize) + paddingX * 2;
        const panelHeight = paddingY * 2 + thumbSize + 4 + lineHeight * 3;

        const offsetAboveHex = HEX_SIZE * scale * 1.6;
        const panelX = screen.x - panelWidth / 2;
        const panelY = screen.y - offsetAboveHex - panelHeight;

        ctx.globalAlpha = 0.92;
        ctx.fillStyle = "rgba(5, 6, 8, 0.92)";
        drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 6);
        ctx.fill();

        ctx.globalAlpha = 1.0;
        ctx.strokeStyle = "rgba(255, 255, 255, 0.16)";
        ctx.lineWidth = 1;
        drawRoundedRect(ctx, panelX, panelY, panelWidth, panelHeight, 6);
        ctx.stroke();

        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.font = `${baseFontSize}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;

        let cursorY = panelY + paddingY;

        const thumbX = screen.x - thumbSize / 2;
        const thumbY = cursorY;

        ctx.fillStyle = "rgba(255,255,255,0.10)";
        drawRoundedRect(ctx, thumbX, thumbY, thumbSize, thumbSize, 4);
        ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.85)";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const initial = (nameText && nameText.trim().length > 0)
          ? nameText.trim().charAt(0)
          : "?";
        ctx.fillText(initial, screen.x, thumbY + thumbSize / 2);

        cursorY += thumbSize + 4;

        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.fillStyle = "rgba(255,255,255,0.96)";
        ctx.fillText(nameText, screen.x, cursorY);
        cursorY += lineHeight;

        ctx.fillStyle =
          statusText === "å‚åŠ "
            ? "rgba(150, 255, 190, 0.96)"
            : statusText === "ä¸å‚åŠ "
            ? "rgba(255, 170, 170, 0.96)"
            : "rgba(255, 230, 170, 0.96)";
        ctx.fillText(statusLine, screen.x, cursorY);
        cursorY += lineHeight;

        ctx.fillStyle = "rgba(210, 230, 255, 0.96)";
        ctx.fillText(coordText, screen.x, cursorY);
      });

      ctx.restore();
    }

    function drawRegionLabels() {
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.textAlign = "center";

      let cx = 0, cy = 0;
      desertVerticesGrid.forEach(v => { cx += v.x; cy += v.y; });
      cx /= desertVerticesGrid.length;
      cy /= desertVerticesGrid.length;
      const desertWorld = gridToWorld(cx, cy);
      const desertScreen = worldToScreen(desertWorld.x, desertWorld.y);

      let fontSize = Math.max(10, Math.min(22, 14 * scale * 2.5));
      ctx.font = `${fontSize}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
      ctx.textBaseline = "middle";
      ctx.fillText("ç ‚æ¼ ã‚¨ãƒªã‚¢", desertScreen.x, desertScreen.y);

      const grassGrid = { x: 500, y: 550 };
      const grassWorld = gridToWorld(grassGrid.x, grassGrid.y);
      const grassScreen = worldToScreen(grassWorld.x, grassWorld.y);
      ctx.fillStyle = "rgba(200,255,200,0.9)";
      ctx.fillText("èŠç”Ÿã‚¨ãƒªã‚¢", grassScreen.x, grassScreen.y);

      const fixedLabels = [
        { x: 500, y: 500, text: "é…ç½®ä¸å¯ã‚¨ãƒªã‚¢" },
        { x: 517, y: 500, text: "ç ²å°3å·" },
        { x: 491, y: 483, text: "ç ²å°2å·" },
        { x: 491, y: 517, text: "ç ²å°1å·" }
      ];

      fontSize = Math.max(9, Math.min(18, 12 * scale * 2));
      ctx.font = `${fontSize}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.textBaseline = "top";

      fixedLabels.forEach(obj => {
        const w = gridToWorld(obj.x, obj.y);
        const s = worldToScreen(w.x, w.y);
        const offset = HEX_SIZE * scale * 1.3;
        ctx.fillText(obj.text, s.x, s.y + offset);
      });

      ctx.restore();
    }

    function draw() {
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0, 0, rect.width, rect.height);
      drawGrid();
      drawDesertOutline();
      drawBlockedOutline();
      drawRegionLabels();
      drawBaseLabels();

      zoomDisplay.textContent = Math.round(scale * 100) + "%";
      cellDisplay.textContent = selectedCell
        ? `X${selectedCell.x} Y${selectedCell.y}`
        : "â€”";
    }

    // ===== æ“ä½œ =====
    canvas.addEventListener("mousedown", (e) => {
      if (e.button !== 0) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;

      const base = findBaseAtCell(cell.x, cell.y);
      if (base) {
        draggingBaseId = base.id;
        lastDragCell = cell;
        canvas.classList.add("dragging");
      } else {
        isPanning = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        canvas.classList.add("dragging");
      }
      draw();
    });

    window.addEventListener("mousemove", (e) => {
      if (draggingBaseId) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const cell = screenToGrid(mx, my);
        if (!lastDragCell || cell.x !== lastDragCell.x || cell.y !== lastDragCell.y) {
          moveBaseToGrid(draggingBaseId, cell.x, cell.y);
          lastDragCell = cell;
        }
        return;
      }

      if (!isPanning) return;
      const dx = e.clientX - lastMouseX;
      const dy = e.clientY - lastMouseY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      offsetX += dx;
      offsetY += dy;
      draw();
    });

    window.addEventListener("mouseup", () => {
      isPanning = false;
      draggingBaseId = null;
      lastDragCell = null;
      canvas.classList.remove("dragging");
    });

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      const zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
      let newScale = scale + zoomDelta * scale;
      newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
      if (newScale === scale) return;

      const worldBefore = screenToWorld(mx, my);
      scale = newScale;
      const worldAfter = screenToWorld(mx, my);

      offsetX += (worldAfter.x - worldBefore.x) * scale;
      offsetY += (worldAfter.y - worldBefore.y) * scale;

      draw();
    }, { passive: false });

    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;
      draw();
    });

    canvas.addEventListener("dblclick", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;

      const base = findBaseAtCell(cell.x, cell.y);
      if (base) {
        renameOrDeleteBase(base);
      } else {
        addBaseAtGrid(cell.x, cell.y);
      }
    });

    canvas.addEventListener("touchstart", (e) => {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mx = t.clientX - rect.left;
      const my = t.clientY - rect.top;
      const cell = screenToGrid(mx, my);
      selectedCell = cell;

      const base = findBaseAtCell(cell.x, cell.y);
      if (base) {
        draggingBaseId = base.id;
        lastDragCell = cell;
      } else {
        isPanning = true;
        lastMouseX = t.clientX;
        lastMouseY = t.clientY;
      }
      canvas.classList.add("dragging");
      draw();
    }, { passive: true });

    canvas.addEventListener("touchmove", (e) => {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mx = t.clientX - rect.left;
      const my = t.clientY - rect.top;

      if (draggingBaseId) {
        const cell = screenToGrid(mx, my);
        if (!lastDragCell || cell.x !== lastDragCell.x || cell.y !== lastDragCell.y) {
          moveBaseToGrid(draggingBaseId, cell.x, cell.y);
          lastDragCell = cell;
        }
        return;
      }

      if (!isPanning) return;
      const dx = t.clientX - lastMouseX;
      const dy = t.clientY - lastMouseY;
      lastMouseX = t.clientX;
      lastMouseY = t.clientY;
      offsetX += dx;
      offsetY += dy;
      draw();
    }, { passive: true });

    window.addEventListener("touchend", () => {
      isPanning = false;
      draggingBaseId = null;
      lastDragCell = null;
      canvas.classList.remove("dragging");
    });
  </script>
</body>
</html>
